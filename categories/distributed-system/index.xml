<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Distributed System - 分类 - Victor's Code Journey</title><link>http://www.victorchu.info/categories/distributed-system/</link><description>Distributed System - 分类 - Victor's Code Journey</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><managingEditor>victorchu0610@outlook.com (victorchutian)</managingEditor><webMaster>victorchu0610@outlook.com (victorchutian)</webMaster><lastBuildDate>Mon, 05 Dec 2022 11:42:33 +0800</lastBuildDate><atom:link href="http://www.victorchu.info/categories/distributed-system/" rel="self" type="application/rss+xml"/><item><title>分布式锁实现-DB</title><link>http://www.victorchu.info/posts/2022/12/8a3cfb04/</link><pubDate>Mon, 05 Dec 2022 11:42:33 +0800</pubDate><author><name>victorchutian</name></author><guid>http://www.victorchu.info/posts/2022/12/8a3cfb04/</guid><description><![CDATA[<div class="featured-image">
                <img src="/feature-images/distribute.webp" referrerpolicy="no-referrer">
            </div><p>在<a href="posts/2020/05/4eb3381c/" rel="">前面</a>我们简单介绍过分布式锁，本篇文章会介绍如果基于数据库(Mysql)实现分布式锁。基于Mysql实现锁的一般场景是对性能要求不高，且不希望因为分布式锁而引入新的组件的。</p>]]></description></item><item><title>分布式一致性模型</title><link>http://www.victorchu.info/posts/2022/03/15af3555/</link><pubDate>Thu, 24 Mar 2022 21:30:23 +0800</pubDate><author><name>victorchutian</name></author><guid>http://www.victorchu.info/posts/2022/03/15af3555/</guid><description><![CDATA[<div class="featured-image">
                <img src="/feature-images/distribute.webp" referrerpolicy="no-referrer">
            </div><p>在前面的分布式系统理论中，我们了解到网络分区是大概率会发生的。分布式系统需要考虑在面临分区分区问题时，选择一致性还是高可用。本文将展开介绍分布式一致性模型(并行计算不涉及事务)。</p>]]></description></item><item><title>分布式系统理论-CAP</title><link>http://www.victorchu.info/posts/2022/03/c274555b/</link><pubDate>Mon, 21 Mar 2022 17:49:16 +0800</pubDate><author><name>victorchutian</name></author><guid>http://www.victorchu.info/posts/2022/03/c274555b/</guid><description><![CDATA[<div class="featured-image">
                <img src="/feature-images/distribute.webp" referrerpolicy="no-referrer">
            </div><p>CAP定理(CAP theorem)，又被称作布鲁尔定理(Brewer&rsquo;s theorem)，它指出对于一个分布式计算系统来说，不可能同时满足以下三点:</p>
<ul>
<li>一致性 (Consistency): 一个写操作返回成功，那么之后的读请求都必须读到这个新数据；如果返回失败，那么所有读操作都不能读到这个数据。所有节点访问同一份最新的数据。</li>
<li>可用性 (Availability): 保证每个请求都会收到关于它是成功还是失败的响应。无论您是要读取还是写入，您都会得到一些响应。</li>
<li>分区容错性 (Partition tolerance): 能容忍网络分区，在网络断开(不是延迟)的情况下，被分隔的节点仍能正常对外提供服务。</li>
</ul>
<p><img class="tw-inline" loading="lazy" src='/posts/2022/03/c274555b/CAP.webp'    height="342" width="343"></p>]]></description></item><item><title>分布式追踪系统</title><link>http://www.victorchu.info/posts/2022/01/a892384f/</link><pubDate>Tue, 11 Jan 2022 22:35:14 +0800</pubDate><author><name>victorchutian</name></author><guid>http://www.victorchu.info/posts/2022/01/a892384f/</guid><description><![CDATA[<div class="featured-image">
                <img src="/feature-images/distribute.webp" referrerpolicy="no-referrer">
            </div><p>随着微服务和云原生开发的兴起，越来越多应用基于分布式进行开发，大型应用拆分为微服务后，服务之间的依赖和调用变得越来越复杂。微服务提供了一个强大的体系结构，但也有面临了一些挑战，例如：</p>
<ul>
<li>如何调试和观察跨复杂网络的分布式调用？</li>
<li>如何分析服务链路的瓶颈并对其进行调优？</li>
<li>如何快速进行服务链路的故障发现？</li>
<li>&hellip;&hellip;</li>
</ul>
<p>为了更好地维护这些服务，软件领域出现了 Observability 思想。</p>]]></description></item><item><title>分布式锁简介</title><link>http://www.victorchu.info/posts/2020/05/4eb3381c/</link><pubDate>Mon, 25 May 2020 11:09:22 +0800</pubDate><author><name>victorchutian</name></author><guid>http://www.victorchu.info/posts/2020/05/4eb3381c/</guid><description><![CDATA[<div class="featured-image">
                <img src="/feature-images/distribute.webp" referrerpolicy="no-referrer">
            </div><p>在分布式场景中分布式锁是一种很常见的需求。实现一个分布式锁要注意以下几点:</p>
<ul>
<li>安全: 独享（相互排斥）。在任意一个时刻，只有一个客户端持有锁。</li>
<li>锁失效保护: 无死锁。即便持有锁的客户端崩溃（crashed)或者网络被分裂（gets partitioned)，锁仍然可以被获取。</li>
<li>集群容错。 只要大部分节点都活着，客户端就可以获取和释放锁。</li>
<li>原子性：获取释放锁最好是原子操作，获取释放锁的性能要好。</li>
<li>可重入(optional): 同一个线程在没有释放锁之前，如果想再次操作，可以直接获得锁。</li>
<li>阻塞/非阻塞(optional)：若没有获取到锁，返回获取失败。</li>
</ul>]]></description></item></channel></rss>