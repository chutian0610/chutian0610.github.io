<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>设计模式 - 系列 - Victor's Code Journey</title><link>http://www.victorchu.info/series/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link><description>设计模式 - 系列 - Victor's Code Journey</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><managingEditor>victorchu0610@outlook.com (victorchutian)</managingEditor><webMaster>victorchu0610@outlook.com (victorchutian)</webMaster><lastBuildDate>Sat, 28 Jan 2017 11:36:22 +0800</lastBuildDate><atom:link href="http://www.victorchu.info/series/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="self" type="application/rss+xml"/><item><title>设计模式之控制反转</title><link>http://www.victorchu.info/posts/2017/01/a9694c7d/</link><pubDate>Sat, 28 Jan 2017 11:36:22 +0800</pubDate><author><name>victorchutian</name></author><guid>http://www.victorchu.info/posts/2017/01/a9694c7d/</guid><description><![CDATA[<div class="featured-image">
                <img src="/feature-images/architecture.webp" referrerpolicy="no-referrer">
            </div><p>控制反转（Inversion of Control）是一种是面向对象编程中的一种设计原则，用来减低计算机代码之间的耦合度。其基本思想是：借助于“第三方”实现具有依赖关系的对象之间的解耦。</p>]]></description></item><item><title>设计模式之访问者模式</title><link>http://www.victorchu.info/posts/2017/01/e81a254a/</link><pubDate>Thu, 26 Jan 2017 11:36:22 +0800</pubDate><author><name>victorchutian</name></author><guid>http://www.victorchu.info/posts/2017/01/e81a254a/</guid><description><![CDATA[<div class="featured-image">
                <img src="/feature-images/architecture.webp" referrerpolicy="no-referrer">
            </div><p>访问者模式是一种较为复杂的行为型设计模式，它包含访问者和被访问元素两个主要组成部分，这些被访问的元素通常具有不同的类型，且不同的访问者可以对它们进行不同的访问操作。问者模式使得用户可以在不修改现有系统的情况下扩展系统的功能，为这些不同类型的元素增加新的操作。在使用访问者模式时，被访问元素通常不是单独存在的，它们存储在一个集合中，这个集合被称为“对象结构”，访问者通过遍历对象结构实现对其中存储的元素的逐个操作。</p>]]></description></item><item><title>设计模式之依赖注入</title><link>http://www.victorchu.info/posts/2017/01/21e1fc41/</link><pubDate>Thu, 26 Jan 2017 11:36:22 +0800</pubDate><author><name>victorchutian</name></author><guid>http://www.victorchu.info/posts/2017/01/21e1fc41/</guid><description><![CDATA[<div class="featured-image">
                <img src="/feature-images/architecture.webp" referrerpolicy="no-referrer">
            </div><p>依赖关系注入是一种软件设计模式，其中一个或多个依赖关系（或服务）被注入或通过引用传递到依赖对象（或客户端）中，并成为客户端状态的一部分。该模式将客户端依赖项的创建与其自身行为分开，这允许程序设计松散耦合并遵循控制反转和单一责任原则。</p>
<p>简单来说，依赖注入通过请求获取它们的子组件而不是通过创建它们来获取, 将依赖关系的创建与其自身行为分开。</p>]]></description></item><item><title>设计模式之单例模式</title><link>http://www.victorchu.info/posts/2017/01/1a4b62fe/</link><pubDate>Wed, 25 Jan 2017 11:36:22 +0800</pubDate><author><name>victorchutian</name></author><guid>http://www.victorchu.info/posts/2017/01/1a4b62fe/</guid><description><![CDATA[<div class="featured-image">
                <img src="/feature-images/architecture.webp" referrerpolicy="no-referrer">
            </div><p>单例模式(Singleton Pattern)：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。</p>]]></description></item><item><title>设计模式之代理模式</title><link>http://www.victorchu.info/posts/2017/01/907a70d0/</link><pubDate>Tue, 24 Jan 2017 11:36:22 +0800</pubDate><author><name>victorchutian</name></author><guid>http://www.victorchu.info/posts/2017/01/907a70d0/</guid><description><![CDATA[<div class="featured-image">
                <img src="/feature-images/architecture.webp" referrerpolicy="no-referrer">
            </div><p>代理模式：给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。代理模式是一种对象结构型模式。在代理模式中引入了一个新的代理对象，代理对象在客户端对象和目标对象之间起到中介的作用，它去掉客户不能看到的内容和服务或者增添客户需要的额外的新服务。</p>]]></description></item><item><title>设计模式之解释器模式</title><link>http://www.victorchu.info/posts/2017/01/bc603741/</link><pubDate>Mon, 23 Jan 2017 11:36:22 +0800</pubDate><author><name>victorchutian</name></author><guid>http://www.victorchu.info/posts/2017/01/bc603741/</guid><description><![CDATA[<div class="featured-image">
                <img src="/feature-images/architecture.webp" referrerpolicy="no-referrer">
            </div><p>解释器模式用于描述如何使用面向对象语言构成一个简单的语言解释器。在某些情况下，为了更好地描述某一些特定类型的问题，我们可以创建一种新的语言，这种语言拥有自己的表达式和结构，即文法规则，这些问题的实例将对应为该语言中的句子。此时，可以使用解释器模式来设计这种新的语言。对解释器模式的学习能够加深我们对面向对象思想的理解，并且掌握编程语言中文法规则的解释过程。</p>]]></description></item><item><title>设计模式之状态模式</title><link>http://www.victorchu.info/posts/2017/01/61e067b6/</link><pubDate>Sun, 22 Jan 2017 11:36:22 +0800</pubDate><author><name>victorchutian</name></author><guid>http://www.victorchu.info/posts/2017/01/61e067b6/</guid><description><![CDATA[<div class="featured-image">
                <img src="/feature-images/architecture.webp" referrerpolicy="no-referrer">
            </div><p>状态模式用于解决系统中复杂对象的状态转换以及不同状态下行为的封装问题。当系统中某个对象存在多个状态，这些状态之间可以进行转换，而且对象在不同状态下行为不相同时可以使用状态模式。状态模式将一个对象的状态从该对象中分离出来，封装到专门的状态类中，使得对象状态可以灵活变化，对于客户端而言，无须关心对象状态的转换以及对象所处的当前状态，无论对于何种状态的对象，客户端都可以一致处理。</p>]]></description></item><item><title>设计模式之桥梁模式</title><link>http://www.victorchu.info/posts/2017/01/28327c8a/</link><pubDate>Sat, 21 Jan 2017 11:36:22 +0800</pubDate><author><name>victorchutian</name></author><guid>http://www.victorchu.info/posts/2017/01/28327c8a/</guid><description><![CDATA[<div class="featured-image">
                <img src="/feature-images/architecture.webp" referrerpolicy="no-referrer">
            </div><p>如果软件系统中某个类存在两个独立变化的维度，通过该模式可以将这两个维度分离出来，使两者可以独立扩展，让系统更加符合“单一职责原则”。与多层继承方案不同，它将两个独立变化的维度设计为两个独立的继承等级结构，并且在抽象层建立一个抽象关联，该关联关系类似一条连接两个独立继承结构的桥，故名桥梁模式。</p>]]></description></item><item><title>设计模式之享元模式</title><link>http://www.victorchu.info/posts/2017/01/ab6d78a/</link><pubDate>Fri, 20 Jan 2017 22:09:15 +0800</pubDate><author><name>victorchutian</name></author><guid>http://www.victorchu.info/posts/2017/01/ab6d78a/</guid><description><![CDATA[<div class="featured-image">
                <img src="/feature-images/architecture.webp" referrerpolicy="no-referrer">
            </div><p>享元模式以共享的方式高效地支持大量细粒度对象的重用，享元对象能做到共享的关键是区分了内部状态(Intrinsic State)和外部状态(Extrinsic State)。下面将对享元的内部状态和外部状态进行简单的介绍：</p>
<ol>
<li>内部状态是存储在享元对象内部并且不会随环境改变而改变的状态，内部状态可以共享。如字符的内容，不会随外部环境的变化而变化，无论在任何环境下字符“a”始终是“a”，都不会变成“b”。</li>
<li>外部状态是随环境改变而改变的、不可以共享的状态。享元对象的外部状态通常由客户端保存，并在享元对象被创建之后，需要使用的时候再传入到享元对象内部。一个外部状态与另一个外部状态之间是相互独立的。如字符的颜色，可以在不同的地方有不同的颜色，例如有的“a”是红色的，有的“a”是绿色的，字符的大小也是如此，有的“a”是五号字，有的“a”是四号字。</li>
</ol>
<p>通过区分内部状态和外部状态，我们可以将具有相同内部状态的对象存储在享元池中，享元池中的对象是可以实现共享的，需要的时候就将对象从享元池中取出，实现对象的复用。通过向取出的对象注入不同的外部状态，可以得到一系列相似的对象，而这些对象在内存中实际上只存储一份。</p>]]></description></item><item><title>设计模式之门面模式</title><link>http://www.victorchu.info/posts/2017/01/12864415/</link><pubDate>Thu, 19 Jan 2017 01:44:04 +0800</pubDate><author><name>victorchutian</name></author><guid>http://www.victorchu.info/posts/2017/01/12864415/</guid><description><![CDATA[<div class="featured-image">
                <img src="/feature-images/architecture.webp" referrerpolicy="no-referrer">
            </div><p>门面模式是一种使用频率非常高的结构型设计模式，它通过引入一个外观角色来简化客户端与子系统之间的交互，为复杂的子系统调用提供一个统一的入口，降低子系统与客户端的耦合度，且客户端调用非常方便。</p>]]></description></item></channel></rss>