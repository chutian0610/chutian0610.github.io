<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"www.victorchu.info","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"style":null,"show_result":"mac"},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"waline","storage":false,"lazyload":false,"nav":null,"activeClass":"waline"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"algolia":{"appID":"X9UOD4FSUP","apiKey":"fa32db1f02073025c69da8ebad0a6aa6","indexName":"hexo-next-blog","hits":{"per_page":10}}}</script><script src="/js/config.js"></script><meta name="description" content="在java代码中，类型的加载，连接与初始化过程都是在程序运行期间完成的（类class文件信息在编译期间已经确定好）。  类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载Loading、验证Verification、准备Preparation、解析Resolution、初始化Initialization、使用Using和卸载Unloading7个阶段。其中准备、验证、解析3"><meta property="og:type" content="article"><meta property="og:title" content="Java 类加载"><meta property="og:url" content="https://www.victorchu.info/posts/51a7bdd0/index.html"><meta property="og:site_name" content="代码之旅"><meta property="og:description" content="在java代码中，类型的加载，连接与初始化过程都是在程序运行期间完成的（类class文件信息在编译期间已经确定好）。  类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载Loading、验证Verification、准备Preparation、解析Resolution、初始化Initialization、使用Using和卸载Unloading7个阶段。其中准备、验证、解析3"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.victorchu.info/posts/51a7bdd0/jvm-classloader.webp"><meta property="og:image" content="https://www.victorchu.info/posts/51a7bdd0/jvm-classloaders.webp"><meta property="og:image" content="https://www.victorchu.info/posts/51a7bdd0/jvm-load-class.webp"><meta property="article:published_time" content="2017-10-27T03:24:08.000Z"><meta property="article:modified_time" content="2024-06-27T06:53:33.488Z"><meta property="article:author" content="Victor Chu"><meta property="article:tag" content="JVM"><meta property="article:tag" content="ClassLoader"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.victorchu.info/posts/51a7bdd0/jvm-classloader.webp"><link rel="canonical" href="https://www.victorchu.info/posts/51a7bdd0/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.victorchu.info/posts/51a7bdd0/","path":"/posts/51a7bdd0/","title":"Java 类加载"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Java 类加载 | 代码之旅</title><script src="/js/third-party/analytics/baidu-analytics.js"></script><script async src="https://hm.baidu.com/hm.js?277fc29fa80de77c97f4f62b69e94233"></script><link rel="dns-prefetch" href="walineui.victorchu.info"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="alternate" href="/atom.xml" title="代码之旅" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">代码之旅</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">I love Coding !</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">110</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">79</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">204</span></a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="algolia-stats"><hr></div><div class="algolia-hits"></div><div class="algolia-pagination"></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%95%E6%97%B6%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="nav-number">1.</span> <span class="nav-text">何时类加载</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E5%8A%A8%E4%BD%9C"><span class="nav-number">2.</span> <span class="nav-text">加载动作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81"><span class="nav-number">2.1.</span> <span class="nav-text">验证</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%86%E5%A4%87"><span class="nav-number">2.2.</span> <span class="nav-text">准备</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90"><span class="nav-number">2.3.</span> <span class="nav-text">解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">2.4.</span> <span class="nav-text">初始化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">3.</span> <span class="nav-text">类加载器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E5%8D%B8%E8%BD%BD"><span class="nav-number">4.</span> <span class="nav-text">类卸载</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Victor Chu" src="/images/victor-blog-head.webp"><p class="site-author-name" itemprop="name">Victor Chu</p><div class="site-description" itemprop="description">blog about programming.</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">204</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">79</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">110</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/chutian0610" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;chutian0610" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:victorchu0610@outlook.com" title="E-Mail → mailto:victorchu0610@outlook.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/victorchu" title="Zhihu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;victorchu" rel="noopener me" target="_blank"><i class="fab fa-zhihu fa-fw"></i>Zhihu</a> </span><span class="links-of-author-item"><a href="/images/Wechat.webp" title="WeChat → &#x2F;images&#x2F;Wechat.webp" rel="noopener me"><i class="fa-brands fa-weixin fa-fw"></i>WeChat</a></span></div></div></div><div class="back-to-top animated" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div><div class="sidebar-inner sidebar-blogroll"><div class="links-of-blogroll animated"><div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i> 链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://www.tpfuture.top/" title="https:&#x2F;&#x2F;www.tpfuture.top&#x2F;" rel="noopener" target="_blank">一水轩</a></li></ul></div></div><div class="sidebar-inner sidebar-post-related"><div class="animated"><div class="links-of-blogroll-title"><i class="fa fa-signs-post fa-fw"></i> 相关文章</div><ul class="popular-posts"><li class="popular-posts-item"><a class="popular-posts-link" href="/posts/921530f5/" rel="bookmark"><time class="popular-posts-time">2017-10-28</time><br>java 类加载器</a></li></ul></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.victorchu.info/posts/51a7bdd0/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/victor-blog-head.webp"><meta itemprop="name" content="Victor Chu"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="代码之旅"><meta itemprop="description" content="blog about programming."></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Java 类加载 | 代码之旅"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Java 类加载</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2017-10-27 11:24:08" itemprop="dateCreated datePublished" datetime="2017-10-27T11:24:08+08:00">2017-10-27</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-06-27 14:53:33" itemprop="dateModified" datetime="2024-06-27T14:53:33+08:00">2024-06-27</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a> </span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/JDK/" itemprop="url" rel="index"><span itemprop="name">JDK</span></a> </span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Waline：</span> <a title="waline" href="/posts/51a7bdd0/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/51a7bdd0/" itemprop="commentCount"></span> </a></span><span class="post-meta-item" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="waline-pageview-count" data-path="/posts/51a7bdd0/"></span> </span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>7.5k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>13 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>在java代码中，类型的加载，连接与初始化过程都是在程序运行期间完成的（类class文件信息在编译期间已经确定好）。</p><figure><img data-src="/posts/51a7bdd0/jvm-classloader.webp" alt></figure><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载<code>Loading</code>、验证<code>Verification</code>、准备<code>Preparation</code>、解析<code>Resolution</code>、初始化<code>Initialization</code>、使用<code>Using</code>和卸载<code>Unloading</code>7个阶段。其中准备、验证、解析3个部分统称为连接<code>Linking</code>。</p><p>加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定(也称为动态绑定或晚期绑定)。</p><blockquote><p>注意，本文的JDK版本是Java 1.8，在Java 9 引进模块化后，ClassLoader也有了一些变化。</p></blockquote><span id="more"></span><h1 id="何时类加载">何时类加载</h1><p>什么时候开始加载？Java 虚拟机规范中没有进行强制约束，这点可以交由虚拟机自行把握。</p><p>但是对于初始化阶段，虚拟机规范定义了有且只有5种情况需要对类进行初始化。这5种行为被称为主动引用。</p><ol><li>使用new、getstatic、putstatic和invokestatic这4条字节码指令时，如果类没有进行初始化，需要先初始化。对应的代码场景是:使用new实例化对象时、读取或设置类的静态字段(被final修饰，在编译期把结果放入常量池的静态字段除外)和调用类的静态方法时。</li><li>使用java.lang.reflect包下方法对类进行反射时，如果类没有进行过初始化，先初始化。</li><li>初始化一个类时，如果其父类还没有进行过初始化，先初始化其父类。</li><li>当虚拟机启动时，用户需要指定一个执行的主类，虚拟机会先初始化这个主类。</li><li>当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例的解析结果为REF_getStatic、REF_invokeStatic的方法句柄，并且这个方法句柄对应的类没有初始化，则对其初始化。</li></ol><p>除了这5种行为，其他的引用类的方式都被称为被动引用。</p><ul><li><p>通过子类引用父类的静态字段，不会导致子类初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperClass</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">SuperClass</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    System.out.println(SubClass.value);</span><br><span class="line">    <span class="comment">// 没有输出</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过数组定义来引用类，不会触发类的初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">SuperClass</span> <span class="variable">superclass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SuperClass</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">// superclass 的类型是 [LSuperClass ,有虚拟机生成的数组Class</span></span><br><span class="line">    <span class="comment">// 没有输出</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>常量会在编译期存入常量池，不会触发定义常量的类的初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstantClass</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    System.out.println(ConstantClass.hello);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>编译期已经把ConstantClass.hello 转化为test类的常量池中常量, 所以此处的字节码是直接从 Test class 的常量池中取出，<a target="_blank" rel="noopener" href="https://github.com/chutian0610/code-lab/tree/main/demos/jdk-lab/src/main/java/info/victorchu/jdk/lab/usage/type/classload/demos/TestClassLoad.java">不会加载ConstantClass</a>. 如果将 hello 定义成 <code>UUID.randomUUID().toString()</code>, 当一个常量的值并非编译期间可以确定的,那么其值就不会被放到调用类的常量池当中，这时在程序运行时,会导致主动使用这个常量所在的类,显然会导致这个类被初始化。</p><ul><li>接口也有初始化过程，接口与类的区别仅在第3种情况: 接口初始化是，并不要求其父接口全部完成初始化，可以懒加载。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test5</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(ChildInterface.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ParentInterface</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ChildInterface</span> <span class="keyword">extends</span> <span class="title class_">ParentInterface</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>JVM 日志验证:使用<code>-XX:+TraceClassLoading</code> 或者是 <code>-verbose:class</code> 命令行选项开启查看类加载信息的功能.</p><blockquote><p>java -XX:+TraceClassLoading</p></blockquote></blockquote><h1 id="加载动作">加载动作</h1><p>加载是查找具有特定名称的类或接口类型的二进制表示并从该二进制表示创建类或接口的过程。在加载阶段，虚拟机需要完成以下3件事情：</p><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流；</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口；</li></ol><p>首先要说明的是Java获取类的二进制流有多种方式：</p><ol><li>从Zip包中读取，例如 JAR，WAR，EAR等格式。</li><li>从网络中获取，例如Applet。</li><li>运行时动态生成，例如Java的动态代理。</li><li>其他文件生成，例如JSP生成对应的Class类。</li></ol><p>… …</p><p>值得一提的是，对于非数组类，加载阶段是通过类加载器来实现的(可以是系统提供的引导类加载器，也可以是自定义的类加载器);而数组类并不通过类加载器加载，它是由JVM直接创建的。当然，数组类的元素类型(数组去掉所有维度的类型)还是要靠类加载器加载。</p><p>数组类的创建遵循以下原则:</p><ol><li>如果数组的组件类型(数组去掉一个维度的类型)是引用类型，那么就采用类加载器去加载这个组件类型，数组将会在加载组件类型的类加载器的类名空间上被标识。</li><li>如果数组的组件类型不是引用类型，如int[],那么Java虚拟机会把数组标记为与引导类加载器关联。</li><li>数组类的可见性与它的组件类型可见性一致，如果组件类型不是引用类型，那么数组类的可见性默认为Public。</li></ol><p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区的数据存储格式由虚拟机自行定义实现，虚拟机规范未规定具体数据结构。然后在内存中实例化一个java.lang.Class类的对象(未规定存储在java堆中，hotspot虚拟机将Class对象存储在方法区。)</p><blockquote><p>加载阶段和连接阶段的部分内容是交叉进行的，加载尚未完成时，连接阶段可能已经开始了。</p></blockquote><h2 id="验证">验证</h2><p>验证是连接的第一步。这一阶段的目的是保证 class 文件符合虚拟机规范。<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.10">java 虚拟机规范</a>对 class 文件验证给出了一些建议:</p><p>Java虚拟机实现可以使用两种策略进行验证：</p><ul><li>必须使用类型检查进行验证来验证class版本号大于或等于50.0的文件(JDK 1.6及之后)。</li><li>所有Java虚拟机实现都必须支持通过类型推断进行验证，以验证class版本号小于50.0的文件，但那些符合Java ME CLDC和Java Card配置文件的实现除外。</li></ul><blockquote><p>1.6 之后的jvm 进行了优化，在 方法体的code属性的属性表中增加了名为 StackMapTable 的属性，这项属性描述了方法体中所有基本块(按控制流拆分的代码块)开始时，本地变量表和操作栈应有的状态。在字节码验证阶段，就不需要根据程序推导这些状态的合法性，只需要检查StackMapTable中记录是否合法。</p></blockquote><p>具体的验证实现，此处就不赘述了，可以通过上面的链接查看。</p><h2 id="准备">准备</h2><p>准备工作包括为类或接口创建静态字段，并将这些字段初始化为其类型默认值。在通常情况下，静态字段在准备阶段是默认值，但是，如果字段的属性表中有 ConstantValue 属性，那么在准备阶段变量就还会被初始化成ConstantValue 属性所指定的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">123</span>;         <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">123</span>;  <span class="comment">// 123</span></span><br><span class="line"><span class="comment">// final 修饰的值在class 中有 ConstantValue</span></span><br></pre></td></tr></table></figure><p>初始默认值如下:</p><table><thead><tr><th style="text-align:left">type</th><th style="text-align:left">value</th></tr></thead><tbody><tr><td style="text-align:left">int</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">long</td><td style="text-align:left">0L</td></tr><tr><td style="text-align:left">short</td><td style="text-align:left">(short)0</td></tr><tr><td style="text-align:left">char</td><td style="text-align:left">‘\u0000’</td></tr><tr><td style="text-align:left">boolean</td><td style="text-align:left">false</td></tr><tr><td style="text-align:left">float</td><td style="text-align:left">0.0f</td></tr><tr><td style="text-align:left">double</td><td style="text-align:left">0.0d</td></tr><tr><td style="text-align:left">reference</td><td style="text-align:left">null</td></tr></tbody></table><h2 id="解析">解析</h2><p>在前面的 JVM 内存介绍中有提到过运行时常量池，Java虚拟机为每个类型维护一个常量池，这是一种运行时数据结构，它的很多功能类似于符号表。</p><p>class 文件中的constant_pool 表用于在类或接口创建时构造<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.1">运行时常量池</a>，运行时常量池中的所有引用最初都是符号的。运行时常量池中的符号引用是从class中派生的。</p><p>解析阶段是虚拟机将常量池中的符号引用换成直接引用的过程。</p><ul><li>符号引用: 符号引用使用一组符号来描述所引用目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。符号引用和虚拟机内存无关，其字面量明确定义在class 文件中。</li><li>直接引用: 直接引用可以是直接指向目标的指针，相对偏移量或是一个能间接定位目标的句柄。直接引用和虚拟机的内存布局相关，同一符号引用在不同虚拟机实例上的直接引用一般不会相同，有直接引用,说明对象已在内存中。</li></ul><p>虚拟机规范未规定解析的发生时间，只要求在执行 anewarray, checkcast, getfield, getstatic, instanceof, invokedynamic, invokeinterface, invokespecial, invokestatic, invokevirtual, ldc, ldc_w, multianewarray, new, putfield, 和putstatic这些用于操作符号引用的指令之前，先对符号引用进行解析。</p><p>对同一个符号引用进行多次解析，是很常见的事情。除了 invokedynamic 指令外，虚拟机实现可以对第一次解析的结果进行缓存，在运行时常量池记录直接引用，并把常量标识为已解析状态。这样可以避免多次重复解析。</p><p>对于 invokedynamic指令，因为该指令是用于动态语言支持的,所以，只有当程序执行到这的时候，解析动作才能进行。</p><h2 id="初始化">初始化</h2><p>类的初始化是类加载的最后一步。在准备阶段，静态变量已经赋过初始值。而在初始化阶段，则根据代码中的逻辑去初始化，初始化阶段是执行类构造器<code>&lt;cinit&gt;()</code>方法的过程。</p><ul><li><code>&lt;cinit&gt;()</code>方法是编译器自动收集类中所有静态变量赋值和 static 代码块合并而成。编译器收集的顺序是在源文件中出现顺序。</li><li><code>&lt;cinit&gt;()</code>方法与类的构造方法<code>&lt;init&gt;()</code>不同，不需要显式调用父类的构造器，虚拟机会保证子类的<code>&lt;cinit&gt;()</code>方法执行前，已经执行了父类的<code>&lt;cinit&gt;()</code>方法。</li><li>执行接口中的<code>&lt;cinit&gt;()</code>方法，不需要先执行父接口的<code>&lt;cinit&gt;()</code>方法，只有使用父接口的静态变量时，才会执行<code>&lt;cinit&gt;()</code>方法。</li><li>接口的实现类，在初始化时，不需要执行接口的<code>&lt;cinit&gt;()</code>方法。</li><li><code>&lt;cinit&gt;()</code>方法对于类或接口不是必须的，如果一个类中没有静态变量，编译器可以不生成<code>&lt;cinit&gt;()</code>方法。</li><li>虚拟机会保证多线程环境下，<code>&lt;cinit&gt;()</code>方法被正确地加锁，同步。如果有多个线程同时去初始化一个类，那么只有一个线程会执行<code>&lt;cinit&gt;()</code>方法，其它的线程都会被阻塞。直到类的构造器执行完毕。(单例模式的实现方案之一)</li></ul><p>代码示例见<a href="../1f719186/index.html">Java 对象启动顺序</a></p><h1 id="类加载器">类加载器</h1><p>类加载器的设计目的是，通过一个类的全限定名来获取定义此类的二进制字节流。但在 Java 程序中的作用并不仅局限于类的加载-初始化阶段。对于任意一个类，都需要由加载它的类加载器和这个类本身一同才能确定其在 JVM 中的一致性，也就是说: 比较两个类是否&quot;相等&quot;，只有在这两个类是同一个类加载器的前提下才有意义，否则即使两个类来自同一个class 文件，被同一个虚拟机加载，若加载的类加载器不同，这两个类就不同。</p><blockquote><p>这里的相等包括Class对象的equals()方法，isAssignableFrom()方法，isInstance()方法的返回结果,也包括 instanceof 关键字的返回结果。</p></blockquote><figure><img data-src="/posts/51a7bdd0/jvm-classloaders.webp" alt="java classloader"></figure><p>如上图所示，java 提供了3种类加载器:</p><ul><li>Bootstrap ClassLoader: 启动类加载器，这个加载器负责加载<code>$JAVAHOME/jre/lib</code>下的，或是被<code>-Xbootclasspath</code>参数所指定的路径下的类库加载到虚拟机内存。用户在编写自定义加载器时，如果想把加载请求指派给启动类加载器，可以直接使用 null 代替。这个类加载器是使用 C++ 语言实现的。</li><li>Extension ClassLoader: 扩展类加载器,这个加载器由 <code>sun.misc.Launcher$ExtClassLoader</code>实现，这个加载器负责加载<code>$JAVAHOME/jre/lib/ext</code>下的,或是被<code>java.ext.dirs</code>变量所指定的路径下的所有类库。</li><li>Application ClassLoader: 应用程序类加载器,这个加载器由 <code>sun.misc.Launcher$AppClassLoader</code>实现，这个类加载器是ClassLoader中的 getSystemClassLoader()方法的返回值，负则加载 ClassPath上所指定的类库，一般是程序中默认的加载器。</li></ul><p>像图中的类加载器之间的关系，也被称为双亲委派模型。双亲委派模型要求除了顶层的启动类加载器之外，其余的类加载器都要有自己的父加载器，这里的父子关系，一般不是通过继承，而是通过组合实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="comment">// The parent class loader for delegation</span></span><br><span class="line">    <span class="comment">// Note: VM hardcoded the offset of this field, thus all new fields</span></span><br><span class="line">    <span class="comment">// must be added *after* it.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ClassLoader的继承关系</span></span><br><span class="line"><span class="comment">// java.lang.ClassLoader</span></span><br><span class="line"><span class="comment">//     -&gt; java.security.SecureClassLoader</span></span><br><span class="line"><span class="comment">//         -&gt; java.net.URLClassLoader</span></span><br><span class="line"><span class="comment">//             -&gt; sun.misc.Launcher$ExtClassLoader</span></span><br><span class="line"><span class="comment">//             -&gt; sun.misc.Launcher$AppClassLoader</span></span><br></pre></td></tr></table></figure><p>一个类加载器查找class和resource时，是通过“委托模式”进行的：它首先判断这个class是不是已经加载成功，如果没有的话它并不是自己进行查找，而是先通过父加载器，然后递归下去，直到Bootstrap ClassLoader，如果Bootstrap classloader找到了，直接返回，如果没有找到，则一级一级返回，最后到达自身去查找这些对象。这种机制就叫做双亲委托。</p><figure><img data-src="/posts/51a7bdd0/jvm-load-class.webp" alt></figure><h1 id="类卸载">类卸载</h1><p>当某个类被加载、连接和初始化后，它的生命周期就开始了。当代表某个类的Class对象不再被引用，即不可触及（没有引用指向）时，Class对象就会结束生命周期，某个类在方法区内的数据也会被卸载，从而结束类的生命周期。</p><p>一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。</p><ul><li>一个类的实例总是引用代表这个类的Class对象。 在 Object类中定义了getClass()方法，这个方法返回代表对象所属类的Class对象的引用。此外，所有的Java类都有一个静态属性class，它引用代表这个类的Class对象。</li><li>类加载器内部也会持有类对象的引用<ul><li>由Java虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载。前面已经介绍过，Java虚拟机自带的类加载器包括根类加载器、扩展类加载器和系统类加载器。Java虚拟机本身会始终引用这些类加载器，而这些类加载器则会始终引用它们所加载的类的Class对象，因此这些Class对象始终是可触及的。</li><li>由用户自定义的类加载器所加载的类是可以被卸载的。运行程序时，某个类由loader加载。在类加载器的内部实现中，用一个Java集合来存放所加载类的引用。 另一方面，一个Class对象总是会引用它的类加载器， 调用Class对象的getClassLoader()方法,就能获得它的类加载器。由此可见,代表某个类的Class实例与loader之间为双向关联关系。</li></ul></li></ul><blockquote><p>要使用JVM参数 -XX:+TraceClassUnloading 来打印类的卸载消息</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">     <span class="type">UserClassLoader</span> <span class="variable">userClassLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserClassLoader</span>();</span><br><span class="line">     userClassLoader.setPath(<span class="string">&quot;~/test/&quot;</span>);</span><br><span class="line">     Class&lt;?&gt; clazz = userClassLoader.loadClass(<span class="string">&quot;XXX&quot;</span>);<span class="comment">//不能是当前类</span></span><br><span class="line">     <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">     <span class="comment">//让类和自定义类加载器不再互相引用</span></span><br><span class="line">     userClassLoader = <span class="literal">null</span>;</span><br><span class="line">     clazz = <span class="literal">null</span>;</span><br><span class="line">     object = <span class="literal">null</span>;</span><br><span class="line">     System.gc();<span class="comment">//实际场景不这么用</span></span><br><span class="line">     <span class="comment">// 此时可以看到 unload class 的日志。</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="reward-container"><div>请我一杯咖啡吧！</div><button>赞赏</button><div class="post-reward"><div><img src="/images/weixinpay.webp" alt="Victor Chu 微信"> <span>微信</span></div><div><img src="/images/alpay.webp" alt="Victor Chu 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"><strong>本文作者： </strong>Victor Chu</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://www.victorchu.info/posts/51a7bdd0/" title="Java 类加载">https://www.victorchu.info/posts/51a7bdd0/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="followme"><span>欢迎关注我的其它发布渠道</span><div class="social-list"><div class="social-item"><a target="_blank" class="social-link" href="/atom.xml"><span class="icon"><i class="fa fa-rss"></i> </span><span class="label">RSS</span></a></div><div class="social-item"><a target="_blank" class="social-link" href="/images/wechat_channel.webp"><span class="icon"><i class="fab fa-weixin"></i> </span><span class="label">WeChat</span></a></div></div></div><div class="post-tags"><a href="/tags/JVM/" rel="tag"><i class="fa fa-tag"></i> JVM</a> <a href="/tags/ClassLoader/" rel="tag"><i class="fa fa-tag"></i> ClassLoader</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/1f893078/" rel="prev" title="IEEE 754 标准"><i class="fa fa-angle-left"></i> IEEE 754 标准</a></div><div class="post-nav-item"><a href="/posts/921530f5/" rel="next" title="java 类加载器">java 类加载器 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">浙ICP备18037908号-1 </a><img src="/images/gongan_icon.webp" alt=""><a href="https://beian.mps.gov.cn/#/query/webSearch?code=33010902002043" rel="noopener" target="_blank">浙公网安备 33010902002043号</a></div><div class="copyright">&copy; 2016 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Victor Chu</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span title="站点总字数">1.7m</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">47:54</span></span></div><div class="powered-by">由<a href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" class="theme-link" rel="noopener" target="_blank"><img src="/images/upyun_logo.webp" width="50" style="display:inline"></a>提供CDN服务</div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/algoliasearch/4.23.3/algoliasearch-lite.umd.js" integrity="sha256-1QNshz86RqXe/qsCBldsUu13eAX6n/O98uubKQs87UI=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/instantsearch.js/4.67.0/instantsearch.production.min.js" integrity="sha256-TW7D3X/i/W+RUgEeDppEnFT2ixv5lzplKH0c58D92dY=" crossorigin="anonymous"></script><script src="/js/third-party/search/algolia-search.js"></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":"default","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.9.0/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script><script src="/js/third-party/tags/mermaid.js"></script><script src="/js/third-party/fancybox.js"></script><script class="next-config" data-name="enableMath" type="application/json">false</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css" integrity="sha256-UF1fgpAiu3tPJN/uCqEUHNe7pnr+QR0SQDNfgglgtcM=" crossorigin="anonymous"><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"walineui.victorchu.info","cssUrl":"https://cdn.staticfile.org/waline/2.15.8/waline.css","commentCount":true,"pageview":true,"requiredMeta":["nick","mail"],"login":"force","libUrl":"https://cdn.staticfile.org/waline/2.15.8/waline.js","el":"#waline","comment":true,"path":"/posts/51a7bdd0/"}</script><link rel="stylesheet" href="https://cdn.staticfile.org/waline/2.15.8/waline.css"><script>document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});</script></body></html>