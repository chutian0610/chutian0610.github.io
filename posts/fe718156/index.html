<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"www.victorchu.info","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"style":null,"show_result":"mac"},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"waline","storage":false,"lazyload":false,"nav":null,"activeClass":"waline"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"algolia":{"appID":"X9UOD4FSUP","apiKey":"fa32db1f02073025c69da8ebad0a6aa6","indexName":"hexo-next-blog","hits":{"per_page":10}}}</script><script src="/js/config.js"></script><meta name="description" content="上篇我们介绍了查询是如何调度的。本篇将介绍Task的执行。"><meta property="og:type" content="article"><meta property="og:title" content="Trino源码学习-TASK执行"><meta property="og:url" content="https://www.victorchu.info/posts/fe718156/index.html"><meta property="og:site_name" content="代码之旅"><meta property="og:description" content="上篇我们介绍了查询是如何调度的。本篇将介绍Task的执行。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.victorchu.info/posts/fe718156/trino_exec.webp"><meta property="article:published_time" content="2023-03-15T02:35:46.000Z"><meta property="article:modified_time" content="2024-06-27T06:53:33.465Z"><meta property="article:author" content="Victor Chu"><meta property="article:tag" content="Presto"><meta property="article:tag" content="Trino"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.victorchu.info/posts/fe718156/trino_exec.webp"><link rel="canonical" href="https://www.victorchu.info/posts/fe718156/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.victorchu.info/posts/fe718156/","path":"/posts/fe718156/","title":"Trino源码学习-TASK执行"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Trino源码学习-TASK执行 | 代码之旅</title><script src="/js/third-party/analytics/baidu-analytics.js"></script><script async src="https://hm.baidu.com/hm.js?277fc29fa80de77c97f4f62b69e94233"></script><link rel="dns-prefetch" href="walineui.victorchu.info"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="alternate" href="/atom.xml" title="代码之旅" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">代码之旅</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">I love Coding !</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">108</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">80</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">197</span></a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="algolia-stats"><hr></div><div class="algolia-hits"></div><div class="algolia-pagination"></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%9B%E5%BB%BATask"><span class="nav-number">1.</span> <span class="nav-text">创建Task</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#TaskManager"><span class="nav-number">1.1.</span> <span class="nav-text">TaskManager</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SqlTaskExecution%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.2.</span> <span class="nav-text">SqlTaskExecution初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Task%E6%9B%B4%E6%96%B0"><span class="nav-number">1.3.</span> <span class="nav-text">Task更新</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E8%BF%90%E8%A1%8C%E9%80%BB%E8%BE%91%E8%AE%A1%E5%88%92"><span class="nav-number">2.</span> <span class="nav-text">本地运行逻辑计划</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#LocalExecution"><span class="nav-number">2.1.</span> <span class="nav-text">LocalExecution</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LocalExecutionPlanner"><span class="nav-number">2.2.</span> <span class="nav-text">LocalExecutionPlanner</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Task%E6%89%A7%E8%A1%8C"><span class="nav-number">3.</span> <span class="nav-text">Task执行</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#TaskExecutor"><span class="nav-number">3.1.</span> <span class="nav-text">TaskExecutor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MultilevelSplitQueue"><span class="nav-number">3.2.</span> <span class="nav-text">MultilevelSplitQueue</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#offer"><span class="nav-number">3.2.1.</span> <span class="nav-text">offer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#take"><span class="nav-number">3.2.2.</span> <span class="nav-text">take</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pollSplit"><span class="nav-number">3.2.3.</span> <span class="nav-text">pollSplit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#updatePriority"><span class="nav-number">3.2.4.</span> <span class="nav-text">updatePriority</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PrioritizedSplitRunner"><span class="nav-number">3.3.</span> <span class="nav-text">PrioritizedSplitRunner</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DriverSplitRunner"><span class="nav-number">3.4.</span> <span class="nav-text">DriverSplitRunner</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Driver%E6%89%A7%E8%A1%8C%E7%BB%86%E8%8A%82"><span class="nav-number">4.</span> <span class="nav-text">Driver执行细节</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#process"><span class="nav-number">4.1.</span> <span class="nav-text">process</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#processInternal"><span class="nav-number">4.2.</span> <span class="nav-text">processInternal</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#destroyIfNecessary"><span class="nav-number">4.3.</span> <span class="nav-text">destroyIfNecessary</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Pipeline"><span class="nav-number">5.</span> <span class="nav-text">Pipeline</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#LocalExchage"><span class="nav-number">5.1.</span> <span class="nav-text">LocalExchage</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Victor Chu" src="/images/victor-blog-head.webp"><p class="site-author-name" itemprop="name">Victor Chu</p><div class="site-description" itemprop="description">blog about programming.</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">197</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">80</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">108</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/chutian0610" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;chutian0610" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:victorchu0610@outlook.com" title="E-Mail → mailto:victorchu0610@outlook.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/victorchu" title="Zhihu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;victorchu" rel="noopener me" target="_blank"><i class="fab fa-zhihu fa-fw"></i>Zhihu</a> </span><span class="links-of-author-item"><a href="/images/Wechat.webp" title="WeChat → &#x2F;images&#x2F;Wechat.webp" rel="noopener me"><i class="fa-brands fa-weixin fa-fw"></i>WeChat</a></span></div></div></div><div class="back-to-top animated" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div><div class="sidebar-inner sidebar-blogroll"><div class="links-of-blogroll animated"><div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i> 链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://www.tpfuture.top/" title="https:&#x2F;&#x2F;www.tpfuture.top&#x2F;" rel="noopener" target="_blank">一水轩</a></li></ul></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.victorchu.info/posts/fe718156/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/victor-blog-head.webp"><meta itemprop="name" content="Victor Chu"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="代码之旅"><meta itemprop="description" content="blog about programming."></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Trino源码学习-TASK执行 | 代码之旅"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Trino源码学习-TASK执行</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-03-15 10:35:46" itemprop="dateCreated datePublished" datetime="2023-03-15T10:35:46+08:00">2023-03-15</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-06-27 14:53:33" itemprop="dateModified" datetime="2024-06-27T14:53:33+08:00">2024-06-27</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Trino/" itemprop="url" rel="index"><span itemprop="name">Trino</span></a> </span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Waline：</span> <a title="waline" href="/posts/fe718156/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/fe718156/" itemprop="commentCount"></span> </a></span><span class="post-meta-item" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="waline-pageview-count" data-path="/posts/fe718156/"></span> </span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>50k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>1:23</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p><a href="/posts/53a7bc3d/">上篇</a>我们介绍了查询是如何调度的。本篇将介绍Task的执行。</p><span id="more"></span><h1 id="创建Task">创建Task</h1><p>分析上篇查询调度代码时，可以发现，查询调度最终通过StageExection#scheduleTask方法生成 RemoteTask。我们先来分析下Task是如何被创建的。</p><pre class="mermaid">sequenceDiagram
  PipelinedStageExecution-&gt;&gt;PipelinedStageExecution: scheduleTask
  PipelinedStageExecution-&gt;&gt;+SqlStage: createTask
  SqlStage-&gt;&gt;+MemoryTrackingRemoteTaskFactory:createRemoteTask
  MemoryTrackingRemoteTaskFactory-&gt;&gt;+HttpRemoteTaskFactory:createRemoteTask
  HttpRemoteTaskFactory-&gt;&gt;+HttpRemoteTask: new HttpRemoteTask
  HttpRemoteTask-&gt;&gt;HttpRemoteTask: start
  HttpRemoteTask-&gt;&gt;HttpRemoteTask: triggerUpdate
  HttpRemoteTask-&gt;&gt;HttpRemoteTask: scheduleUpdate
  HttpRemoteTask--&gt;&gt;HttpRemoteTask: sendUpdate,异步线程池执行
  HttpRemoteTask--&gt;&gt;httpClient: executeAsync,向worker发起异步请求
  HttpRemoteTask-&gt;&gt;-HttpRemoteTaskFactory: return Task
  HttpRemoteTaskFactory-&gt;&gt;-MemoryTrackingRemoteTaskFactory: return Task
  MemoryTrackingRemoteTaskFactory-&gt;&gt;-SqlStage: return Task
  SqlStage-&gt;&gt;-PipelinedStageExecution: return Task</pre><p>先来看入口PipelinedStageExecution#scheduleTask方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//io.trino.execution.scheduler.PipelinedStageExecution</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Optional&lt;RemoteTask&gt; <span class="title function_">scheduleTask</span><span class="params">(</span></span><br><span class="line"><span class="params">            InternalNode node,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> partition,</span></span><br><span class="line"><span class="params">            Multimap&lt;PlanNodeId, Split&gt; initialSplits)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (stateMachine.getState().isDone()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    checkArgument(!tasks.containsKey(partition), <span class="string">&quot;A task for partition %s already exists&quot;</span>, partition);</span><br><span class="line"></span><br><span class="line">    <span class="type">OutputBuffers</span> <span class="variable">outputBuffers</span> <span class="operator">=</span> outputBufferManagers.get(stage.getFragment().getId()).getOutputBuffers();</span><br><span class="line">    <span class="comment">// 此处创建了Task，TaskID结构:stageId + &quot;.&quot; + partitionId + &quot;.&quot; + attemptId</span></span><br><span class="line">    Optional&lt;RemoteTask&gt; optionalTask = stage.createTask(</span><br><span class="line">            node,</span><br><span class="line">            partition,</span><br><span class="line">            attempt,</span><br><span class="line">            bucketToPartition,</span><br><span class="line">            outputBuffers,</span><br><span class="line">            initialSplits,</span><br><span class="line">            ImmutableSet.of(),</span><br><span class="line">            Optional.empty());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (optionalTask.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">RemoteTask</span> <span class="variable">task</span> <span class="operator">=</span> optionalTask.get();</span><br><span class="line"></span><br><span class="line">    tasks.put(partition, task);</span><br><span class="line"></span><br><span class="line">    ImmutableMultimap.Builder&lt;PlanNodeId, Split&gt; exchangeSplits = ImmutableMultimap.builder();</span><br><span class="line">    <span class="comment">// sourceTasks中存放了上游Stage的SourceTask,即当前Stage的输入</span></span><br><span class="line">    <span class="comment">// 在DistributedStagesScheduler#create方法中</span></span><br><span class="line">    <span class="comment">// parentStageExecution会将自己提供的listener注册到Child上，以获取Child的Task作为SourceTask。</span></span><br><span class="line">    sourceTasks.forEach((fragmentId, sourceTask) -&gt; &#123;</span><br><span class="line">        <span class="type">TaskStatus</span> <span class="variable">status</span> <span class="operator">=</span> sourceTask.getTaskStatus();</span><br><span class="line">        <span class="keyword">if</span> (status.getState() != TaskState.FINISHED) &#123;</span><br><span class="line">            <span class="comment">// 在DistributedStagesScheduler#create方法中</span></span><br><span class="line">            <span class="comment">// exchangeSources 存放了当前Stage的所有remoteSourceFragmentId</span></span><br><span class="line">            <span class="type">PlanNodeId</span> <span class="variable">planNodeId</span> <span class="operator">=</span> exchangeSources.get(fragmentId).getId();</span><br><span class="line">            exchangeSplits.put(planNodeId, createExchangeSplit(sourceTask, task));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//记录创建的TASK</span></span><br><span class="line">    allTasks.add(task.getTaskId());</span><br><span class="line">    <span class="comment">// task尝试添加Source Split</span></span><br><span class="line">    task.addSplits(exchangeSplits.build());</span><br><span class="line">    <span class="comment">// 通知task完成的Source</span></span><br><span class="line">    completeSources.forEach(task::noMoreSplits);</span><br><span class="line">    <span class="comment">// 添加状态变更listener</span></span><br><span class="line">    task.addStateChangeListener(<span class="built_in">this</span>::updateTaskStatus);</span><br><span class="line">    <span class="comment">// 启动task(此处会在worker上发起创建Task请求)</span></span><br><span class="line">    task.start();</span><br><span class="line">    <span class="comment">// 通知listener(parent stage) task创建信息</span></span><br><span class="line">    taskLifecycleListener.taskCreated(stage.getFragment().getId(), task);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update output buffers</span></span><br><span class="line">    <span class="type">OutputBufferId</span> <span class="variable">outputBufferId</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputBufferId</span>(task.getTaskId().getPartitionId());</span><br><span class="line">    updateSourceTasksOutputBuffers(outputBufferManager -&gt; outputBufferManager.addOutputBuffer(outputBufferId));</span><br><span class="line">    <span class="keyword">return</span> Optional.of(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后分析下HttpRemoteTask。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//io.trino.server.remotetask.HttpRemoteTask</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HttpRemoteTask</span><span class="params">(... ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// require param</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">SetThreadName</span> <span class="variable">ignored</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SetThreadName</span>(<span class="string">&quot;HttpRemoteTask-%s&quot;</span>, taskId)) &#123;</span><br><span class="line">        ... ...</span><br><span class="line">        <span class="comment">// 将所有的initialSplits构建为ScheduledSplit，放入pendingSplits。</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;PlanNodeId, Split&gt; entry : initialSplits.entries()) &#123;</span><br><span class="line">            <span class="type">ScheduledSplit</span> <span class="variable">scheduledSplit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScheduledSplit</span>(nextSplitId.getAndIncrement(), entry.getKey(), entry.getValue());</span><br><span class="line">            pendingSplits.put(entry.getKey(), scheduledSplit);</span><br><span class="line">        &#125;</span><br><span class="line">        ... ...</span><br><span class="line">        <span class="type">int</span> <span class="variable">pendingSourceSplitCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">pendingSourceSplitsWeight</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// getPartitionedSources中存放着planFragment的TableScanNode Id</span></span><br><span class="line">        <span class="keyword">for</span> (PlanNodeId planNodeId : planFragment.getPartitionedSources()) &#123;</span><br><span class="line">            Collection&lt;Split&gt; tableScanSplits = initialSplits.get(planNodeId);</span><br><span class="line">            <span class="keyword">if</span> (!tableScanSplits.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// 记录Split处理的数量</span></span><br><span class="line">                pendingSourceSplitCount += tableScanSplits.size();</span><br><span class="line">                pendingSourceSplitsWeight = addExact(pendingSourceSplitsWeight, SplitWeight.rawValueSum(tableScanSplits, Split::getSplitWeight));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.pendingSourceSplitCount = pendingSourceSplitCount;</span><br><span class="line">        <span class="built_in">this</span>.pendingSourceSplitsWeight = pendingSourceSplitsWeight;</span><br><span class="line"></span><br><span class="line">        ... ...</span><br><span class="line">        <span class="comment">// 创建TaskInfo保存Task的内部信息</span></span><br><span class="line">        <span class="type">TaskInfo</span> <span class="variable">initialTask</span> <span class="operator">=</span> createInitialTask(taskId, location, nodeId, pipelinedBufferStates, <span class="keyword">new</span> <span class="title class_">TaskStats</span>(DateTime.now(), <span class="literal">null</span>));</span><br><span class="line">        <span class="comment">// 持续获取task状态</span></span><br><span class="line">        <span class="built_in">this</span>.taskStatusFetcher = <span class="keyword">new</span> <span class="title class_">ContinuousTaskStatusFetcher</span>();</span><br><span class="line">        <span class="comment">// 持续获取task信息</span></span><br><span class="line">        <span class="built_in">this</span>.taskInfoFetcher = <span class="keyword">new</span> <span class="title class_">TaskInfoFetcher</span>();</span><br><span class="line">        ... ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">SetThreadName</span> <span class="variable">ignored</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SetThreadName</span>(<span class="string">&quot;HttpRemoteTask-%s&quot;</span>, taskId)) &#123;</span><br><span class="line">        <span class="comment">// to start we just need to trigger an update</span></span><br><span class="line">        started.set(<span class="literal">true</span>);</span><br><span class="line">        triggerUpdate(); <span class="comment">// 触发创建或更新</span></span><br><span class="line"></span><br><span class="line">        dynamicFiltersFetcher.start();</span><br><span class="line">        taskStatusFetcher.start();</span><br><span class="line">        taskInfoFetcher.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">triggerUpdate</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!started.get()) &#123;</span><br><span class="line">        <span class="comment">// task has not started yet</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pendingRequestsCounter.getAndIncrement() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// schedule update if this is the first update requested</span></span><br><span class="line">        scheduleUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">scheduleUpdate</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    executor.execute(<span class="built_in">this</span>::sendUpdate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendUpdate</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="type">HttpUriBuilder</span> <span class="variable">uriBuilder</span> <span class="operator">=</span> getHttpUriBuilder(taskStatus);</span><br><span class="line">    <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> preparePost()</span><br><span class="line">            .setUri(uriBuilder.build())</span><br><span class="line">            .setHeader(HttpHeaders.CONTENT_TYPE, MediaType.JSON_UTF_8.toString())</span><br><span class="line">            .setBodyGenerator(createStaticBodyGenerator(taskUpdateRequestJson))</span><br><span class="line">            .build();</span><br><span class="line">    ListenableFuture&lt;JsonResponse&lt;TaskInfo&gt;&gt; future = httpClient.executeAsync(request, </span><br><span class="line">    Futures.addCallback(</span><br><span class="line">            future,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SimpleHttpResponseHandler</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">UpdateResponseHandler</span>(splitAssignments, dynamicFilterDomains.getVersion(), System.nanoTime(), currentPendingRequestsCounter), request.getUri(), stats),</span><br><span class="line">            executor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HttpRemoteTask中HttpClient发出的请求会到达TaskResource的createOrUpdateTask方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//io.trino.server.TaskResource</span></span><br><span class="line"><span class="meta">@Path(&quot;/v1/task&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskResource</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="meta">@ResourceSecurity(INTERNAL_ONLY)</span></span><br><span class="line">  <span class="meta">@POST</span></span><br><span class="line">  <span class="meta">@Path(&quot;&#123;taskId&#125;&quot;)</span></span><br><span class="line">  <span class="meta">@Consumes(MediaType.APPLICATION_JSON)</span></span><br><span class="line">  <span class="meta">@Produces(MediaType.APPLICATION_JSON)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrUpdateTask</span><span class="params">(</span></span><br><span class="line"><span class="params">          <span class="meta">@PathParam(&quot;taskId&quot;)</span> TaskId taskId,</span></span><br><span class="line"><span class="params">          TaskUpdateRequest taskUpdateRequest,</span></span><br><span class="line"><span class="params">          <span class="meta">@Context</span> UriInfo uriInfo,</span></span><br><span class="line"><span class="params">          <span class="meta">@Suspended</span> AsyncResponse asyncResponse)</span></span><br><span class="line">  &#123;</span><br><span class="line">      requireNonNull(taskUpdateRequest, <span class="string">&quot;taskUpdateRequest is null&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> taskUpdateRequest.getSession().toSession(sessionPropertyManager, taskUpdateRequest.getExtraCredentials(), taskUpdateRequest.getExchangeEncryptionKey());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (injectFailure(session.getTraceToken(), taskId, RequestType.CREATE_OR_UPDATE_TASK, asyncResponse)) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 使用Taskmanager创建/更新Task，并返回task信息</span></span><br><span class="line">      <span class="type">TaskInfo</span> <span class="variable">taskInfo</span> <span class="operator">=</span> taskManager.updateTask(session,</span><br><span class="line">              taskId,</span><br><span class="line">              taskUpdateRequest.getFragment(),</span><br><span class="line">              taskUpdateRequest.getSplitAssignments(),</span><br><span class="line">              taskUpdateRequest.getOutputIds(),</span><br><span class="line">              taskUpdateRequest.getDynamicFilterDomains());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (shouldSummarize(uriInfo)) &#123;</span><br><span class="line">          taskInfo = taskInfo.summarize();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      asyncResponse.resume(Response.ok().entity(taskInfo).build());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TaskManager">TaskManager</h2><p>在Worker上Task的创建是通过taskManager来实现的。</p><pre class="mermaid">sequenceDiagram
  TaskResource-&gt;&gt;+SqlTaskManager:updateTask
  SqlTaskManager-&gt;&gt;SqlTaskManager:doUpdateTask
  SqlTaskmanager-&gt;&gt;+NonEvictableLoadingCache: get
  NonEvictableLoadingCache-&gt;&gt;+SqlTask:createSqlTask
  SqlTask-&gt;&gt;-NonEvictableLoadingCache: return SqlTask
  NonEvictableLoadingCache-&gt;&gt;-SqlTaskmanager: return SqlTask
  SqlTaskmanager-&gt;&gt;+SqlTask:updateTask
  SqlTask-&gt;&gt;+SqlTaskExecutionFactory: create
  SqlTaskExecutionFactory-&gt;&gt;+LocalExecutionPlanner: plan
  LocalExecutionPlanner-&gt;&gt;-SqlTaskExecutionFactory: new LocalExecutionPlan
  SqlTaskExecutionFactory-&gt;&gt;+SqlTaskExecution: new SqlTaskExecutionFactory
  SqlTaskExecution-&gt;&gt;+TaskExecutor: addTask
  TaskExecutor-&gt;&gt;-SqlTaskExecution:TaskHandle
  SqlTaskExecution--&gt;SqlTaskExecutionFactory: return SqlTaskExecution
  SqlTaskExecution-&gt;&gt;-SqlTask: return SqlTaskExecution
  SqlTaskExecutionFactory-&gt;&gt;-SqlTask: return SqlTaskExecution
  SqlTask-&gt;&gt;SqlTaskExecution: start
  SqlTask-&gt;&gt;SqlTaskExecution: addSplitAssignments
  SqlTaskExecution-&gt;&gt;TaskResource:return</pre><p>由于是第一次创建，所以NonEvictableLoadingCache中没有对应的TaskID,会通过createSqlTask来加载SqlTask</p><h2 id="SqlTaskExecution初始化">SqlTaskExecution初始化</h2><p>本小节分析下SqlTaskExecution是如何初始化的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//io.trino.execution.SqlTaskExecution</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SqlTaskExecution</span><span class="params">(</span></span><br><span class="line"><span class="params">            TaskStateMachine taskStateMachine,</span></span><br><span class="line"><span class="params">            TaskContext taskContext,</span></span><br><span class="line"><span class="params">            OutputBuffer outputBuffer,</span></span><br><span class="line"><span class="params">            LocalExecutionPlan localExecutionPlan,</span></span><br><span class="line"><span class="params">            TaskExecutor taskExecutor,</span></span><br><span class="line"><span class="params">            SplitMonitor splitMonitor,</span></span><br><span class="line"><span class="params">            Executor notificationExecutor)</span></span><br><span class="line">&#123;</span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">SetThreadName</span> <span class="variable">ignored</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SetThreadName</span>(<span class="string">&quot;Task-%s&quot;</span>, taskId)) &#123;</span><br><span class="line">        <span class="comment">// 根据是否是本地Source节点，将driverFactory放到不同的管理器中</span></span><br><span class="line">        <span class="comment">// index driver factories</span></span><br><span class="line">        <span class="keyword">for</span> (DriverFactory driverFactory : localExecutionPlan.getDriverFactories()) &#123;</span><br><span class="line">            Optional&lt;PlanNodeId&gt; sourceId = driverFactory.getSourceId();</span><br><span class="line">            <span class="keyword">if</span> (sourceId.isPresent() &amp;&amp; partitionedSources.contains(sourceId.get())) &#123;</span><br><span class="line">                driverRunnerFactoriesWithSplitLifeCycle.put(sourceId.get(), <span class="keyword">new</span> <span class="title class_">DriverSplitRunnerFactory</span>(driverFactory, <span class="literal">true</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//DriverSplitRunnerFactory中会初始化PipelineContext</span></span><br><span class="line">                <span class="type">DriverSplitRunnerFactory</span> <span class="variable">runnerFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DriverSplitRunnerFactory</span>(driverFactory, <span class="literal">false</span>);</span><br><span class="line">                sourceId.ifPresent(planNodeId -&gt; driverRunnerFactoriesWithRemoteSource.put(planNodeId, runnerFactory));</span><br><span class="line">                driverRunnerFactoriesWithTaskLifeCycle.add(runnerFactory);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ... ...</span><br><span class="line">        <span class="comment">//  向TaskExecutor中添加Task</span></span><br><span class="line">        <span class="keyword">if</span> (!taskStateMachine.getState().isDone()) &#123;</span><br><span class="line">                taskHandle = createTaskHandle(taskStateMachine, taskContext, outputBuffer, localExecutionPlan, taskExecutor);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">                taskHandle = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ... ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//io.trino.execution.SqlTaskExecution.TaskHandle</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> TaskHandle <span class="title function_">createTaskHandle</span><span class="params">(</span></span><br><span class="line"><span class="params">            TaskStateMachine taskStateMachine,</span></span><br><span class="line"><span class="params">            TaskContext taskContext,</span></span><br><span class="line"><span class="params">            OutputBuffer outputBuffer,</span></span><br><span class="line"><span class="params">            LocalExecutionPlan localExecutionPlan,</span></span><br><span class="line"><span class="params">            TaskExecutor taskExecutor)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">TaskHandle</span> <span class="variable">taskHandle</span> <span class="operator">=</span> taskExecutor.addTask(</span><br><span class="line">            taskStateMachine.getTaskId(),</span><br><span class="line">            outputBuffer::getUtilization,</span><br><span class="line">            getInitialSplitsPerNode(taskContext.getSession()),</span><br><span class="line">            getSplitConcurrencyAdjustmentInterval(taskContext.getSession()),</span><br><span class="line">            getMaxDriversPerTask(taskContext.getSession()));</span><br><span class="line">    taskStateMachine.addStateChangeListener(state -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (state.isDone()) &#123;</span><br><span class="line">            taskExecutor.removeTask(taskHandle);</span><br><span class="line">            <span class="keyword">for</span> (DriverFactory factory : localExecutionPlan.getDriverFactories()) &#123;</span><br><span class="line">                factory.noMoreDrivers();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> taskHandle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Task更新">Task更新</h2><p>刚才分析代码时可以看到HttpRemoteTask是会出现更新(triggerUpdate)的情况，那么什么时候会触发Task更新？</p><p>我们先来看看什么时候会调用triggerUpdate。</p><ul><li>HttpRemoteTask#start: 读源码可知PipelinedStageExecution#scheduleTask每次的partition是不同的，start方法只会执行一次。</li><li>HttpRemoteTask#addSplits: SourcePartitionedScheduler#assignSplits时会被多次调用，直到所有split批均被处理完成。</li><li>HttpRemoteTask#noMoreSplits: source类型节点(tableScan,remoteNode)调度完成时，会通知一次。</li><li>HttpRemoteTask#setOutputBuffers: RemoteTask未Start前，多次触发没有用。</li></ul><p>根据上面的分析，可以知道只有Source类型的Task会被addSplits不断触发更新。每次更新时，都会将最新的SplitAssignment提交到Worker。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//triggerUpdate -&gt; sendUpdate</span></span><br><span class="line"><span class="comment">// io.trino.server.remotetask.HttpRemoteTask#sendUpdate</span></span><br><span class="line">List&lt;SplitAssignment&gt; splitAssignments = getSplitAssignments();</span><br><span class="line"><span class="type">VersionedDynamicFilterDomains</span> <span class="variable">dynamicFilterDomains</span> <span class="operator">=</span> outboundDynamicFiltersCollector.acknowledgeAndGetNewDomains(sentDynamicFiltersVersion.get());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Workers don&#x27;t need the embedded JSON representation when the fragment is sent</span></span><br><span class="line">Optional&lt;PlanFragment&gt; fragment = sendPlan.get() ? Optional.of(planFragment.withoutEmbeddedJsonRepresentation()) : Optional.empty();</span><br><span class="line"><span class="type">TaskUpdateRequest</span> <span class="variable">updateRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskUpdateRequest</span>(</span><br><span class="line">        session.toSessionRepresentation(),</span><br><span class="line">        session.getIdentity().getExtraCredentials(),</span><br><span class="line">        fragment,</span><br><span class="line">        splitAssignments,</span><br><span class="line">        outputBuffers.get(),</span><br><span class="line">        dynamicFilterDomains.getDynamicFilterDomains(),</span><br><span class="line">        session.getExchangeEncryptionKey());</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> List&lt;SplitAssignment&gt; <span class="title function_">getSplitAssignments</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Stream.concat(planFragment.getPartitionedSourceNodes().stream(), planFragment.getRemoteSourceNodes().stream())</span><br><span class="line">            .filter(Objects::nonNull)</span><br><span class="line">            .map(PlanNode::getId)</span><br><span class="line">            .map(<span class="built_in">this</span>::getSplitAssignment)</span><br><span class="line">            .filter(Objects::nonNull)</span><br><span class="line">            .collect(toImmutableList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> SplitAssignment <span class="title function_">getSplitAssignment</span><span class="params">(PlanNodeId planNodeId)</span></span><br><span class="line">&#123;   <span class="comment">// addSplits会将Split记录到pendingSplits中</span></span><br><span class="line">    Set&lt;ScheduledSplit&gt; splits = pendingSplits.get(planNodeId);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">pendingNoMoreSplits</span> <span class="operator">=</span> Boolean.TRUE.equals(<span class="built_in">this</span>.noMoreSplits.get(planNodeId));</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">noMoreSplits</span> <span class="operator">=</span> <span class="built_in">this</span>.noMoreSplits.containsKey(planNodeId);</span><br><span class="line"></span><br><span class="line">    <span class="type">SplitAssignment</span> <span class="variable">assignment</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (!splits.isEmpty() || pendingNoMoreSplits) &#123;</span><br><span class="line">        assignment = <span class="keyword">new</span> <span class="title class_">SplitAssignment</span>(planNodeId, splits, noMoreSplits);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> assignment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="本地运行逻辑计划">本地运行逻辑计划</h1><p>根据上面的代码分析，Worker中Task的运行由SqlTaskExecution表示。SqlTaskExecution从LocalExecutionPlan(本地执行逻辑计划)生成。LocalExecution由LocalExecutionPlanner#plan方法生成。</p><h2 id="LocalExecution">LocalExecution</h2><p>LocalExecution结构如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LocalExecutionPlan</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;DriverFactory&gt; driverFactories;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;PlanNodeId&gt; partitionedSourceOrder; <span class="comment">// stage中TableScan节点ID</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LocalExecutionPlan</span><span class="params">(List&lt;DriverFactory&gt; driverFactories, List&lt;PlanNodeId&gt; partitionedSourceOrder)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.driverFactories = ImmutableList.copyOf(requireNonNull(driverFactories, <span class="string">&quot;driverFactories is null&quot;</span>));</span><br><span class="line">        <span class="built_in">this</span>.partitionedSourceOrder = ImmutableList.copyOf(requireNonNull(partitionedSourceOrder, <span class="string">&quot;partitionedSourceOrder is null&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;DriverFactory&gt; <span class="title function_">getDriverFactories</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> driverFactories;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;PlanNodeId&gt; <span class="title function_">getPartitionedSourceOrder</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> partitionedSourceOrder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看看DriverFactory的结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DriverFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> pipelineId; <span class="comment">// pipeline的ID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> inputDriver; <span class="comment">// 是否输入Diver</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> outputDriver; <span class="comment">// 是否输出Driver</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;OperatorFactory&gt; operatorFactories; <span class="comment">// 算子工厂</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Optional&lt;PlanNodeId&gt; sourceId; <span class="comment">//SourceOperator对应的执行计划ID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OptionalInt driverInstances; <span class="comment">// driver的实例数</span></span><br><span class="line">  ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DriverInstances也就是执行时Pipeline的并行度。</p><ul><li>RemoteSourceNode的并行度是TASK_CONCURRENCY</li><li>MergeWriterNode，TableExecuteNode和TableWriterNode并行度是Writer的个数，优先是TASK_PARTITIONED_WRITER_COUNT否则是TASK_WRITER_COUNT</li><li>LocalExchangeNode根据自己的类型判断:<ul><li>GATHER: 并行度是1</li><li>优先使用上下文的并行度，否则是TASK_CONCURRENCY</li></ul></li></ul><p>OperatorFactory是算子工厂类。提供了创建Operator算子的能力。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OperatorFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    Operator <span class="title function_">createOperator</span><span class="params">(DriverContext driverContext)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Declare that createOperator will not be called any more and release</span></span><br><span class="line"><span class="comment">     * any resources associated with this factory.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * This method will be called only once.</span></span><br><span class="line"><span class="comment">     * Implementation doesn&#x27;t need to worry about duplicate invocations.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">noMoreOperators</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    OperatorFactory <span class="title function_">duplicate</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Operator接口有以下重要的方法:</p><ul><li>isBlocked() 当前算子是否阻塞</li><li>needsInput() 当前算子是否需要输入Page</li><li>addInput(Page page) 传递Page给当前算子</li><li>getOutput() 获取当前算子输出的Page</li><li>finish() 用于上游算子调用，告诉当前算子，不再有page输入</li><li>isFinished() 当前算子是否完成计算</li></ul><h2 id="LocalExecutionPlanner">LocalExecutionPlanner</h2><p>分析完LocalExecution的结构，我们来关注下本地执行计划是怎么生成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> LocalExecutionPlan <span class="title function_">plan</span><span class="params">(</span></span><br><span class="line"><span class="params">            TaskContext taskContext,</span></span><br><span class="line"><span class="params">            PlanNode plan,</span></span><br><span class="line"><span class="params">            TypeProvider types,</span></span><br><span class="line"><span class="params">            PartitioningScheme partitioningScheme,</span></span><br><span class="line"><span class="params">            List&lt;PlanNodeId&gt; partitionedSourceOrder,</span></span><br><span class="line"><span class="params">            OutputBuffer outputBuffer)</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;Symbol&gt; outputLayout = partitioningScheme.getOutputLayout();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (partitioningScheme.getPartitioning().getHandle().equals(FIXED_BROADCAST_DISTRIBUTION) ||</span><br><span class="line">            partitioningScheme.getPartitioning().getHandle().equals(FIXED_ARBITRARY_DISTRIBUTION) ||</span><br><span class="line">            partitioningScheme.getPartitioning().getHandle().equals(SCALED_WRITER_ROUND_ROBIN_DISTRIBUTION) ||</span><br><span class="line">            partitioningScheme.getPartitioning().getHandle().equals(SINGLE_DISTRIBUTION) ||</span><br><span class="line">            partitioningScheme.getPartitioning().getHandle().equals(COORDINATOR_DISTRIBUTION)) &#123;</span><br><span class="line">        <span class="keyword">return</span> plan(taskContext, plan, outputLayout, types, partitionedSourceOrder, <span class="keyword">new</span> <span class="title class_">TaskOutputFactory</span>(outputBuffer));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We can convert the symbols directly into channels, because the root must be a sink and therefore the layout is fixed</span></span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> plan(</span><br><span class="line">            taskContext,</span><br><span class="line">            plan,</span><br><span class="line">            outputLayout,</span><br><span class="line">            types,</span><br><span class="line">            partitionedSourceOrder,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PartitionedOutputFactory</span>(</span><br><span class="line">                    partitionFunction,</span><br><span class="line">                    partitionChannels,</span><br><span class="line">                    partitionConstants,</span><br><span class="line">                    partitioningScheme.isReplicateNullsAndAny(),</span><br><span class="line">                    nullChannel,</span><br><span class="line">                    outputBuffer,</span><br><span class="line">                    maxPagePartitioningBufferSize,</span><br><span class="line">                    positionsAppenderFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>入口是LocalExecutionPlanner#plan方法。<ul><li>如果分区方式是如下方式，会将Task的输出OperatorFactory设置为TaskOutputFactory.<ul><li>FIXED_BROADCAST_DISTRIBUTION</li><li>FIXED_ARBITRARY_DISTRIBUTION</li><li>SCALED_WRITER_ROUND_ROBIN_DISTRIBUTION</li><li>SINGLE_DISTRIBUTION和COORDINATOR_DISTRIBUTION</li></ul></li><li>否则会将Task的输出OperatorFactory设置为PartitionedOutputFactory.</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> LocalExecutionPlan <span class="title function_">plan</span><span class="params">(</span></span><br><span class="line"><span class="params">            TaskContext taskContext,</span></span><br><span class="line"><span class="params">            PlanNode plan,</span></span><br><span class="line"><span class="params">            List&lt;Symbol&gt; outputLayout,</span></span><br><span class="line"><span class="params">            TypeProvider types,</span></span><br><span class="line"><span class="params">            List&lt;PlanNodeId&gt; partitionedSourceOrder,</span></span><br><span class="line"><span class="params">            OutputFactory outputOperatorFactory)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> taskContext.getSession();</span><br><span class="line">    <span class="type">LocalExecutionPlanContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalExecutionPlanContext</span>(taskContext, types);</span><br><span class="line"></span><br><span class="line">    <span class="type">PhysicalOperation</span> <span class="variable">physicalOperation</span> <span class="operator">=</span> plan.accept(<span class="keyword">new</span> <span class="title class_">Visitor</span>(session), context);</span><br><span class="line"></span><br><span class="line">    Function&lt;Page, Page&gt; pagePreprocessor = enforceLoadedLayoutProcessor(outputLayout, physicalOperation.getLayout());</span><br><span class="line"></span><br><span class="line">    List&lt;Type&gt; outputTypes = outputLayout.stream()</span><br><span class="line">            .map(types::get)</span><br><span class="line">            .collect(toImmutableList());</span><br><span class="line"></span><br><span class="line">    context.addDriverFactory(</span><br><span class="line">            context.isInputDriver(),</span><br><span class="line">            <span class="literal">true</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PhysicalOperation</span>(</span><br><span class="line">                    outputOperatorFactory.createOutputOperator(</span><br><span class="line">                            context.getNextOperatorId(),</span><br><span class="line">                            plan.getId(),</span><br><span class="line">                            outputTypes,</span><br><span class="line">                            pagePreprocessor,</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">PagesSerdeFactory</span>(plannerContext.getBlockEncodingSerde(), isExchangeCompressionEnabled(session))),</span><br><span class="line">                    physicalOperation),</span><br><span class="line">            context.getDriverInstanceCount());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// notify operator factories that planning has completed</span></span><br><span class="line">    context.getDriverFactories().stream()</span><br><span class="line">            .map(DriverFactory::getOperatorFactories)</span><br><span class="line">            .flatMap(List::stream)</span><br><span class="line">            .filter(LocalPlannerAware.class::isInstance)</span><br><span class="line">            .map(LocalPlannerAware.class::cast)</span><br><span class="line">            .forEach(LocalPlannerAware::localPlannerComplete);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LocalExecutionPlan</span>(context.getDriverFactories(), partitionedSourceOrder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>开始执行带outputFactory的plan方法。<ul><li>构造LocalExecutionPlanContext</li><li>使用Visitor遍历Plan树，并返回PhysicalOperation。</li><li>基于outputOperatorFactory和上面的返回的PhysicalOperation，构建一个新的PhysicalOperation。</li><li>将最终的PhysicalOperation添加到Context的DriverFactories中</li><li>获取context中的DriverFactories，构建LocalExecution。</li></ul></li></ul><p>核心逻辑在Visitor遍历Plan树，并生成PhysicalOperation这块。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PhysicalOperation</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;OperatorFactoryWithTypes&gt; operatorFactoriesWithTypes;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Symbol, Integer&gt; layout; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Type&gt; types;</span><br><span class="line">    ... ... </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">PhysicalOperation</span><span class="params">(</span></span><br><span class="line"><span class="params">            OperatorFactory operatorFactory,</span></span><br><span class="line"><span class="params">            Map&lt;Symbol, Integer&gt; layout,</span></span><br><span class="line"><span class="params">            TypeProvider typeProvider,</span></span><br><span class="line"><span class="params">            Optional&lt;PhysicalOperation&gt; source)</span></span><br><span class="line">    &#123;</span><br><span class="line">        requireNonNull(operatorFactory, <span class="string">&quot;operatorFactory is null&quot;</span>);</span><br><span class="line">        requireNonNull(layout, <span class="string">&quot;layout is null&quot;</span>);</span><br><span class="line">        requireNonNull(typeProvider, <span class="string">&quot;typeProvider is null&quot;</span>);</span><br><span class="line">        requireNonNull(source, <span class="string">&quot;source is null&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.types = toTypes(layout, typeProvider);</span><br><span class="line">        <span class="built_in">this</span>.operatorFactoriesWithTypes = ImmutableList.&lt;OperatorFactoryWithTypes&gt;builder()</span><br><span class="line">                <span class="comment">// operatorFactoriesWithTypes的顺序是先上游节点，然后是自己</span></span><br><span class="line">                .addAll(source.map(PhysicalOperation::getOperatorFactoriesWithTypes).orElse(ImmutableList.of()))</span><br><span class="line">                .add(<span class="keyword">new</span> <span class="title class_">OperatorFactoryWithTypes</span>(operatorFactory, types))</span><br><span class="line">                .build();</span><br><span class="line">        <span class="built_in">this</span>.layout = ImmutableMap.copyOf(layout);</span><br><span class="line">    &#125;</span><br><span class="line">  ... ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// private static class LocalExecutionPlanContext</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addDriverFactory</span><span class="params">(<span class="type">boolean</span> inputDriver, <span class="type">boolean</span> outputDriver, PhysicalOperation physicalOperation, OptionalInt driverInstances)</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;OperatorFactoryWithTypes&gt; operatorFactoriesWithTypes = physicalOperation.getOperatorFactoriesWithTypes();</span><br><span class="line">    <span class="comment">// addLookupOuterDrivers 是对joinNode中 outer部分返回的特殊处理。</span></span><br><span class="line">    addLookupOuterDrivers(outputDriver, toOperatorFactories(operatorFactoriesWithTypes));</span><br><span class="line">    List&lt;OperatorFactory&gt; operatorFactories;</span><br><span class="line">    <span class="keyword">if</span> (isLateMaterializationEnabled(taskContext.getSession())) &#123;</span><br><span class="line">        operatorFactories = handleLateMaterialization(operatorFactoriesWithTypes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        operatorFactories = toOperatorFactories(operatorFactoriesWithTypes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意，在此次新建了一个pipeline</span></span><br><span class="line">    driverFactories.add(<span class="keyword">new</span> <span class="title class_">DriverFactory</span>(getNextPipelineId(), inputDriver, outputDriver, operatorFactories, driverInstances));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合Visitor的代码和上面的代码可以知道。</p><ul><li>上游的节点会先解析成PhysicalOperation，然后作为Source提供给下游节点，PhysicalOperation会合并Source的operatorFactoriesWithTypes。</li><li>在遍历Plan的过程中，对于joinNode，exchangeNode等多个Source的，context提供了addDriverFactory方法，将Source对应的PhysicalOperation优先加入到Context的DriverFactories中。</li><li>每次addDriverFactory，实际上会新增一个Pipeline。</li></ul><h1 id="Task执行">Task执行</h1><p>Task执行的入口是SqlTaskExecution#start。</p><pre class="mermaid">sequenceDiagram
  SqlTaskExecution-&gt;&gt;SqlTaskExecution: scheduleDriversForTaskLifeCycle
  loop every DriverRunnerFactory
    SqlTaskExecution-&gt;&gt;+DriverRunnerFactory: createDriverRunner 
    DriverRunnerFactory-&gt;&gt;-SqlTaskExecution: return DriverSplitRunner
    SqlTaskExecution-&gt;&gt;SqlTaskExecution: enqueueDriverSplitRunner
    SqlTaskExecution-&gt;&gt;+TaskExecutor: enqueueSplits
    TaskExecutor-&gt;&gt;-SqlTaskExecution: return ListenableFuture
    SqlTaskExecution-&gt;&gt;SqlTaskExecution: set Future CallBack
    SqlTaskExecution-&gt;&gt;DriverRunnerFactory: noMoreDriverRunner
    DriverRunnerFactory-&gt;&gt;SqlTaskExecution: return void
  end</pre><p>可以看到Task的执行主要依靠TaskExecutor。同时，我们可以注意到start中只调度了scheduleDriversForTaskLifeCycle中的DriverRunnerFactory。在SqlTaskExecution初始化一节中，对于本地Source，单独被放到了driverRunnerFactoriesWithRemoteSource中。这些Split是通过<code>taskExecution.addSplitAssignments(splitAssignments)</code>方法触发执行的(可以循环触发)。</p><pre class="mermaid">sequenceDiagram
  SqlTaskExecution-&gt;&gt;SqlTaskExecution: addSplitAssignments
  SqlTaskExecution-&gt;&gt;SqlTaskExecution: updateSplitAssignments
  loop every new SplitAssignment
    alt driverRunnerFactoriesWithSplit contains
      SqlTaskExecution-&gt;&gt;SqlTaskExecution:schedulePartitionedSource
    else
      SqlTaskExecution-&gt;&gt;DriverSplitRunnerFactory:enqueueSplits
      SqlTaskExecution-&gt;&gt;updatedUnpartitionedSources: added
      updatedUnpartitionedSources-&gt;&gt;SqlTaskExecution: return
    end
  end
  loop every planNodeId in updatedUnpartitionedSources
    SqlTaskExecution-&gt;&gt;+DriverSplitRunnerFactory: scheduleSplits 
  end</pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//io.trino.execution.SqlTaskExecution</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> Set&lt;PlanNodeId&gt; <span class="title function_">updateSplitAssignments</span><span class="params">(List&lt;SplitAssignment&gt; splitAssignments)</span></span><br><span class="line">&#123;</span><br><span class="line">  ImmutableSet.Builder&lt;PlanNodeId&gt; updatedUnpartitionedSources = ImmutableSet.builder();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// first remove any split that was already acknowledged</span></span><br><span class="line">  <span class="type">long</span> <span class="variable">currentMaxAcknowledgedSplit</span> <span class="operator">=</span> <span class="built_in">this</span>.maxAcknowledgedSplit;</span><br><span class="line">  splitAssignments = splitAssignments.stream()</span><br><span class="line">          .map(assignment -&gt; <span class="keyword">new</span> <span class="title class_">SplitAssignment</span>(</span><br><span class="line">                  assignment.getPlanNodeId(),</span><br><span class="line">                  assignment.getSplits().stream()</span><br><span class="line">                          .filter(scheduledSplit -&gt; scheduledSplit.getSequenceId() &gt; currentMaxAcknowledgedSplit)</span><br><span class="line">                          .collect(toImmutableSet()),</span><br><span class="line">                  assignment.isNoMoreSplits()))</span><br><span class="line">          <span class="comment">// drop assignments containing no unacknowledged splits</span></span><br><span class="line">          <span class="comment">// the noMoreSplits signal acknowledgement is not tracked but it is okay to deliver it more than once</span></span><br><span class="line">          .filter(assignment -&gt; !assignment.getSplits().isEmpty() || assignment.isNoMoreSplits())</span><br><span class="line">          .collect(toList());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// update task with new assignments</span></span><br><span class="line">  <span class="keyword">for</span> (SplitAssignment assignment : splitAssignments) &#123;</span><br><span class="line">      <span class="keyword">if</span> (driverRunnerFactoriesWithSplitLifeCycle.containsKey(assignment.getPlanNodeId())) &#123;</span><br><span class="line">          <span class="comment">// 本地Source</span></span><br><span class="line">          schedulePartitionedSource(assignment);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 远程Source，才会加到updatedUnpartitionedSources中</span></span><br><span class="line">          <span class="comment">// tell existing drivers about the new splits</span></span><br><span class="line">          <span class="type">DriverSplitRunnerFactory</span> <span class="variable">factory</span> <span class="operator">=</span> driverRunnerFactoriesWithRemoteSource.get(assignment.getPlanNodeId());</span><br><span class="line">          factory.enqueueSplits(assignment.getSplits(), assignment.isNoMoreSplits());</span><br><span class="line">          updatedUnpartitionedSources.add(assignment.getPlanNodeId());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// update maxAcknowledgedSplit</span></span><br><span class="line">  maxAcknowledgedSplit = splitAssignments.stream()</span><br><span class="line">          .flatMap(source -&gt; source.getSplits().stream())</span><br><span class="line">          .mapToLong(ScheduledSplit::getSequenceId)</span><br><span class="line">          .max()</span><br><span class="line">          .orElse(maxAcknowledgedSplit);</span><br><span class="line">  <span class="keyword">return</span> updatedUnpartitionedSources.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于本地Source，会调用schedulePartitionedSource方法。该方法中会启动处理split的Runner。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//io.trino.execution.SqlTaskExecution</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">schedulePartitionedSource</span><span class="params">(SplitAssignment splitAssignmentUpdate)</span></span><br><span class="line">&#123;</span><br><span class="line">    mergeIntoPendingSplits(splitAssignmentUpdate.getPlanNodeId(), splitAssignmentUpdate.getSplits(), splitAssignmentUpdate.isNoMoreSplits());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (schedulingPlanNodeOrdinal &lt; sourceStartOrder.size()) &#123;</span><br><span class="line">        <span class="comment">// 注意这个循环只会执行一次，后面的SplitAssign都会加入pendingSplitsForPlanNode</span></span><br><span class="line">        <span class="type">PlanNodeId</span> <span class="variable">schedulingPlanNode</span> <span class="operator">=</span> sourceStartOrder.get(schedulingPlanNodeOrdinal);</span><br><span class="line"></span><br><span class="line">        <span class="type">DriverSplitRunnerFactory</span> <span class="variable">partitionedDriverRunnerFactory</span> <span class="operator">=</span> driverRunnerFactoriesWithSplitLifeCycle.get(schedulingPlanNode);</span><br><span class="line"></span><br><span class="line">        <span class="type">PendingSplitsForPlanNode</span> <span class="variable">pendingSplits</span> <span class="operator">=</span> pendingSplitsByPlanNode.get(schedulingPlanNode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Enqueue driver runners with split lifecycle for this plan node and driver life cycle combination.</span></span><br><span class="line">        ImmutableList.Builder&lt;DriverSplitRunner&gt; runners = ImmutableList.builder();</span><br><span class="line">        <span class="keyword">for</span> (ScheduledSplit scheduledSplit : pendingSplits.removeAllSplits()) &#123;</span><br><span class="line">            <span class="comment">// create a new driver for the split</span></span><br><span class="line">            <span class="comment">// 创建用于执行的DriverRunner</span></span><br><span class="line">            runners.add(partitionedDriverRunnerFactory.createDriverRunner(scheduledSplit));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将DriverRunner放入TaskExecutor</span></span><br><span class="line">        enqueueDriverSplitRunner(<span class="literal">false</span>, runners.build());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If all driver runners have been enqueued for this plan node and driver life cycle combination,</span></span><br><span class="line">        <span class="comment">// move on to the next plan node.</span></span><br><span class="line">        <span class="keyword">if</span> (pendingSplits.getState() != NO_MORE_SPLITS) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        partitionedDriverRunnerFactory.noMoreDriverRunner();</span><br><span class="line">        pendingSplits.markAsCleanedUp();</span><br><span class="line"></span><br><span class="line">        schedulingPlanNodeOrdinal++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将Split添加到pendingSplitsForPlanNode中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mergeIntoPendingSplits</span><span class="params">(PlanNodeId planNodeId, Set&lt;ScheduledSplit&gt; scheduledSplits, <span class="type">boolean</span> noMoreSplits)</span></span><br><span class="line">&#123;</span><br><span class="line">    checkHoldsLock();</span><br><span class="line"></span><br><span class="line">    <span class="type">DriverSplitRunnerFactory</span> <span class="variable">partitionedDriverFactory</span> <span class="operator">=</span> driverRunnerFactoriesWithSplitLifeCycle.get(planNodeId);</span><br><span class="line">    <span class="type">PendingSplitsForPlanNode</span> <span class="variable">pendingSplitsForPlanNode</span> <span class="operator">=</span> pendingSplitsByPlanNode.get(planNodeId);</span><br><span class="line"></span><br><span class="line">    partitionedDriverFactory.splitsAdded(scheduledSplits.size(), SplitWeight.rawValueSum(scheduledSplits, scheduledSplit -&gt; scheduledSplit.getSplit().getSplitWeight()));</span><br><span class="line">    <span class="keyword">for</span> (ScheduledSplit scheduledSplit : scheduledSplits) &#123;</span><br><span class="line">        pendingSplitsForPlanNode.addSplit(scheduledSplit);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (noMoreSplits) &#123;</span><br><span class="line">        pendingSplitsForPlanNode.setNoMoreSplits();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于RemoteSource,会通过DriverSplitRunnerFactory#scheduleSplits执行。在方法内部会调用driver#updateSplitAssignment方法。Driver部分在下面会介绍，此处就不展开了。</p><h2 id="TaskExecutor">TaskExecutor</h2><p>DriverRunner通过TaskExecutor#enqueueSplits方法执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;ListenableFuture&lt;Void&gt;&gt; <span class="title function_">enqueueSplits</span><span class="params">(TaskHandle taskHandle, <span class="type">boolean</span> intermediate, List&lt;? extends SplitRunner&gt; taskSplits)</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;PrioritizedSplitRunner&gt; splitsToDestroy = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;ListenableFuture&lt;Void&gt;&gt; finishedFutures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(taskSplits.size());</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (SplitRunner taskSplit : taskSplits) &#123;</span><br><span class="line">            <span class="comment">// 将原有的SplitRunner包装为PrioritizedSplitRunner</span></span><br><span class="line">            <span class="type">PrioritizedSplitRunner</span> <span class="variable">prioritizedSplitRunner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrioritizedSplitRunner</span>(</span><br><span class="line">                    taskHandle,</span><br><span class="line">                    taskSplit,</span><br><span class="line">                    ticker,</span><br><span class="line">                    globalCpuTimeMicros,</span><br><span class="line">                    globalScheduledTimeMicros,</span><br><span class="line">                    blockedQuantaWallTime,</span><br><span class="line">                    unblockedQuantaWallTime);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (taskHandle.isDestroyed()) &#123;</span><br><span class="line">                <span class="comment">// If the handle is destroyed, we destroy the task splits to complete the future</span></span><br><span class="line">                splitsToDestroy.add(prioritizedSplitRunner);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (intermediate) &#123;</span><br><span class="line">                <span class="comment">// 立刻启动</span></span><br><span class="line">                <span class="comment">// Note: we do not record queued time for intermediate splits</span></span><br><span class="line">                startIntermediateSplit(prioritizedSplitRunner);</span><br><span class="line">                <span class="comment">// add the runner to the handle so it can be destroyed if the task is canceled</span></span><br><span class="line">                taskHandle.recordIntermediateSplit(prioritizedSplitRunner);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 将Split 入队</span></span><br><span class="line">                taskHandle.enqueueSplit(prioritizedSplitRunner);</span><br><span class="line">                <span class="comment">// 如果Task启动的Split低于保证(guaranteedNumberOfDriversPerTask)，尝试启动Split</span></span><br><span class="line">                scheduleTaskIfNecessary(taskHandle);</span><br><span class="line">                <span class="comment">// 如果有更多的全局资源(低于minimumNumberOfDrivers)，TaskExecutor会全局启动更多Split</span></span><br><span class="line">                addNewEntrants();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            finishedFutures.add(prioritizedSplitRunner.getFinishedFuture());</span><br><span class="line">        &#125;</span><br><span class="line">        recordLeafSplitsSize();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 销毁split</span></span><br><span class="line">    <span class="keyword">for</span> (PrioritizedSplitRunner split : splitsToDestroy) &#123;</span><br><span class="line">        split.destroy();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> finishedFutures;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><img data-src="/posts/fe718156/trino_exec.webp" alt></figure><ul><li>如果是立刻执行，会调用startIntermediateSplit，将SplitRunner加到waitingSplits中</li><li>否则排队调用enqueueSplit，将SplitRunner存储到Task的QueuedLeafSplits。<ul><li>调用Task的pollNextSplit尝试启动Task下的Split</li><li>调用TaskExecutor的pollNextSplitWorker尝试尽可能启动所有Task中的Splits。</li></ul></li><li>TaskExecutor内部的executor中有轮询线程。<ul><li>线程不停的从waitingSplits中拿出SplitRunner</li><li>调用SplitRunner的process方法</li><li>如果SplitRunner被block，那就等block解除后，继续调度</li><li>如果SplitRunner未完成，继续加入waitingSplits</li><li>如果SplitRunner已完成，触发splitFinished方法</li></ul></li></ul><h2 id="MultilevelSplitQueue">MultilevelSplitQueue</h2><p>TaskExecutor中的waitingSplits是MultilevelSplitQueue。这是一个多层级的优先级队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultilevelSplitQueue</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//每个level的阈值，比如LEVEL_THRESHOLD_SECONDS[1] = 1s，也就是说累计运行时间超过1s的任务会被放到level1。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] LEVEL_THRESHOLD_SECONDS = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">60</span>, <span class="number">300</span>&#125;;</span><br><span class="line">    <span class="comment">//一个保护性的值，一次process被计算的上限时间，避免某些任务因为特殊情况被计算了太多值。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">LEVEL_CONTRIBUTION_CAP</span> <span class="operator">=</span> SECONDS.toNanos(<span class="number">30</span>);</span><br><span class="line">    <span class="comment">// 一个size为5的优先队列的2维数组。共5个level，</span></span><br><span class="line">    <span class="comment">// 每次take时，通过比对每一level已经消耗的时间，选取一个level，</span></span><br><span class="line">    <span class="comment">// 从该level里选取优先级最高的PrioritizedSplitRunner。</span></span><br><span class="line">    <span class="meta">@GuardedBy(&quot;lock&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PriorityQueue&lt;PrioritizedSplitRunner&gt;[] levelWaitingSplits;</span><br><span class="line">    <span class="comment">//一个size为5的调度时间累加器，表示当前level的已用掉的调度时间。</span></span><br><span class="line">    <span class="comment">// PrioritizedSplitRunner在执行完任务的process之后会增加当前level的调度时间。</span></span><br><span class="line">    <span class="comment">// 这部分的数据主要用于在poll取PrioritizedSplitRunner数据的时候计算具体从哪个level的队列里面拿。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong[] levelScheduledTime;</span><br><span class="line">    <span class="comment">//是一个size为5的优先级分数数组，表明当前level的最小的优先级分数，</span></span><br><span class="line">    <span class="comment">// 每次从队里成功take出数据之后会更新这个当前level的优先级分数。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong[] levelMinPriority;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CounterStat[] selectedLevelCounters;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="comment">//这个字段用于设置不同level之间的cpu时间分配。默认用的是2，也就是level0-4时间占比为16:8:4:2:1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">double</span> levelTimeMultiplier;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="offer">offer</h3><p>将一个PrioritizedSplitRunner加入对应层级的优先队列，一个PrioritizedSplitRunner初始化的时候默认在level0。这里遇到空层级的时候，会将空层的运行时间调到预期的运行时间，Trino这样做的原因可能是：</p><p>如果不调整，如果这个空的level落后太多，那么之后真的有PrioritizedSplitRunner到达这个level时，这个level的优先级会很高（因为是按照每个层级已经分配到的时间来计算优先级的），可能会导致其它level较长时间得不到调度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">offer</span><span class="params">(PrioritizedSplitRunner split)</span></span><br><span class="line">&#123;</span><br><span class="line">    checkArgument(split != <span class="literal">null</span>, <span class="string">&quot;split is null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    split.setReady();</span><br><span class="line">    <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> split.getPriority().getLevel();</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (levelWaitingSplits[level].isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// Accesses to levelScheduledTime are not synchronized, so we have a data race</span></span><br><span class="line">            <span class="comment">// here - our level time math will be off. However, the staleness is bounded by</span></span><br><span class="line">            <span class="comment">// the fact that only running splits that complete during this computation</span></span><br><span class="line">            <span class="comment">// can update the level time. Therefore, this is benign.</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">level0Time</span> <span class="operator">=</span> getLevel0TargetTime();</span><br><span class="line">            <span class="type">long</span> <span class="variable">levelExpectedTime</span> <span class="operator">=</span> (<span class="type">long</span>) (level0Time / Math.pow(levelTimeMultiplier, level));</span><br><span class="line">            <span class="type">long</span> <span class="variable">delta</span> <span class="operator">=</span> levelExpectedTime - levelScheduledTime[level].get();</span><br><span class="line">            levelScheduledTime[level].addAndGet(delta);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        levelWaitingSplits[level].offer(split);</span><br><span class="line">        notEmpty.signal();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="take">take</h3><p>pollSplit()方法选取一个合适的PrioritizedSplitRunner.</p><p>如果result.updateLevelPriority()返回true，说明这个PrioritizedSplitRunner对应的TaskHandle的优先级和PrioritizedSplitRunner的优先级不同，</p><p>而Trino认为TaskHandle关联的所有PrioritizedSplitRunner的level应当地一致改变，所以将PrioritizedSplitRunner重新放回队列，等待下一次调度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> PrioritizedSplitRunner <span class="title function_">take</span><span class="params">()</span></span><br><span class="line">            <span class="keyword">throws</span> InterruptedException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PrioritizedSplitRunner result;</span><br><span class="line">            <span class="keyword">while</span> ((result = pollSplit()) == <span class="literal">null</span>) &#123;</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (result.updateLevelPriority()) &#123;</span><br><span class="line">                offer(result);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">selectedLevel</span> <span class="operator">=</span> result.getPriority().getLevel();</span><br><span class="line">            levelMinPriority[selectedLevel].set(result.getPriority().getLevelPriority());</span><br><span class="line">            selectedLevelCounters[selectedLevel].update(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// io.trino.execution.executor.PrioritizedSplitRunner</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">updateLevelPriority</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">Priority</span> <span class="variable">newPriority</span> <span class="operator">=</span> taskHandle.getPriority();</span><br><span class="line">    <span class="type">Priority</span> <span class="variable">oldPriority</span> <span class="operator">=</span> priority.getAndSet(newPriority);</span><br><span class="line">    <span class="keyword">return</span> newPriority.getLevel() != oldPriority.getLevel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pollSplit">pollSplit</h3><p>如何决定选哪个level的优先队列：</p><ul><li>level的数量固定是5，Trino假设不同level之间CPU的预期时间分布是确定的，具体实现中使用levelMinPriority的幂次方来决定，比如选择levelMinPriority=2，level0-4的预期CPU时间占比就为16:8:4:2:1</li><li>维护了一个levelSchedueTime的数组，标识了各个level已经调度的时间，Trino的选择思路很简单<ul><li>首先计算出level0的基准时间，注意level0的基准时间是通过getLevel0TargetTime()计算得出的，而不是一个常数</li><li>根据levelMinPriority给出的各level时间比例，我们就知道了每一个level的targetScheduledTime</li><li>Ratio = targetScheduledTime/实际的调度时间<code>levelScheduledTime[level].get()</code>，ratio结果最大的level就是我们认为最不符合预期比例的level，我们希望给它分配更多的时间，所以选择这个level。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> PrioritizedSplitRunner <span class="title function_">pollSplit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">targetScheduledTime</span> <span class="operator">=</span> getLevel0TargetTime();</span><br><span class="line">    <span class="type">double</span> <span class="variable">worstRatio</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">selectedLevel</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">0</span>; level &lt; LEVEL_THRESHOLD_SECONDS.length; level++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!levelWaitingSplits[level].isEmpty()) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">levelTime</span> <span class="operator">=</span> levelScheduledTime[level].get();</span><br><span class="line">            <span class="type">double</span> <span class="variable">ratio</span> <span class="operator">=</span> levelTime == <span class="number">0</span> ? <span class="number">0</span> : targetScheduledTime / (<span class="number">1.0</span> * levelTime);</span><br><span class="line">            <span class="keyword">if</span> (selectedLevel == -<span class="number">1</span> || ratio &gt; worstRatio) &#123;</span><br><span class="line">                worstRatio = ratio;</span><br><span class="line">                selectedLevel = level;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        targetScheduledTime /= levelTimeMultiplier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (selectedLevel == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">PrioritizedSplitRunner</span> <span class="variable">result</span> <span class="operator">=</span> levelWaitingSplits[selectedLevel].poll();</span><br><span class="line">    checkState(result != <span class="literal">null</span>, <span class="string">&quot;pollSplit cannot return null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">getLevel0TargetTime</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">level0TargetTime</span> <span class="operator">=</span> levelScheduledTime[<span class="number">0</span>].get();</span><br><span class="line">    <span class="type">double</span> <span class="variable">currentMultiplier</span> <span class="operator">=</span> levelTimeMultiplier;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">0</span>; level &lt; LEVEL_THRESHOLD_SECONDS.length; level++) &#123;</span><br><span class="line">        currentMultiplier /= levelTimeMultiplier;</span><br><span class="line">        <span class="type">long</span> <span class="variable">levelTime</span> <span class="operator">=</span> levelScheduledTime[level].get();</span><br><span class="line">        <span class="comment">// 选择的是所有level经过比例换算之后最大的那个时间。</span></span><br><span class="line">        level0TargetTime = Math.max(level0TargetTime, (<span class="type">long</span>) (levelTime / currentMultiplier));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> level0TargetTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="updatePriority">updatePriority</h3><p>PrioritizedSplitRunner#process方法在处理完一次processFor之后，会更新其本身以及TaskHandle的Priority，就会调用到这个updatePriority方法.</p><ul><li>计算TaskHanlde的累积调度时间是不是要升级到更高的level</li><li>逐级更新各level，然后返回更新后的Priority</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Priority <span class="title function_">updatePriority</span><span class="params">(Priority oldPriority, <span class="type">long</span> quantaNanos, <span class="type">long</span> scheduledNanos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldLevel</span> <span class="operator">=</span> oldPriority.getLevel();</span><br><span class="line">    <span class="comment">// 计算新的level</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newLevel</span> <span class="operator">=</span> computeLevel(scheduledNanos); </span><br><span class="line">    <span class="comment">//上限保护</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">levelContribution</span> <span class="operator">=</span> Math.min(quantaNanos, LEVEL_CONTRIBUTION_CAP);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldLevel == newLevel) &#123;</span><br><span class="line">        <span class="comment">// 增加调度耗时</span></span><br><span class="line">        addLevelTime(oldLevel, levelContribution);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Priority</span>(oldLevel, oldPriority.getLevelPriority() + quantaNanos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">remainingLevelContribution</span> <span class="operator">=</span> levelContribution;</span><br><span class="line">    <span class="type">long</span> <span class="variable">remainingTaskTime</span> <span class="operator">=</span> quantaNanos;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a task normally slowly accrues scheduled time in a level and then moves to the next, but</span></span><br><span class="line">    <span class="comment">// if the split had a particularly long quanta, accrue time to each level as if it had run</span></span><br><span class="line">    <span class="comment">// in that level up to the level limit.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">currentLevel</span> <span class="operator">=</span> oldLevel; currentLevel &lt; newLevel; currentLevel++) &#123;</span><br><span class="line">        <span class="comment">// 对不同level的时间贡献</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">timeAccruedToLevel</span> <span class="operator">=</span> Math.min(SECONDS.toNanos(LEVEL_THRESHOLD_SECONDS[currentLevel + <span class="number">1</span>] - LEVEL_THRESHOLD_SECONDS[currentLevel]), remainingLevelContribution);</span><br><span class="line">        addLevelTime(currentLevel, timeAccruedToLevel);</span><br><span class="line">        remainingLevelContribution -= timeAccruedToLevel;</span><br><span class="line">        remainingTaskTime -= timeAccruedToLevel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addLevelTime(newLevel, remainingLevelContribution);</span><br><span class="line">    <span class="comment">// 获取level中最低的优先级</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">newLevelMinPriority</span> <span class="operator">=</span> getLevelMinPriority(newLevel, scheduledNanos);</span><br><span class="line">    <span class="comment">// 耗时越高，levelPriority越高，越不易从优先级队列中取出。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Priority</span>(newLevel, newLevelMinPriority + remainingTaskTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PrioritizedSplitRunner">PrioritizedSplitRunner</h2><p>PrioritizedSplitRunner执行相关的核心方法是process。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> ListenableFuture&lt;Void&gt; <span class="title function_">process</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 本次调度启动时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">startNanos</span> <span class="operator">=</span> ticker.read();</span><br><span class="line">        <span class="comment">// 启动时间</span></span><br><span class="line">        start.compareAndSet(<span class="number">0</span>, startNanos);</span><br><span class="line">        <span class="comment">// 上次退出时间</span></span><br><span class="line">        lastReady.compareAndSet(<span class="number">0</span>, startNanos);</span><br><span class="line">        <span class="comment">// 调度次数+1</span></span><br><span class="line">        processCalls.incrementAndGet();</span><br><span class="line">        <span class="comment">// 等待时间</span></span><br><span class="line">        waitNanos.getAndAdd(startNanos - lastReady.get());</span><br><span class="line"></span><br><span class="line">        <span class="type">CpuTimer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CpuTimer</span>();</span><br><span class="line">        <span class="comment">// 调用内部Split，最多只能执行1s，否则返回ListenableFuture</span></span><br><span class="line">        ListenableFuture&lt;Void&gt; blocked = split.processFor(SPLIT_RUN_QUANTA);</span><br><span class="line">        CpuTimer.<span class="type">CpuDuration</span> <span class="variable">elapsed</span> <span class="operator">=</span> timer.elapsedTime();</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">quantaScheduledNanos</span> <span class="operator">=</span> ticker.read() - startNanos;</span><br><span class="line">        scheduledNanos.addAndGet(quantaScheduledNanos);</span><br><span class="line">        <span class="comment">// task更新优先级和耗时</span></span><br><span class="line">        priority.set(taskHandle.addScheduledNanos(quantaScheduledNanos));</span><br><span class="line">        <span class="comment">// 更新上次运行时间</span></span><br><span class="line">        lastRun.set(ticker.read());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (blocked == NOT_BLOCKED) &#123;</span><br><span class="line">            unblockedQuantaWallTime.add(elapsed.getWall());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            blockedQuantaWallTime.add(elapsed.getWall());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">quantaCpuNanos</span> <span class="operator">=</span> elapsed.getCpu().roundTo(NANOSECONDS);</span><br><span class="line">        cpuTimeNanos.addAndGet(quantaCpuNanos);</span><br><span class="line"></span><br><span class="line">        globalCpuTimeMicros.update(quantaCpuNanos / <span class="number">1000</span>);</span><br><span class="line">        globalScheduledTimeMicros.update(quantaScheduledNanos / <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> blocked;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        finishedFuture.setException(e);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TaskHandle也持有一个Priority对象，这个Priority对象可以理解成是其关联的PrioritizedSplitRunner共享的一个cahce。</p><p>TaskHandle如何做到调度时统一考虑其关联的所有PrioritizedSplitRunner：</p><ul><li>PrioritizedSplitRunner#process方法中，更新Priority的时候会调用TaskHandle#addScheduledNanos</li><li>TaskHandle#addScheduledNanos更新TaskHandle的Priority</li><li>PrioritizedSplitRunner在从MultiLevelSplitQueue#take中被取出时，会首先判断一下自己的Priority和TaskHandle的Priority是否一致，如果不一致，说明该TaskHandle累计的运行时间已经导致其升级到其它level了，其关联的所有PrioritizedSplitRunner也应该升级，此时将这个出队的PrioritizedSplitRunner重新放入队列，另外选取一个PrioritizedSplitRunner。</li></ul><h2 id="DriverSplitRunner">DriverSplitRunner</h2><p>DriverSplitRunner是PrioritizedSplitRunner内部实际执行的SplitRunner。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ListenableFuture&lt;Void&gt; <span class="title function_">processFor</span><span class="params">(Duration duration)</span></span><br><span class="line">&#123;</span><br><span class="line">    Driver driver;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">// if close() was called before we get here, there&#x27;s not point in even creating the driver</span></span><br><span class="line">        <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">            <span class="keyword">return</span> immediateVoidFuture();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.driver == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 创建Driver</span></span><br><span class="line">            <span class="built_in">this</span>.driver = driverSplitRunnerFactory.createDriver(driverContext, partitionedSplit);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        driver = <span class="built_in">this</span>.driver;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用driver执行</span></span><br><span class="line">    <span class="keyword">return</span> driver.processForDuration(duration);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//io.trino.execution.SqlTaskExecution</span></span><br><span class="line"><span class="keyword">public</span> Driver <span class="title function_">createDriver</span><span class="params">(DriverContext driverContext, <span class="meta">@Nullable</span> ScheduledSplit partitionedSplit)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> driverFactory.createDriver(driverContext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (partitionedSplit != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// TableScanOperator requires partitioned split to be added before the first call to process</span></span><br><span class="line">        driver.updateSplitAssignment(<span class="keyword">new</span> <span class="title class_">SplitAssignment</span>(partitionedSplit.getPlanNodeId(), ImmutableSet.of(partitionedSplit), <span class="literal">true</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pendingCreations.decrementAndGet();</span><br><span class="line">    closeDriverFactoryIfFullyCreated();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (driverFactory.getSourceId().isPresent() &amp;&amp; partitionedSplit == <span class="literal">null</span>) &#123;</span><br><span class="line">        driverReferences.add(<span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(driver));</span><br><span class="line">        scheduleSplits();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> driver;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//io.trino.operator.DriverFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Driver <span class="title function_">createDriver</span><span class="params">(DriverContext driverContext)</span></span><br><span class="line">&#123;</span><br><span class="line">    checkState(!noMoreDrivers, <span class="string">&quot;noMoreDrivers is already set&quot;</span>);</span><br><span class="line">    requireNonNull(driverContext, <span class="string">&quot;driverContext is null&quot;</span>);</span><br><span class="line">    ImmutableList.Builder&lt;Operator&gt; operators = ImmutableList.builder();</span><br><span class="line">    <span class="comment">//将Driver中的Operator初始化完毕</span></span><br><span class="line">    <span class="keyword">for</span> (OperatorFactory operatorFactory : operatorFactories) &#123;</span><br><span class="line">        <span class="type">Operator</span> <span class="variable">operator</span> <span class="operator">=</span> operatorFactory.createOperator(driverContext);</span><br><span class="line">        operators.add(operator);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Driver.createDriver(driverContext, operators.build());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Driver执行细节">Driver执行细节</h1><p>最终，Task的执行是通过DriverSplitRunner中内置的Driver来实现的。本节我们来进一步分析Driver的实现细节。</p><h2 id="process">process</h2><p>process的工作有:</p><ul><li>记录执行时间</li><li>设置yieldSignal，防止执行太长时间导致阻塞</li><li>调用真正执行的方法processInternal</li><li>返回BlockedFuture</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListenableFuture&lt;Void&gt; <span class="title function_">process</span><span class="params">(Duration maxRuntime, <span class="type">int</span> maxIterations)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// if the driver is blocked we don&#x27;t need to continue</span></span><br><span class="line">    SettableFuture&lt;Void&gt; blockedFuture = driverBlockedFuture.get();</span><br><span class="line">    <span class="keyword">if</span> (!blockedFuture.isDone()) &#123;</span><br><span class="line">        <span class="keyword">return</span> blockedFuture;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算最多运行时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">maxRuntimeInNanos</span> <span class="operator">=</span> maxRuntime.roundTo(TimeUnit.NANOSECONDS);</span><br><span class="line">    <span class="comment">// 当前线程尝试持有独占锁，最多等待100ms</span></span><br><span class="line">    Optional&lt;ListenableFuture&lt;Void&gt;&gt; result = tryWithLock(<span class="number">100</span>, TimeUnit.MILLISECONDS, <span class="literal">true</span>, () -&gt; &#123;</span><br><span class="line">        <span class="type">OperationTimer</span> <span class="variable">operationTimer</span> <span class="operator">=</span> createTimer();</span><br><span class="line">        driverContext.startProcessTimer();</span><br><span class="line">        <span class="comment">// 延迟设置yield信号，1s</span></span><br><span class="line">        driverContext.getYieldSignal().setWithDelay(maxRuntimeInNanos, driverContext.getYieldExecutor());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="type">int</span> <span class="variable">iterations</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!isFinishedInternal()) &#123;</span><br><span class="line">                <span class="comment">// 通过processInternal执行</span></span><br><span class="line">                <span class="comment">// yield 信号会用于 processInternal中的operator让出CPU</span></span><br><span class="line">                <span class="comment">// 从粗粒度实现用户态CPU资源的分时调度,</span></span><br><span class="line">                <span class="comment">// 进而实现cpu层面的多租户。</span></span><br><span class="line">                ListenableFuture&lt;Void&gt; future = processInternal(operationTimer);</span><br><span class="line">                iterations++;</span><br><span class="line">                <span class="keyword">if</span> (!future.isDone()) &#123;</span><br><span class="line">                    <span class="comment">//更新阻塞future原因</span></span><br><span class="line">                    <span class="keyword">return</span> updateDriverBlockedFuture(future);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (System.nanoTime() - start &gt;= maxRuntimeInNanos || iterations &gt;= maxIterations) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            ... ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//重置yield信号</span></span><br><span class="line">            driverContext.getYieldSignal().reset();</span><br><span class="line">            <span class="comment">// 记录执行时间</span></span><br><span class="line">            driverContext.recordProcessed(operationTimer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> NOT_BLOCKED;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result.orElse(NOT_BLOCKED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="processInternal">processInternal</h2><p>processInternal是Driver内部真正执行的地方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ListenableFuture&lt;Void&gt; <span class="title function_">processInternal</span><span class="params">(OperationTimer operationTimer)</span></span><br><span class="line">&#123;</span><br><span class="line">    checkLockHeld(<span class="string">&quot;Lock must be held to call processInternal&quot;</span>);</span><br><span class="line">    <span class="comment">// 处理内存撤回</span></span><br><span class="line">    handleMemoryRevoke();</span><br><span class="line">    <span class="comment">// 处理新增的SplitAssignment</span></span><br><span class="line">    processNewSources();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!activeOperators.isEmpty() &amp;&amp; activeOperators.size() != allOperators.size()) &#123;</span><br><span class="line">        <span class="comment">// 如果还有activeOperators, 告知第一个operator没有输入数据</span></span><br><span class="line">        <span class="type">Operator</span> <span class="variable">rootOperator</span> <span class="operator">=</span> activeOperators.get(<span class="number">0</span>);</span><br><span class="line">        rootOperator.finish();</span><br><span class="line">        rootOperator.getOperatorContext().recordFinish(operationTimer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">movedPage</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; activeOperators.size() - <span class="number">1</span> &amp;&amp; !driverContext.isDone(); i++) &#123;</span><br><span class="line">        <span class="comment">// 获取当前Operator</span></span><br><span class="line">        <span class="type">Operator</span> <span class="variable">current</span> <span class="operator">=</span> activeOperators.get(i);</span><br><span class="line">        <span class="comment">// 获取下一个Operator</span></span><br><span class="line">        <span class="type">Operator</span> <span class="variable">next</span> <span class="operator">=</span> activeOperators.get(i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// skip blocked operator</span></span><br><span class="line">        <span class="keyword">if</span> (getBlockedFuture(current).isPresent()) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前Operator没有结束，同时下一个operator没有blocked且需要输入</span></span><br><span class="line">        <span class="keyword">if</span> (!current.isFinished() &amp;&amp; getBlockedFuture(next).isEmpty() &amp;&amp; next.needsInput()) &#123;</span><br><span class="line">            <span class="comment">// 从当前Operator获取输出page</span></span><br><span class="line">            <span class="type">Page</span> <span class="variable">page</span> <span class="operator">=</span> current.getOutput();</span><br><span class="line">            current.getOperatorContext().recordGetOutput(operationTimer, page);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// if we got an output page, add it to the next operator</span></span><br><span class="line">            <span class="keyword">if</span> (page != <span class="literal">null</span> &amp;&amp; page.getPositionCount() != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 将当前operator的输出作为下一个operator的输出</span></span><br><span class="line">                next.addInput(page);</span><br><span class="line">                next.getOperatorContext().recordAddInput(operationTimer, page);</span><br><span class="line">                <span class="comment">// 标记 page移动</span></span><br><span class="line">                movedPage = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (current <span class="keyword">instanceof</span> SourceOperator) &#123;</span><br><span class="line">                <span class="comment">// 标记 page移动</span></span><br><span class="line">                movedPage = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if current operator is finished...</span></span><br><span class="line">        <span class="keyword">if</span> (current.isFinished()) &#123;</span><br><span class="line">            <span class="comment">// 告知下一个operator没有输入数据</span></span><br><span class="line">            next.finish();</span><br><span class="line">            next.getOperatorContext().recordFinish(operationTimer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> activeOperators.size() - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line">        <span class="comment">//如果当前Operator已经结束，那么前面的Operator也应该结束了</span></span><br><span class="line">        <span class="keyword">if</span> (activeOperators.get(index).isFinished()) &#123;</span><br><span class="line">            <span class="comment">// close and remove this operator and all source operators</span></span><br><span class="line">            List&lt;Operator&gt; finishedOperators = <span class="built_in">this</span>.activeOperators.subList(<span class="number">0</span>, index + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 关闭和销毁结束的Operator</span></span><br><span class="line">            <span class="type">Throwable</span> <span class="variable">throwable</span> <span class="operator">=</span> closeAndDestroyOperators(finishedOperators);</span><br><span class="line">            <span class="comment">// 从activeOperators中删除这个sublist</span></span><br><span class="line">            finishedOperators.clear(); </span><br><span class="line">            <span class="keyword">if</span> (throwable != <span class="literal">null</span>) &#123;</span><br><span class="line">                throwIfUnchecked(throwable);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(throwable);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Finish the next operator, which is now the first operator.</span></span><br><span class="line">            <span class="keyword">if</span> (!activeOperators.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// 告知下一个operator没有输入数据</span></span><br><span class="line">                <span class="type">Operator</span> <span class="variable">newRootOperator</span> <span class="operator">=</span> activeOperators.get(<span class="number">0</span>);</span><br><span class="line">                newRootOperator.finish();</span><br><span class="line">                newRootOperator.getOperatorContext().recordFinish(operationTimer);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有发生Page移动，检查是不是阻塞了</span></span><br><span class="line">    <span class="keyword">if</span> (!movedPage) &#123;</span><br><span class="line">        List&lt;Operator&gt; blockedOperators = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;ListenableFuture&lt;Void&gt;&gt; blockedFutures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Operator operator : activeOperators) &#123;</span><br><span class="line">            Optional&lt;ListenableFuture&lt;Void&gt;&gt; blocked = getBlockedFuture(operator);</span><br><span class="line">            <span class="keyword">if</span> (blocked.isPresent()) &#123;</span><br><span class="line">                blockedOperators.add(operator);</span><br><span class="line">                blockedFutures.add(blocked.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 确实有阻塞Operator</span></span><br><span class="line">        <span class="keyword">if</span> (!blockedFutures.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// allow for operators to unblock drivers when they become finished</span></span><br><span class="line">            <span class="comment">// 当任意operator完成时，也能解除driver的阻塞状态。</span></span><br><span class="line">            <span class="keyword">for</span> (Operator operator : activeOperators) &#123;</span><br><span class="line">                operator.getOperatorContext().getFinishedFuture().ifPresent(blockedFutures::add);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建包装阻塞, 内部任何阻塞完成，都会解除blocked状态</span></span><br><span class="line">            ListenableFuture&lt;Void&gt; blocked = firstFinishedFuture(blockedFutures);</span><br><span class="line">            <span class="comment">// driver records serial blocked time</span></span><br><span class="line">            driverContext.recordBlocked(blocked);</span><br><span class="line">            <span class="comment">// each blocked operator is responsible for blocking the execution</span></span><br><span class="line">            <span class="comment">// until one of the operators can continue</span></span><br><span class="line">            <span class="keyword">for</span> (Operator operator : blockedOperators) &#123;</span><br><span class="line">                operator.getOperatorContext().recordBlocked(blocked);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//返回阻塞</span></span><br><span class="line">            <span class="keyword">return</span> blocked;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 无阻塞</span></span><br><span class="line">    <span class="keyword">return</span> NOT_BLOCKED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>排在后面的operator依赖前面的Operator的输入，最前面的Operator是SourceOperator。可以想象每当Source产生一个Page，就会自底向上move，一直到Output Operator。从这种执行逻辑来看，Trino的计算模型是Push模型。</p><pre class="mermaid">flowchart BT
subgraph Driver
Operator1(Source operator) --&gt;|Page| Operator2(operator)
Operator2 --&gt;|Page| Operator3(Output operator)
end</pre><h2 id="destroyIfNecessary">destroyIfNecessary</h2><p>调用链路: <code>process-&gt; tryWithLock -&gt;destroyIfNecessary</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">destroyIfNecessary</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    checkLockHeld(<span class="string">&quot;Lock must be held to call destroyIfNecessary&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!state.compareAndSet(State.NEED_DESTRUCTION, State.DESTROYED)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we get an error while closing a driver, record it and we will throw it at the end</span></span><br><span class="line">    <span class="type">Throwable</span> <span class="variable">inFlightException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        inFlightException = closeAndDestroyOperators(activeOperators);</span><br><span class="line">        <span class="keyword">if</span> (driverContext.getMemoryUsage() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Driver still has memory reserved after freeing all operator memory.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (driverContext.getRevocableMemoryUsage() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Driver still has revocable memory reserved after freeing all operator memory. Freeing it.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        driverContext.finished();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// this shouldn&#x27;t happen but be safe</span></span><br><span class="line">        inFlightException = addSuppressedException(</span><br><span class="line">                inFlightException,</span><br><span class="line">                t,</span><br><span class="line">                <span class="string">&quot;Error destroying driver for task %s&quot;</span>,</span><br><span class="line">                driverContext.getTaskId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inFlightException != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// this will always be an Error or Runtime</span></span><br><span class="line">        throwIfUnchecked(inFlightException);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(inFlightException);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Pipeline">Pipeline</h1><p>上面介绍了DriverSplitRunner的执行细节。每个DriverSplitRunner实际上代表了一个并行度下的一批operator的执行器。而一组DriverSplitRunner就是trino中的pipeline概念(包含在一个任务里的一串并行度相同的算子叫作流水线)。</p><p>一个SqlTaskExecution就对应了一个Task的执行。每个SqlTaskExecution中有多个Pipeline，每个pipeline是一些相同并发度的Operator列表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">    t.<span class="operator">*</span>,n.<span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    system.runtime.tasks t</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> </span><br><span class="line">    system.runtime.nodes n</span><br><span class="line"><span class="keyword">on</span> </span><br><span class="line">    t.node_id <span class="operator">=</span> n.node_id</span><br><span class="line"><span class="keyword">where</span> </span><br><span class="line">    t.state <span class="operator">=</span> <span class="string">&#x27;FINISHED&#x27;</span></span><br></pre></td></tr></table></figure><p>上面的Sql对应的查询Stage如下(stage1和stage2中只有一个pipeline0，图中就省略了):</p><pre class="mermaid">flowchart BT
    subgraph stage0
        subgraph Pipeline0
            ExchangeOperator0(ExchangeOperator) --&gt; LocalExchangeSinkOperator
        end 
        subgraph Pipeline1
            LocalExchangeSourceOperator --&gt; HashBuildOperator
        end 
        subgraph Pipeline2
            ExchangeOperator1(ExchangeOperator) --&gt; LookupJoinOperator
            LookupJoinOperator--&gt; TaskOutputOperator
        end 
        LocalExchangeSinkOperator -.-&gt; LocalExchangeSourceOperator
        HashBuildOperator -.-&gt; LookupJoinOperator
    end
    subgraph stage1
        ScanFilterAndProjectOperator1(ScanFilterAndProjectOperator)--&gt; PartitionedOutputOperator1(PartitionedOutputOperator)
    end
    subgraph stage2
        ScanFilterAndProjectOperator2(ScanFilterAndProjectOperator)--&gt; PartitionedOutputOperator2(PartitionedOutputOperator)
    end
    PartitionedOutputOperator2-.-&gt;ExchangeOperator0
    PartitionedOutputOperator1-.-&gt;ExchangeOperator1</pre><p>在介绍本地运行逻辑计划中的DriverFactory有提到过，DriverFactory中的属性pipelineId就是Driver所在的Pipeline。没遇到一个LocalExchangeOperator或者包含LocalExchange的Operator(例如HashBuildOperator)就会在执行计划中创建一个新的pipeline。</p><p>在本地执行时，每个SqlTaskExecution中都会有执行上下文TaskContext。每个DriverSplitRunnerFactory在创建时，会在TaskContext中添加PipelineContext。同时在createDriverRunner时，会在每个PipelineContext中创建DriverContext。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">DriverSplitRunnerFactory</span><span class="params">(DriverFactory driverFactory, <span class="type">boolean</span> partitioned)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">this</span>.driverFactory = driverFactory;</span><br><span class="line">    <span class="built_in">this</span>.pipelineContext = taskContext.addPipelineContext(driverFactory.getPipelineId(), driverFactory.isInputDriver(), driverFactory.isOutputDriver(), partitioned);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> DriverSplitRunner <span class="title function_">createDriverRunner</span><span class="params">(<span class="meta">@Nullable</span> ScheduledSplit partitionedSplit)</span></span><br><span class="line">&#123;</span><br><span class="line">    checkState(!noMoreDriverRunner.get(), <span class="string">&quot;noMoreDriverRunner is set&quot;</span>);</span><br><span class="line">    pendingCreations.incrementAndGet();</span><br><span class="line">    <span class="comment">// create driver context immediately so the driver existence is recorded in the stats</span></span><br><span class="line">    <span class="comment">// the number of drivers is used to balance work across nodes</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">splitWeight</span> <span class="operator">=</span> partitionedSplit == <span class="literal">null</span> ? <span class="number">0</span> : partitionedSplit.getSplit().getSplitWeight().getRawValue();</span><br><span class="line">    <span class="type">DriverContext</span> <span class="variable">driverContext</span> <span class="operator">=</span> pipelineContext.addDriverContext(splitWeight);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DriverSplitRunner</span>(<span class="built_in">this</span>, driverContext, partitionedSplit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LocalExchage">LocalExchage</h2><p>trino使用LocalExchange在pipieline间传递数据(page)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalExchange</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Supplier&lt;LocalExchanger&gt; exchangerSupplier;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;LocalExchangeSource&gt; sources;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LocalExchangeMemoryManager memoryManager;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LocalExchange</span><span class="params">(... ...)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ImmutableList.Builder&lt;LocalExchangeSource&gt; sources = ImmutableList.builder();</span><br><span class="line">        <span class="comment">// 基于分区方式和并行度计算buffer数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">bufferCount</span> <span class="operator">=</span> computeBufferCount(partitioning, defaultConcurrency, partitionChannels);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bufferCount; i++) &#123;</span><br><span class="line">            sources.add(<span class="keyword">new</span> <span class="title class_">LocalExchangeSource</span>(source -&gt; checkAllSourcesFinished()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.sources = sources.build();</span><br><span class="line">        <span class="comment">// 将LocalExchangeSource包装成Consumer&lt;PageReference&gt;</span></span><br><span class="line">        List&lt;Consumer&lt;PageReference&gt;&gt; buffers = <span class="built_in">this</span>.sources.stream()</span><br><span class="line">                .map(buffer -&gt; (Consumer&lt;PageReference&gt;) buffer::addPage)</span><br><span class="line">                .collect(toImmutableList());</span><br><span class="line">        <span class="comment">// 创建localExchange内存管理器</span></span><br><span class="line">        <span class="built_in">this</span>.memoryManager = <span class="keyword">new</span> <span class="title class_">LocalExchangeMemoryManager</span>(maxBufferedBytes.toBytes());</span><br><span class="line">        <span class="comment">// 根据分区方式创建不同的Exchanger,后面用于LocalExchangeSink</span></span><br><span class="line">        <span class="comment">// 在LocalExchangeSink acceptpage时，会调用buffer的addPage。</span></span><br><span class="line">        <span class="keyword">if</span> (partitioning.equals(SINGLE_DISTRIBUTION)) &#123;</span><br><span class="line">            exchangerSupplier = () -&gt; <span class="keyword">new</span> <span class="title class_">BroadcastExchanger</span>(buffers, memoryManager);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (partitioning.equals(FIXED_BROADCAST_DISTRIBUTION)) &#123;</span><br><span class="line">            exchangerSupplier = () -&gt; <span class="keyword">new</span> <span class="title class_">BroadcastExchanger</span>(buffers, memoryManager);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (partitioning.equals(FIXED_ARBITRARY_DISTRIBUTION)) &#123;</span><br><span class="line">            exchangerSupplier = () -&gt; <span class="keyword">new</span> <span class="title class_">RandomExchanger</span>(buffers, memoryManager);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (partitioning.equals(FIXED_PASSTHROUGH_DISTRIBUTION)) &#123;</span><br><span class="line">            Iterator&lt;LocalExchangeSource&gt; sourceIterator = <span class="built_in">this</span>.sources.iterator();</span><br><span class="line">            exchangerSupplier = () -&gt; &#123;</span><br><span class="line">                checkState(sourceIterator.hasNext(), <span class="string">&quot;no more sources&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PassthroughExchanger</span>(sourceIterator.next(), maxBufferedBytes.toBytes() / bufferCount, memoryManager::updateMemoryUsage);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (partitioning.equals(SCALED_WRITER_ROUND_ROBIN_DISTRIBUTION)) &#123;</span><br><span class="line">            exchangerSupplier = () -&gt; <span class="keyword">new</span> <span class="title class_">ScaleWriterExchanger</span>(... ... );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (partitioning.equals(FIXED_HASH_DISTRIBUTION) || partitioning.getCatalogHandle().isPresent() ||</span><br><span class="line">                (partitioning.getConnectorHandle() <span class="keyword">instanceof</span> MergePartitioningHandle)) &#123;</span><br><span class="line">            exchangerSupplier = () -&gt; &#123;</span><br><span class="line">                ... ... </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PartitioningExchanger</span>(... ...);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unsupported local exchange partitioning &quot;</span> + partitioning);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LocalExchangeSource中有属性<code>BlockingQueue&lt;PageReference&gt; buffer</code>,每当调用addPage方法时就会将Page加入到buffer中。然后通过removePage方法给LocalExchangeSourceOperator提供output。</p></div><footer class="post-footer"><div class="reward-container"><div>请我一杯咖啡吧！</div><button>赞赏</button><div class="post-reward"><div><img src="/images/weixinpay.webp" alt="Victor Chu 微信"> <span>微信</span></div><div><img src="/images/alpay.webp" alt="Victor Chu 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"><strong>本文作者： </strong>Victor Chu</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://www.victorchu.info/posts/fe718156/" title="Trino源码学习-TASK执行">https://www.victorchu.info/posts/fe718156/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="followme"><span>欢迎关注我的其它发布渠道</span><div class="social-list"><div class="social-item"><a target="_blank" class="social-link" href="/atom.xml"><span class="icon"><i class="fa fa-rss"></i> </span><span class="label">RSS</span></a></div><div class="social-item"><a target="_blank" class="social-link" href="/images/wechat_channel.webp"><span class="icon"><i class="fab fa-weixin"></i> </span><span class="label">WeChat</span></a></div></div></div><div class="post-tags"><a href="/tags/Presto/" rel="tag"><i class="fa fa-tag"></i> Presto</a> <a href="/tags/Trino/" rel="tag"><i class="fa fa-tag"></i> Trino</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/d1f5c023/" rel="prev" title="HikariCP: Failed to validate connection"><i class="fa fa-angle-left"></i> HikariCP: Failed to validate connection</a></div><div class="post-nav-item"><a href="/posts/729a4968/" rel="next" title="Trino源码学习-内存管理">Trino源码学习-内存管理 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">浙ICP备18037908号-1 </a><img src="/images/gongan_icon.webp" alt=""><a href="https://beian.mps.gov.cn/#/query/webSearch?code=33010902002043" rel="noopener" target="_blank">浙公网安备 33010902002043号</a></div><div class="copyright">&copy; 2016 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Victor Chu</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span title="站点总字数">1.7m</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">46:21</span></span></div><div class="powered-by">由<a href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" class="theme-link" rel="noopener" target="_blank"><img src="/images/upyun_logo.webp" width="50" style="display:inline"></a>提供CDN服务</div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/algoliasearch/4.23.3/algoliasearch-lite.umd.js" integrity="sha256-1QNshz86RqXe/qsCBldsUu13eAX6n/O98uubKQs87UI=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/instantsearch.js/4.67.0/instantsearch.production.min.js" integrity="sha256-TW7D3X/i/W+RUgEeDppEnFT2ixv5lzplKH0c58D92dY=" crossorigin="anonymous"></script><script src="/js/third-party/search/algolia-search.js"></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":"default","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.9.0/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script><script src="/js/third-party/tags/mermaid.js"></script><script src="/js/third-party/fancybox.js"></script><script class="next-config" data-name="enableMath" type="application/json">false</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css" integrity="sha256-UF1fgpAiu3tPJN/uCqEUHNe7pnr+QR0SQDNfgglgtcM=" crossorigin="anonymous"><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"walineui.victorchu.info","cssUrl":"https://cdn.staticfile.org/waline/2.15.8/waline.css","commentCount":true,"pageview":true,"requiredMeta":["nick","mail"],"login":"force","libUrl":"https://cdn.staticfile.org/waline/2.15.8/waline.js","el":"#waline","comment":true,"path":"/posts/fe718156/"}</script><link rel="stylesheet" href="https://cdn.staticfile.org/waline/2.15.8/waline.css"><script>document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});</script></body></html>