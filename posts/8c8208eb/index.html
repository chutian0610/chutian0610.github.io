<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-fill-left.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"www.victorchu.info","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"waline","storage":false,"lazyload":false,"nav":null,"activeClass":"waline"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"algolia":{"appID":"X9UOD4FSUP","apiKey":"fa32db1f02073025c69da8ebad0a6aa6","indexName":"hexo-next-blog","hits":{"per_page":10}}}</script><script src="/js/config.js"></script><meta name="description" content="线程有时也被称为轻量级的进程。进程和线程都提供了一个执行环境，但创建一个新的线程比创建一个新的进程需要的资源要少。 线程是在进程中存在的，每个进程最少有一个线程。线程共享进程的资源，包括内存和打开的文件。这样提高了效率，但潜在的问题就是线程间的通信。"><meta property="og:type" content="article"><meta property="og:title" content="Java并发之Thread"><meta property="og:url" content="https://www.victorchu.info/posts/8c8208eb/index.html"><meta property="og:site_name" content="代码之旅"><meta property="og:description" content="线程有时也被称为轻量级的进程。进程和线程都提供了一个执行环境，但创建一个新的线程比创建一个新的进程需要的资源要少。 线程是在进程中存在的，每个进程最少有一个线程。线程共享进程的资源，包括内存和打开的文件。这样提高了效率，但潜在的问题就是线程间的通信。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.victorchu.info/posts/8c8208eb/thread.webp"><meta property="article:published_time" content="2017-09-05T14:45:54.000Z"><meta property="article:modified_time" content="2025-02-05T08:11:38.645Z"><meta property="article:author" content="Victor Chu"><meta property="article:tag" content="Java"><meta property="article:tag" content="Concurrency"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.victorchu.info/posts/8c8208eb/thread.webp"><link rel="canonical" href="https://www.victorchu.info/posts/8c8208eb/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.victorchu.info/posts/8c8208eb/","path":"/posts/8c8208eb/","title":"Java并发之Thread"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Java并发之Thread | 代码之旅</title><script src="/js/third-party/analytics/baidu-analytics.js"></script><script async src="https://hm.baidu.com/hm.js?277fc29fa80de77c97f4f62b69e94233"></script><link rel="dns-prefetch" href="walineui.victorchu.info"><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="alternate" href="/atom.xml" title="代码之旅" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">代码之旅</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">I love Coding !</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">119</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">87</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">225</span></a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="algolia-stats"><hr></div><div class="algolia-hits"></div><div class="algolia-pagination"></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.</span> <span class="nav-text">线程的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="nav-number">1.1.</span> <span class="nav-text">线程调度</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%B9%B6%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">定义并启动一个线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BFThread%E7%B1%BB"><span class="nav-number">2.1.</span> <span class="nav-text">继承Thread类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.2.</span> <span class="nav-text">实现Runnable接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Thread-start"><span class="nav-number">2.3.</span> <span class="nav-text">Thread.start</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#isAlive-%E6%96%B9%E6%B3%95"><span class="nav-number">2.4.</span> <span class="nav-text">isAlive()方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sleep-%E6%96%B9%E6%B3%95"><span class="nav-number">2.5.</span> <span class="nav-text">sleep()方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#getId-%E6%96%B9%E6%B3%95"><span class="nav-number">2.6.</span> <span class="nav-text">getId()方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">终止线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%BA%E8%A1%8C%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B%E5%AF%BC%E8%87%B4%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4"><span class="nav-number">3.1.</span> <span class="nav-text">强行终止线程导致数据不一致</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E9%87%8A%E6%94%BE%E9%94%81%EF%BC%8C%E7%A0%B4%E5%9D%8F%E5%AF%B9%E8%B1%A1%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number">3.2.</span> <span class="nav-text">直接释放锁，破坏对象一致性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD"><span class="nav-number">4.</span> <span class="nav-text">线程中断</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Thread-interrupt"><span class="nav-number">4.1.</span> <span class="nav-text">Thread.interrupt()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Thread-isInterrupted"><span class="nav-number">4.2.</span> <span class="nav-text">Thread.isInterrupted</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Thread-interrupted"><span class="nav-number">4.3.</span> <span class="nav-text">Thread.interrupted()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%96%AD"><span class="nav-number">4.4.</span> <span class="nav-text">使用中断</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#wait-notify"><span class="nav-number">5.</span> <span class="nav-text">wait &amp; notify</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">5.1.</span> <span class="nav-text">执行过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Demo"><span class="nav-number">5.2.</span> <span class="nav-text">Demo</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#suspend-resume"><span class="nav-number">6.</span> <span class="nav-text">suspend &amp; resume</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"><span class="nav-number">6.1.</span> <span class="nav-text">简单使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">6.2.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#join"><span class="nav-number">7.</span> <span class="nav-text">join</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#yield"><span class="nav-number">8.</span> <span class="nav-text">yield</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#onSpinWait"><span class="nav-number">9.</span> <span class="nav-text">onSpinWait</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">10.</span> <span class="nav-text">线程的生命周期</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%9A%E7%BA%BF%E7%A8%8B%E7%BB%84"><span class="nav-number">11.</span> <span class="nav-text">线程管理：线程组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E7%BA%A7%E5%85%B3%E8%81%94-ThreadGroup-Thread"><span class="nav-number">11.1.</span> <span class="nav-text">一级关联(ThreadGroup -&gt; Thread)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%B9%E9%87%8F%E4%B8%AD%E6%96%AD%E7%BB%84%E5%86%85%E7%BA%BF%E7%A8%8B"><span class="nav-number">11.2.</span> <span class="nav-text">批量中断组内线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E5%85%B3%E8%81%94"><span class="nav-number">11.3.</span> <span class="nav-text">多级关联</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%BB%84%E7%9A%84%E9%80%92%E5%BD%92%E5%A4%84%E7%90%86"><span class="nav-number">11.4.</span> <span class="nav-text">线程组的递归处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#list"><span class="nav-number">11.4.1.</span> <span class="nav-text">list()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#enumerate"><span class="nav-number">11.4.2.</span> <span class="nav-text">enumerate()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E5%AD%90"><span class="nav-number">11.4.3.</span> <span class="nav-text">例子</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%BB%84%E8%87%AA%E5%8A%A8%E5%BD%92%E5%B1%9E"><span class="nav-number">11.5.</span> <span class="nav-text">线程组自动归属</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B9%E7%BA%BF%E7%A8%8B%E7%BB%84"><span class="nav-number">11.6.</span> <span class="nav-text">根线程组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AA%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8%E7%9A%84%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86"><span class="nav-number">11.7.</span> <span class="nav-text">未捕获异常的统一处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">11.8.</span> <span class="nav-text">线程优先级</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E6%9C%89%E7%BB%A7%E6%89%BF%E6%80%A7"><span class="nav-number">11.8.1.</span> <span class="nav-text">线程的优先级有继承性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%A7%84%E5%88%99"><span class="nav-number">11.8.2.</span> <span class="nav-text">优先级规则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#daemon%E8%BF%9B%E7%A8%8B"><span class="nav-number">11.9.</span> <span class="nav-text">daemon进程</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Victor Chu" src="/images/victor-blog-head.webp"><p class="site-author-name" itemprop="name">Victor Chu</p><div class="site-description" itemprop="description">blog about programming.</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">225</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">87</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">119</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/chutian0610" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;chutian0610" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:victorchu0610@outlook.com" title="E-Mail → mailto:victorchu0610@outlook.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/victorchu" title="Zhihu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;victorchu" rel="noopener me" target="_blank"><i class="fab fa-zhihu fa-fw"></i>Zhihu</a> </span><span class="links-of-author-item"><a href="/images/Wechat.webp" title="WeChat → &#x2F;images&#x2F;Wechat.webp" rel="noopener me"><i class="fa-brands fa-weixin fa-fw"></i>WeChat</a></span></div></div></div></div><div class="sidebar-inner sidebar-blogroll"><div class="links-of-blogroll animated"><div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i> 链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://www.tpfuture.top/" title="https:&#x2F;&#x2F;www.tpfuture.top&#x2F;" rel="noopener" target="_blank">一水轩</a></li></ul></div></div><div class="sidebar-inner sidebar-post-related"><div class="animated"><div class="links-of-blogroll-title"><i class="fa fa-signs-post fa-fw"></i> 相关文章</div><ul class="popular-posts"><li class="popular-posts-item"><a class="popular-posts-link" href="/posts/496918eb/" rel="bookmark"><time class="popular-posts-time">2022-03-01</time><br>log 性能优化</a></li></ul></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.victorchu.info/posts/8c8208eb/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/victor-blog-head.webp"><meta itemprop="name" content="Victor Chu"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="代码之旅"><meta itemprop="description" content="blog about programming."></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Java并发之Thread | 代码之旅"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Java并发之Thread</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2017-09-05 22:45:54" itemprop="dateCreated datePublished" datetime="2017-09-05T22:45:54+08:00">2017-09-05</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2025-02-05 16:11:38" itemprop="dateModified" datetime="2025-02-05T16:11:38+08:00">2025-02-05</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a> </span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/Concurrency/" itemprop="url" rel="index"><span itemprop="name">Concurrency</span></a> </span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Waline：</span> <a title="waline" href="/posts/8c8208eb/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/8c8208eb/" itemprop="commentCount"></span> </a></span><span class="post-meta-item" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="waline-pageview-count" data-path="/posts/8c8208eb/"></span> </span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>33k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>55 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>线程有时也被称为轻量级的进程。进程和线程都提供了一个执行环境，但创建一个新的线程比创建一个新的进程需要的资源要少。 线程是在进程中存在的，每个进程最少有一个线程。线程共享进程的资源，包括内存和打开的文件。这样提高了效率，但潜在的问题就是线程间的通信。</p><span id="more"></span><h1 id="线程的实现">线程的实现</h1><p>线程的实现主要有3种方式:</p><ul><li>使用内核线程实现;</li><li>使用用户线程实现</li><li>使用用户线程加轻量级进程混合实现。</li></ul><p>内核线程就是直接由操作系统内核支持的线程，这类线程由内核来完成线程切换，内核通过调度器调度线程，并将线程的任务映射到各个处理器上。</p><p>轻量级进程是内核线程的一种高级接口——轻量级进程，轻量级进程就是通常意义上所说的线程，每个轻量级进程都由一个内核线程支持，这种轻量级进程与内核进程之间1:1的关系称为一对一线程模型。每个轻量级进程都是一个独立的调度单元，即使有一个轻量级进程在系统调用中被阻塞了，也不会影响整个进程。轻量级进程有它的局限性:</p><ol><li>基于内核线程实现，所以各种线程操作，如创建，析构和同步，都需要进行系统调用，这需要在用户态和内核态之间来回切换，代价较高。</li><li>每个轻量级进程都需要一个内核线程的支持，需要消耗一定的内核资源。因此，一个系统支持的轻量级进程的数量是有限的。</li></ol><p>用户线程的广义定义是:一个线程只要不是内核线程，就可以认为是用户线程。所以，广义地说，轻量级进程也是用户线程。但是，轻量级进程的实现始终是建立在内核上的。用户线程的狭义定义是指完全建立在用户空间上的线程库，系统内核不能感知线程存在的实现。用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。这种线程快速高效，常用于实现进程与线程的1:N关系。用户线程的劣势在于没有内核的支持，所有的线程操作都需要自己实现，程序一般比较复杂。</p><p>用户线程加轻量级进程混合实现:将轻量级进程作为用户线程和内核线程之间的桥梁。主流的操作系统都提供了线程实现，java 语言则提供了在不同硬件和操作系统平台下对线程操作的统一处理。每个执行了<code>start()</code>方法并且还未结束的Thread实例，都代表一个线程。Thread类中的关键方法大都是声明为Native(平台相关)的。</p><h2 id="线程调度">线程调度</h2><p>线程调度的主要方式有2种:协同式线程调度和抢占式线程调度。</p><p>使用协同式线程调度的多线程系统，线程的执行时间由线程自身来控制，线程完成自身任务后，要主动通知系统切换到另外一个线程上。协同式系统的最大好处在于实现简单，且不存在线程同步问题。同样，坏处也很明显，如果一个线程有问题，一直不告知系统切换就会一直阻塞在那。使用抢占式调度的系统，线程由系统来分配时间，线程的切换不受自身控制。在这种情况下，不存在线程导致整个进程阻塞的情况，Java线程的调度方式就是抢占式调度。</p><h1 id="定义并启动一个线程">定义并启动一个线程</h1><p>使用<code>Thread</code>新建线程有两种写法：</p><h2 id="继承Thread类">继承Thread类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">helloThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello from a thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">helloThread.start();</span><br></pre></td></tr></table></figure><h2 id="实现Runnable接口">实现Runnable接口</h2><p><code>Runnable</code>对象仅包含一个<code>run()</code>方法，在这个方法中定义的代码将在会线程中执行。将<code>Runnable</code>对象传递给<code>Thread</code>类的构造函数即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello from a thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">HelloRunnable</span>())).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Thread#start 方法会调用 Thread 的 run 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread 的 run()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// target 就是传入的 Runnable 对象</span></span><br><span class="line">    <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Thread-start">Thread.start</h2><p>开启新线程需要调用Thread.start()方法，直接调用run()方法，只会在当前线程串行执行run()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; is running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Thread mythread=<span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;mythread&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; call mythread.run()&quot;</span>);</span><br><span class="line">        mythread.run();</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; call mythread.start()&quot;</span>);</span><br><span class="line">        mythread.start();</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* ------out put ---------</span></span><br><span class="line"><span class="comment"> * main call mythread.run()</span></span><br><span class="line"><span class="comment"> * main is running</span></span><br><span class="line"><span class="comment"> * main call mythread.start()</span></span><br><span class="line"><span class="comment"> * mythread is running</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><div class="note info"><ol><li><code>Thread.currentThread()</code>方法可以返回代码段正在被哪个线程调用的信息。</li><li>执行<code>start()</code>方法的顺序并不代表线程启动的顺序。</li></ol></div><h2 id="isAlive-方法"><code>isAlive()</code>方法</h2><p>方法<code>isAlive()</code>的功能是判断当前的线程是否处于活动状态。活动状态是指线程已经启动且尚未终止。返回true表示线程还&quot;存活&quot;。</p><h2 id="sleep-方法"><code>sleep()</code>方法</h2><p>方法<code>sleep()</code>的作用是在指定的毫秒数内让当前正在执行的线程暂停执行。</p><h2 id="getId-方法"><code>getId()</code>方法</h2><p><code>getId()</code>方法的作用是取得线程的唯一标识。</p><h1 id="终止线程">终止线程</h1><p>一般来说，线程执行完后就会结束；但是，一些后台线程可能会常驻系统，不会正常终结。如何正常关闭一个线程？JDK的Thread提供了<code>stop()</code>方法，但要注意的是该方法已经被弃用。使用该方法会带来不安全性。</p><h2 id="强行终止线程导致数据不一致">强行终止线程导致数据不一致</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略 setter and getter</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;user -&gt; [ id = &quot;</span>+id+<span class="string">&quot;, name = &quot;</span>+name+<span class="string">&quot; ]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们通过 Thread 来修改User对象的属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> (<span class="type">int</span>) System.currentTimeMillis() / <span class="number">1000</span>;</span><br><span class="line">                    user.setId(tmp);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">99</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    user.setName(String.valueOf(tmp));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        thread.stop();</span><br><span class="line">        System.out.println(user);</span><br><span class="line"><span class="comment">//-----------------------</span></span><br><span class="line"><span class="comment">//user -&gt; [ id = -1064621, name = 0 ]</span></span><br></pre></td></tr></table></figure><p>显然，此处的id与name并不相同，stop方法强行终止了setName方法的执行。</p><h2 id="直接释放锁，破坏对象一致性">直接释放锁，破坏对象一致性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StopThread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Reader</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (StopThread.class) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (user.getId()!= Integer.parseInt(user.getName())) &#123;</span><br><span class="line">                        System.out.println(user);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                Thread.<span class="keyword">yield</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Writer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (StopThread.class)&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> (<span class="type">int</span>) System.currentTimeMillis()/<span class="number">1000</span>;</span><br><span class="line">                    user.setId(tmp);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    user.setName(String.valueOf(tmp));</span><br><span class="line">                &#125;</span><br><span class="line">                Thread.<span class="keyword">yield</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Reader</span>()).start();</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Writer</span>());</span><br><span class="line">            thread.start();</span><br><span class="line">            Thread.sleep(<span class="number">150</span>);</span><br><span class="line">            thread.stop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Thread.stop()</code>在结束线程时，会直接终止线程，立即释放线程所持有的锁。假设当前写入线程写入数据进行到一半，并强行终止，对象数据不一致；又因为锁已经被释放，读进程将读入不一致对象。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user -&gt; <span class="punctuation">[</span> id = <span class="number">-1063553</span><span class="punctuation">,</span> name = <span class="number">-1063554</span> <span class="punctuation">]</span></span><br><span class="line">user -&gt; <span class="punctuation">[</span> id = <span class="number">-1063552</span><span class="punctuation">,</span> name = <span class="number">-1063553</span> <span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>总结下，<code>Thread.stop()</code>的使用会带来数据不一致的问题，所以尽量避免使用该方法。大多数stop的使用，应当被替换为简单修改某些共享变量来指示其目标线程将停止运行的代码。目标线程应当有规律的检查这些变量。并且，如果这些变量指示其将停止运行，目标线程应当以某种有序的方式从它的run方法返回。为了确保停止请求的及时传达，变量必须是 volatile 的（或者变量的访问被同步）。</p><p>下面是一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Thread blinker;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">    blinker = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thisThread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="keyword">while</span> (blinker == thisThread) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thisThread.sleep(interval);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        repaint();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线程中断">线程中断</h1><p>中断是给线程的一个指示，告诉它应该停止正在做的事并去做其他事情。一个线程究竟要怎么响应中断请求取决于程序员。一个线程通过调用对被中断线程的Thread对象的<code>interrupt()</code>方法，发送中断信号。为了让中断机制正常工作，被中断的线程必须支持它自己的中断（即要自己处理中断）。中断的相关方法有3个:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> Thread.interrupt()              <span class="comment">// 中断线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> Thread.isInterrupted()       <span class="comment">// 判断是否中断</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> Thread.interrupted()  <span class="comment">// 判断是否中断，并清除当前中断状态</span></span><br></pre></td></tr></table></figure><h2 id="Thread-interrupt"><code>Thread.interrupt()</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interrupt</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (<span class="built_in">this</span> != Thread.currentThread())</span><br><span class="line">             checkAccess();</span><br><span class="line">         <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">             <span class="type">Interruptible</span> <span class="variable">b</span> <span class="operator">=</span> blocker;</span><br><span class="line">             <span class="keyword">if</span> (b != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 此处的interrupt0 是native方法</span></span><br><span class="line">                 interrupt0();           <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">                 b.interrupt(<span class="built_in">this</span>);</span><br><span class="line">                 <span class="keyword">return</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         interrupt0();</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>中断本线程。无返回值。具体作用分以下几种情况：</p><ul><li>如果该线程正阻塞于Object类的<code>wait()</code>、<code>wait(long)</code>、<code>wait(long, int)</code>方法，或者Thread类的<code>join()</code>、join(long)、<code>join(long, int)</code>、<code>sleep(long)</code>、<code>sleep(long, int)</code>方法，则该线程的中断状态将被清除，并收到一个<code>java.lang.InterruptedException</code>。</li><li>如果该线程正阻塞于interruptible channel上的I/O操作，则该通道将被关闭，同时该线程的中断状态被设置，并收到一个<code>java.nio.channels.ClosedByInterruptException</code>。<br>如果该线程正阻塞于一个<code>java.nio.channels.Selector</code>操作，则该线程的中断状态被设置，它将立即从选择操作返回，并可能带有一个非零值，就好像调用<code>java.nio.channels.Selector.wakeup()</code>方法一样。</li><li>如果上述条件都不成立，则该线程的中断状态将被设置。中断一个不处于活动状态的线程不会有任何作用。如果是其他线程在中断该线程，则<code>java.lang.Thread.checkAccess()</code>方法就会被调用，这可能抛出<code>java.lang.SecurityException</code>。</li></ul><h2 id="Thread-isInterrupted"><code>Thread.isInterrupted</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">interrupted</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> currentThread().isInterrupted(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检测当前线程是否已经中断，是则返回true，否则false，并清除中断状态。换言之，如果该方法被连续调用两次，第二次必将返回false，除非在第一次与第二次的瞬间线程再次被中断。如果中断调用时线程已经不处于活动状态，则返回false。</p><h2 id="Thread-interrupted"><code>Thread.interrupted()</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> isInterrupted(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检测当前线程是否已经中断，是则返回true，否则false。中断状态不受该方法的影响。如果中断调用时线程已经不处于活动状态，则返回false。</p><blockquote><p>interrupted()与isInterrupted()的唯一区别是，前者会读取并清除中断状态，后者仅读取状态。<br>在hotspot源码中，两者均通过调用的native方法isInterrupted(boolean)来实现，区别是参数值ClearInterrupted不同。<br><code>private native boolean isInterrupted(boolean ClearInterrupted);</code></p></blockquote><h2 id="使用中断">使用中断</h2><p>注意，<code>Thread.interrupt()</code>方法只是修改了当前线程的中断状态，为使中断生效，我们需要自己实现处理中断的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptThread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="comment">// 此处处理中断</span></span><br><span class="line">                    <span class="keyword">if</span>(Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;Thread is Interrupted!&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;  </span><br><span class="line">                        <span class="comment">// 如果while 下面还有代码，可以使用 return</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread is Running!&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                    Thread.<span class="keyword">yield</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;interrupt Thread!&quot;</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当线程阻塞于wait/join/sleep时，中断状态会被清除掉，同时收到InterruptedException。如果不加处理，下次循环开始时，就无法捕获这个中断。因此，在编写多线程代码的时候，任何时候捕获到InterruptedException，要么继续上抛，要么重置中断状态，这是最安全的做法。</p></blockquote><p>当某个方法抛出InterruptedException时，表示该方法是一个阻塞方法。当在代码中调用一个将抛出InterruptedException异常的方法时，你自己的方法也就变成了一个阻塞方法，并且必须要处理对中断的相应。对于库代码来说，有两种选择：</p><ol><li>传递InterruptedException。这是最明智的策略，将异常传递给方法的调用者。</li><li>恢复中断。在不能上抛的情况下，如Runnable方法，必须捕获InterruptedException，并通过当前线程的interrupt()方法恢复中断状态，这样在调用栈中更高层的代码将看到引发了一个中断。如下:</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 1.调用阻塞方法</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// important</span></span><br><span class="line">            Thread.currentThread().interrupt();    <span class="comment">// 2.恢复被中断的状态</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="wait-notify">wait &amp; notify</h1><p>JDK在<code>java.lang.Object</code>中提供了两个接口<code>wait()</code>和<code>notify()</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>如果一个线程调用了<code>object.wait()</code>，它就会进入object对象的等待队列。当<code>object.notify()</code> 被调用时，会从等待队列中随机选择一个线程，将其唤醒。注意，这里的选择是不公平的，完全随机。除了<code>notify()</code>方法外，<code>notifyAll()</code>会唤醒等待队列中所有的等待线程。</p><p>注意，<code>wait()</code>和<code>notify()/notifyAll()</code>必须在synchronized同步代码块中使用。</p><h2 id="执行过程">执行过程</h2><ol><li>当线程T1执行<code>wait()</code>时，会把当前的锁S1释放，然后让出CPU，进入等待状态。</li><li>当获得锁的线程T2执行<code>notify/notifyAll</code>s方法时，会唤醒一个处于等待该对象锁状态的的线程T1，然后继续往下执行，直到执行完退出对象锁锁住的区域（synchronized修饰的代码块）后再释放锁。</li><li>T1被唤醒后，会尝试获得锁S1，当顺利获得锁S1后，才能真正继续执行下去。</li></ol><blockquote><p>从这里可以看出，notify/notifyAll()执行后，并不立即释放锁，而是要等到执行完临界区中代码后，再释放。<br>在实际编程中，我们应该尽量在线程调用notify/notifyAll()后，立即退出临界区。即不要在notify/notifyAll()后面再写一些耗时的代码。</p></blockquote><h2 id="Demo">Demo</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">waitandnotify</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span>  <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(System.currentTimeMillis()+ <span class="string">&quot;-&gt; T1 start() &quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                System.out.println(System.currentTimeMillis()+ <span class="string">&quot;-&gt; T1 begin wait() &quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(System.currentTimeMillis()+ <span class="string">&quot;-&gt; T1 end wait() &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(System.currentTimeMillis()+ <span class="string">&quot;-&gt; T2 start() &quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                System.out.println(System.currentTimeMillis()+ <span class="string">&quot;-&gt; T2 begin notify() &quot;</span>);</span><br><span class="line">                lock.notify();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(System.currentTimeMillis()+ <span class="string">&quot;-&gt; T2 end notify() &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">waitandnotify</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">waitandnotify</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> client.<span class="keyword">new</span> <span class="title class_">T1</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> client.<span class="keyword">new</span> <span class="title class_">T2</span>();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*1502699128356-&gt; T1 start() </span></span><br><span class="line"><span class="comment"> *1502699128356-&gt; T1 begin wait() </span></span><br><span class="line"><span class="comment"> *1502699128356-&gt; T2 start() </span></span><br><span class="line"><span class="comment"> *1502699128356-&gt; T2 begin notify() </span></span><br><span class="line"><span class="comment"> *1502699133357-&gt; T2 end notify() </span></span><br><span class="line"><span class="comment"> *1502699133357-&gt; T1 end wait() </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>显然，从时间戳可以看出T2通知T1继续执行后，T1并不能继续执行，而是等待T2释放object的锁，并重新获得锁后才继续执行。</p><blockquote><p><code>Object.wait()</code>和<code>Thread.sleep()</code>都可以让线程等待若干分钟。除了wait方法可以被唤醒之外，另一个主要区别是wait方法会释放目标对象的锁，而sleep方法不会释放资源。当然，<code>Object.wait()</code>只是把当前线程占用的目标对象的锁释放，其他占用的对象的锁状态不会发生变化。</p></blockquote><h1 id="suspend-resume">suspend &amp; resume</h1><h2 id="简单使用">简单使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">suspend_resume</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ChangeThread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="keyword">private</span>  <span class="type">int</span> i= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    System.out.println(System.currentTimeMillis() + <span class="string">&quot;-&gt; Thread ::&quot;</span> + ++i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChangeThread1</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChangeThread1</span>();</span><br><span class="line">        thread1.start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        System.out.println(System.currentTimeMillis()+<span class="string">&quot;------begin-----suspend &quot;</span>);</span><br><span class="line">        thread1.suspend();</span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        thread1.resume();</span><br><span class="line">        System.out.println(System.currentTimeMillis()+<span class="string">&quot;-------end-----resume &quot;</span>);</span><br><span class="line">        thread1.suspend();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1502791453031-&gt; Thread ::11696</span><br><span class="line">1502791453031-&gt; Thread ::11697</span><br><span class="line">1502791453031-&gt; Thread ::11698</span><br><span class="line">1502791453031-&gt; Thread ::11699</span><br><span class="line">1502791453031-&gt; Thread ::11700</span><br><span class="line">1502791453031------begin-----suspend </span><br><span class="line">1502791453031-&gt; Thread ::11701</span><br><span class="line">1502791453031-&gt; Thread ::11702</span><br><span class="line">1502791453031-&gt; Thread ::11703</span><br><span class="line">1502791453031-&gt; Thread ::11704</span><br><span class="line">1502791453031-&gt; Thread ::11705</span><br><span class="line">1502791453042-&gt; Thread ::11706 // 此处可从时间戳看出暂停了10 millis</span><br><span class="line">1502791453042-------end-----resume </span><br></pre></td></tr></table></figure><h2 id="注意事项">注意事项</h2><p>suspend和resume这对API已经被标注为弃用。不推荐使用suspend去挂起线程是因为suspend方法在导致线程暂停的同时，并不会释放任何资源。其他线程无妨访问被占用的锁，直到对应的线程进行了resume操作，被挂起的线程才能继续。其他阻塞在相关锁的线程也可以继续执行。</p><p>但是如果<code>resume()</code>操作意外地在<code>suspend()</code>方法前执行，那么被挂起的线程很难继续被执行，更严重的情况是，挂起线程如果占据锁，那么这个锁将一直得不到释放，从而导致整个系统不正常工作。下面就是一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">suspend_resume_dead_lock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ChangeObjectThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ChangeObjectThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(System.currentTimeMillis()+<span class="string">&quot; -&gt; &quot;</span>+<span class="built_in">this</span>.getName()+<span class="string">&quot;======= begin ======&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                System.out.println(System.currentTimeMillis()+<span class="string">&quot; -&gt; &quot;</span>+<span class="built_in">this</span>.getName()+<span class="string">&quot;+++++++ enter lock ++++++&quot;</span>);</span><br><span class="line">                Thread.currentThread().suspend();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ChangeObjectThread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChangeObjectThread</span>(<span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        System.out.println(System.currentTimeMillis()+<span class="string">&quot; -&gt; ######### sleep 100 ##########&quot;</span>);</span><br><span class="line">        <span class="type">ChangeObjectThread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChangeObjectThread</span>(<span class="string">&quot;thread2&quot;</span>);</span><br><span class="line">        thread2.start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        System.out.println(System.currentTimeMillis()+<span class="string">&quot; -&gt; ######### sleep 100 ##########&quot;</span>);</span><br><span class="line">        thread1.resume();</span><br><span class="line">        thread2.resume();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** output:</span></span><br><span class="line"><span class="comment"> * 1504072559572 -&gt; thread1======= begin ======</span></span><br><span class="line"><span class="comment"> * 1504072559573 -&gt; thread1+++++++ enter lock ++++++</span></span><br><span class="line"><span class="comment"> * 1504072559672 -&gt; ######### sleep 100 ##########</span></span><br><span class="line"><span class="comment"> * 1504072559672 -&gt; thread2======= begin ======</span></span><br><span class="line"><span class="comment"> * 1504072559772 -&gt; ######### sleep 100 ##########</span></span><br><span class="line"><span class="comment"> * 1504072559772 -&gt; thread2+++++++ enter lock ++++++</span></span><br><span class="line"><span class="comment"> * 此时没有退出！！！</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>由输出的时间戳可以发现thread1调用<code>suspend()</code>后一直占据锁，直到执行<code>resume()</code>后释放占用的锁。__值得注意的是，<code>thread2.resume()</code>并没有生效，程序最后并没有退出。__下面是对于没有正常退出的分析：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 java pid</span></span><br><span class="line">$ jps</span><br><span class="line">8256 suspend_resume_dead_lock</span><br><span class="line"><span class="comment"># 查看线程信息</span></span><br><span class="line">$ jstack 8256</span><br><span class="line"><span class="string">&quot;thread2&quot;</span> <span class="comment">#13 prio=5 os_prio=0 tid=0x000000001a4a0800 nid=0x5278 runnable [0x000000001c14e000]</span></span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">        at java.lang.Thread.suspend0(Native Method)</span><br><span class="line">        at java.lang.Thread.<span class="built_in">suspend</span>(Thread.java:1032)</span><br><span class="line">        at suspend_resume_dead_lock<span class="variable">$ChangeObjectThread</span>.run(suspend_resume_dead_lock.java:18)</span><br><span class="line">        - locked &lt;0x00000000d609c8b8&gt; (a java.lang.Object)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>线程信息中thread2的状态是<code>java.lang.Thread.State: RUNNABLE</code>，这是因为时间先后顺序的问题，主线程中的<code>thread2.resume()</code>并未生效，从而导致thread2一直挂起，并占用锁。<strong>危险！！！</strong></p><h1 id="join">join</h1><p>在存在多线程的应用中，考虑下面这种情况：一个线程的输入，依赖于其他线程的执行完成才能继续执行。</p><p>JDK提供了<code>join()</code>方法来实现这一操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        join(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure><p>第一个无参join方法表示无限等待，会一直阻塞当前线程，直到目标线程对象执行完毕。第二个和第三个方法给出了最大等待时间，如果超过最大时间，目标线程还在执行，当前线程会停止等待继续执行。下面是一个使用例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleJoinDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IncreaseCountThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;<span class="number">1000000000</span>;i++)&#123;</span><br><span class="line">                count ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">increaseCountThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IncreaseCountThread</span>();</span><br><span class="line">        increaseCountThread.start();</span><br><span class="line">        increaseCountThread.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;field count is: &quot;</span>+String.valueOf(count));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * field count is: 1000000000</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><code>join()</code>方法的本质是让调用线程(当前执行线程)wait在被调用线程实例上。join的核心代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                wait(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> millis - now;</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(delay);</span><br><span class="line">                now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到join方法的底层实现是wait()方法，当线程执行完后，会在结束前调用<code>notifyAll()</code>通知所有的等待线程继续。<strong>因此,值得注意的是，不要在Thread对象实例中使用<code>wait()</code>或<code>notify()|notifyAll()</code>方法。这可能会影响系统API。</strong></p><h1 id="yield">yield</h1><p>yield是一个静态的本地方法，作用是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。所以有可能刚刚让出cpu资源，又竞争成功重新获取cpu资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">yield</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><h1 id="onSpinWait">onSpinWait</h1><blockquote><p>该方法 JDK9 引入</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;exit&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">3000L</span>);</span><br><span class="line">        temp = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般情况下，我们让线程等待一段时间都是使用Thread.sleep()命令。如果我们想要停顿的时间足够短，取一个极端情况，等待时间为0。那么每次都会停顿 0 毫秒，然后返回。</p><p>使用Thread.sleep(0)的目的是让当前线程主动放弃CPU的执行时间片，以便给其他具有相同优先级的线程执行的机会。虽然参数为0，但实际上并不是让线程休眠0毫秒，而是让线程进入就绪状态，等待重新获取CPU执行时间。</p><p>使用Thread.sleep(0)的主要意义在于提高多线程程序的公平性和响应性。当一个线程执行Thread.sleep(0)时，操作系统会重新调度其他就绪状态的线程，这样可以避免某个线程长时间占用CPU而导致其他线程无法得到执行的情况，从而提高了程序的公平性。但是会比空实现增加部分耗时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IntrinsicCandidate</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">onSpinWait</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>onSpinWait()方法是空实现，被@IntrinsicCandidate修饰，在JDK中，被@IntrinsicCandidate修饰的方法作为内部候选方法（intrinsic candidate）。内部候选方法是指可以由编译器或虚拟机进行特殊处理的方法，以提供更高效的执行方式或更好的性能。</p><p>那么 JDK 做了什么优化？</p><p>参考 JVM 的源码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/openjdk/jdk/blob/master/src/hotspot/cpu/x86/x86.ad</span></span><br><span class="line"><span class="function">instruct <span class="title">onspinwait</span><span class="params">()</span> %</span>&#123;</span><br><span class="line">  <span class="built_in">match</span>(OnSpinWait);</span><br><span class="line">  <span class="built_in">ins_cost</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">  format %&#123;</span><br><span class="line">    $$<span class="keyword">template</span></span><br><span class="line">    $$emit$$<span class="string">&quot;pause\t! membar_onspinwait&quot;</span></span><br><span class="line">  %&#125;</span><br><span class="line">  ins_encode %&#123;</span><br><span class="line">    <span class="function">__ <span class="title">pause</span><span class="params">()</span></span>;</span><br><span class="line">  %&#125;</span><br><span class="line">  <span class="built_in">ins_pipe</span>(pipe_slow);</span><br><span class="line">%&#125;</span><br><span class="line"><span class="comment">// https://github.com/openjdk/jdk/blob/master/src/hotspot/cpu/riscv/riscv.ad</span></span><br><span class="line"><span class="function">instruct <span class="title">spin_wait</span><span class="params">()</span> %</span>&#123;</span><br><span class="line">  <span class="built_in">predicate</span>(UseZihintpause);</span><br><span class="line">  <span class="built_in">match</span>(OnSpinWait);</span><br><span class="line">  <span class="built_in">ins_cost</span>(CACHE_MISS_COST);</span><br><span class="line"></span><br><span class="line">  format %&#123; <span class="string">&quot;spin_wait&quot;</span> %&#125;</span><br><span class="line"></span><br><span class="line">  ins_encode %&#123;</span><br><span class="line">    <span class="function">__ <span class="title">pause</span><span class="params">()</span></span>;</span><br><span class="line">  %&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ins_pipe</span>(pipe_serial);</span><br><span class="line">%&#125;</span><br></pre></td></tr></table></figure><p>x86 的机器，在 x86 的环境下 Thread.onSpinWait() 在被调用一定次数后，C1 编译器就会将其替换成使用 <a target="_blank" rel="noopener" href="https://www.felixcloutier.com/x86/pause">PAUSE</a> 这个 x86 指令实现（同样 riscv 也是改写为自己的 PAUSE 指令）。</p><p>PAUSE 指令是针对这种自旋等待策略实现而产生的一个特殊指令，它会告诉处理器所执行的代码序列是一个不断检查某个状态位是否就绪的代码（即 spin-wait loop），这样的话，然后 CPU 分支预测就会据这个提示而避开内存序列冲突，CPU 就不会将这块读取的内存进行缓存，也就是说对 spin-wait loop 不做缓存，不做指令<br>重新排序等动作。从而提高 spin-wait loop 的执行效率。</p><h1 id="线程的生命周期">线程的生命周期</h1><p>Java 在枚举类<code>Thread.State</code>中定义了线程的几种状态：</p><ul><li>NEW<br>新建状态：线程刚刚创建，尚未启动。</li><li>RUNNABLE<br>就绪状态：线程可执行，等待获取CPU使用权。</li><li>BLOCKED<br>阻塞状态：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。</li><li>WAITING<br>等待状态：运行的线程执行<code>wait()</code>,<code>join()</code>或<code>LockSupport.park()</code>方法，JVM会把该线程放入等待池中。当前线程在等待另一线程的特定动作。</li><li>TIMED_WAITING<br>限时等待状态：运行的线程执行带时间参数<code>wait()</code>,带时间参数<code>join()</code>,<code>sleep()</code>,<code>LockSupport.parkNanos()</code>或<code>LockSupport.parkUntil()</code>方法，JVM会把该线程放入等待池中。当前线程在等待另一线程的特定动作。</li><li>TERMINATED<br>死亡状态：线程执行完成或者因异常退出，结束生命周期。</li></ul><figure><img data-src="/posts/8c8208eb/thread.webp" alt="java线程状态迁移图"></figure><h1 id="线程管理：线程组">线程管理：线程组</h1><p>在系统中如果线程数量很多，而且功能分配比较明确，就可以把相同功能的线程放置在一个线程组里。可以把线程归属到某一个线程组中，线程组中可以有线程对象，也可以有线程组，组中还可以有线程，这样的组织结构有点类似于树的形式。线程组的作用是：<em><strong>可以批量管理线程或线程组对象，有效地对线程或线程组对象进行组织</strong></em>。</p><h2 id="一级关联-ThreadGroup-Thread">一级关联(ThreadGroup -&gt; Thread)</h2><p>Thread 对象通过构造器初始化时传入ThreadGroup对象，实现与ThreadGroup对象的关联。Thread 对象通过方法<code>getThreadGroup()</code>可以获得所属线程组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(ThreadGroup group, String name)</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(ThreadGroup group, Runnable target)</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(ThreadGroup group, Runnable target, String name)</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(ThreadGroup group, Runnable target, String name,<span class="type">long</span> stackSize)</span>&#123;...&#125;</span><br></pre></td></tr></table></figure><h2 id="批量中断组内线程">批量中断组内线程</h2><p>ThreadGroup 对象通过<code>ThreadGroup.interrupt()</code>方法批量中断组内线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadGroup2ThreadDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span>  <span class="title class_">myThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (!Thread.currentThread().isInterrupted())</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(</span><br><span class="line">                            <span class="string">&quot;Group: &quot;</span> + Thread.currentThread().getThreadGroup().getName()+</span><br><span class="line">                            <span class="string">&quot; &gt;&gt; Thread: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                    Thread.sleep(<span class="number">300</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ThreadGroup</span> <span class="variable">threadGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadGroup</span>(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(threadGroup,<span class="keyword">new</span> <span class="title class_">myThread</span>());</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(threadGroup,<span class="keyword">new</span> <span class="title class_">myThread</span>());</span><br><span class="line">        <span class="comment">// 线程启动(start)后才会加入线程组</span></span><br><span class="line">        System.out.println(<span class="string">&quot;线程组中活动线程数量&quot;</span>+threadGroup.activeCount());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;线程组中活动线程数量&quot;</span>+threadGroup.activeCount());</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        threadGroup.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>output:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">线程组中活动线程数量0</span><br><span class="line">Group: group1 &gt;&gt; Thread: Thread-0</span><br><span class="line">Group: group1 &gt;&gt; Thread: Thread-1</span><br><span class="line">线程组中活动线程数量2</span><br><span class="line">Group: group1 &gt;&gt; Thread: Thread-0</span><br><span class="line">Group: group1 &gt;&gt; Thread: Thread-1</span><br><span class="line">Group: group1 &gt;&gt; Thread: Thread-0</span><br><span class="line">Group: group1 &gt;&gt; Thread: Thread-1</span><br><span class="line">Group: group1 &gt;&gt; Thread: Thread-0</span><br><span class="line">Group: group1 &gt;&gt; Thread: Thread-1</span><br><span class="line">Group: group1 &gt;&gt; Thread: Thread-0</span><br><span class="line">Group: group1 &gt;&gt; Thread: Thread-1</span><br><span class="line">Group: group1 &gt;&gt; Thread: Thread-0</span><br><span class="line">Group: group1 &gt;&gt; Thread: Thread-1</span><br><span class="line">Group: group1 &gt;&gt; Thread: Thread-0</span><br><span class="line">Group: group1 &gt;&gt; Thread: Thread-1</span><br><span class="line">Group: group1 &gt;&gt; Thread: Thread-0</span><br><span class="line">Group: group1 &gt;&gt; Thread: Thread-1</span><br><span class="line">Group: group1 &gt;&gt; Thread: Thread-0</span><br><span class="line">Group: group1 &gt;&gt; Thread: Thread-1</span><br><span class="line">Group: group1 &gt;&gt; Thread: Thread-0</span><br><span class="line">Group: group1 &gt;&gt; Thread: Thread-1</span><br><span class="line">Group: group1 &gt;&gt; Thread: Thread-0</span><br><span class="line">Group: group1 &gt;&gt; Thread: Thread-1</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at cn.victor.test.ThreadGroup2ThreadDemo$myThread.run(ThreadGroup2ThreadDemo.java:14)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at cn.victor.test.ThreadGroup2ThreadDemo$myThread.run(ThreadGroup2ThreadDemo.java:14)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h2 id="多级关联">多级关联</h2><p>ThreadGroup 对象之间的关联关系也是通过构造器建立。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadGroup</span><span class="params">(ThreadGroup parent, String name)</span>&#123;...&#125;</span><br></pre></td></tr></table></figure><ul><li><p>ThreadGroup 对象通过方法<code>getParent()</code>可以获得父线程组。</p></li><li><p>父级线程组的中断方法会调用子级线程组的中断方法。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">interrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> ngroupsSnapshot;</span><br><span class="line">    ThreadGroup[] groupsSnapshot;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        checkAccess();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; nthreads ; i++) &#123;</span><br><span class="line">            threads[i].interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        ngroupsSnapshot = ngroups;</span><br><span class="line">        <span class="keyword">if</span> (groups != <span class="literal">null</span>) &#123;</span><br><span class="line">            groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            groupsSnapshot = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; ngroupsSnapshot ; i++) &#123;</span><br><span class="line">        groupsSnapshot[i].interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程组的递归处理">线程组的递归处理</h2><h3 id="list"><code>list()</code></h3><blockquote><p>Prints information about this thread group to the standard output. This method is useful only for debugging.</p></blockquote><p>上面是官方文档的说明，list方法用于向标准输出输出线程组的信息，这个方法仅用于debug。从源码中，可以看出list方法会递归输出多级关联的所有信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">    list(System.out, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> More <span class="title function_">list</span><span class="params">(PrintStream out, <span class="type">int</span> indent)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ngroupsSnapshot;</span><br><span class="line">    ThreadGroup[] groupsSnapshot;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; indent ; j++) &#123;</span><br><span class="line">            out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        out.println(<span class="built_in">this</span>);</span><br><span class="line">        indent += <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; nthreads ; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; indent ; j++) &#123;</span><br><span class="line">                out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            out.println(threads[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        ngroupsSnapshot = ngroups;</span><br><span class="line">        <span class="keyword">if</span> (groups != <span class="literal">null</span>) &#123;</span><br><span class="line">            groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            groupsSnapshot = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此处递归</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; ngroupsSnapshot ; i++) &#123;</span><br><span class="line">        groupsSnapshot[i].list(out, indent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="enumerate"><code>enumerate()</code></h3><p>enumerate方法的作用是枚举线程组的内容，把内容放入对应的容器中。enumerate 既可以枚举当前线程组的线程也可以枚举当前线程组的子线程组。<code>enumerate()</code>的递归与非递归控制是通过boolean值控制的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">enumerate</span><span class="params">(ThreadGroup list[], <span class="type">boolean</span> recurse)</span> &#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">enumerate</span><span class="params">(Thread list[], <span class="type">boolean</span> recurse)</span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>显然从源码中可以看出，当传参为true时，会进行递归操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">enumerate</span><span class="params">(Thread list[], <span class="type">int</span> n, <span class="type">boolean</span> recurse)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ngroupsSnapshot</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    ThreadGroup[] groupsSnapshot = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (destroyed) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nt</span> <span class="operator">=</span> nthreads;</span><br><span class="line">        <span class="keyword">if</span> (nt &gt; list.length - n) &#123;</span><br><span class="line">            nt = list.length - n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nt; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (threads[i].isAlive()) &#123;</span><br><span class="line">                list[n++] = threads[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (recurse) &#123;</span><br><span class="line">            ngroupsSnapshot = ngroups;</span><br><span class="line">            <span class="keyword">if</span> (groups != <span class="literal">null</span>) &#123;</span><br><span class="line">                groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                groupsSnapshot = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (recurse) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; ngroupsSnapshot ; i++) &#123;</span><br><span class="line">            n = groupsSnapshot[i].enumerate(list, n, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例子">例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadGroup2GroupDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span>  <span class="title class_">myThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (!Thread.currentThread().isInterrupted())</span><br><span class="line">                &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">300</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">/** 构建线程组结构</span></span><br><span class="line"><span class="comment">         *   head -&gt; parentGroup -&gt; p-A</span></span><br><span class="line"><span class="comment">         *                       -&gt; p-B</span></span><br><span class="line"><span class="comment">         *                       -&gt; childGroup -&gt; c-a</span></span><br><span class="line"><span class="comment">         *                                     -&gt; c-b</span></span><br><span class="line"><span class="comment">         *                                     -&gt; childChildGroup -&gt; cc-a</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ThreadGroup</span> <span class="variable">parentGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadGroup</span>(<span class="string">&quot;parentGroup&quot;</span>);</span><br><span class="line">        <span class="type">ThreadGroup</span> <span class="variable">childGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadGroup</span>(parentGroup,<span class="string">&quot;childGroup&quot;</span>);</span><br><span class="line">        <span class="type">ThreadGroup</span> <span class="variable">childChildGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadGroup</span>(childGroup,<span class="string">&quot;childChildGroup&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">pThreadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(parentGroup,<span class="keyword">new</span> <span class="title class_">myThread</span>(),<span class="string">&quot;p-A&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">pThreadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(parentGroup,<span class="keyword">new</span> <span class="title class_">myThread</span>(),<span class="string">&quot;p-B&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">cThreada</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(childGroup,<span class="keyword">new</span> <span class="title class_">myThread</span>(),<span class="string">&quot;c-a&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">cThreadb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(childGroup,<span class="keyword">new</span> <span class="title class_">myThread</span>(),<span class="string">&quot;c-b&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">ccThreada</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(childChildGroup,<span class="keyword">new</span> <span class="title class_">myThread</span>(),<span class="string">&quot;cc-a&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        pThreadA.start();</span><br><span class="line">        pThreadB.start();</span><br><span class="line">        cThreada.start();</span><br><span class="line">        cThreadb.start();</span><br><span class="line">        ccThreada.start();</span><br><span class="line"></span><br><span class="line">        parentGroup.list();</span><br><span class="line"></span><br><span class="line">        ThreadGroup[] list1 = <span class="keyword">new</span> <span class="title class_">ThreadGroup</span>[parentGroup.activeGroupCount()];</span><br><span class="line">        System.out.println(<span class="string">&quot;递归获取线程组&quot;</span>);</span><br><span class="line">        parentGroup.enumerate(list1,<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;list1.length;i++)&#123;</span><br><span class="line">            System.out.println(list1[i].getName());</span><br><span class="line">        &#125;</span><br><span class="line">        ThreadGroup[] list2 = <span class="keyword">new</span> <span class="title class_">ThreadGroup</span>[parentGroup.activeGroupCount()];</span><br><span class="line">        System.out.println(<span class="string">&quot;非递归获取线程组&quot;</span>);</span><br><span class="line">        parentGroup.enumerate(list2,<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;list2.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list2[i]!=<span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(list2[i].getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread[] list3 = <span class="keyword">new</span> <span class="title class_">Thread</span>[parentGroup.activeCount()];</span><br><span class="line">        System.out.println(<span class="string">&quot;递归获取线程&quot;</span>);</span><br><span class="line">        parentGroup.enumerate(list3,<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;list3.length;i++)&#123;</span><br><span class="line">            System.out.println(list3[i].getName());</span><br><span class="line">        &#125;</span><br><span class="line">        Thread[] list4 = <span class="keyword">new</span> <span class="title class_">Thread</span>[parentGroup.activeCount()];</span><br><span class="line">        System.out.println(<span class="string">&quot;非递归获取线程&quot;</span>);</span><br><span class="line">        parentGroup.enumerate(list4,<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;list4.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list4[i]!=<span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(list4[i].getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 中断所有线程</span></span><br><span class="line">        parentGroup.interrupt();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>output:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ThreadGroup[name=parentGroup,maxpri=10]</span><br><span class="line">    Thread[p-A,5,parentGroup]</span><br><span class="line">    Thread[p-B,5,parentGroup]</span><br><span class="line">    java.lang.ThreadGroup[name=childGroup,maxpri=10]</span><br><span class="line">        Thread[c-a,5,childGroup]</span><br><span class="line">        Thread[c-b,5,childGroup]</span><br><span class="line">        java.lang.ThreadGroup[name=childChildGroup,maxpri=10]</span><br><span class="line">            Thread[cc-a,5,childChildGroup]</span><br><span class="line">递归获取线程组</span><br><span class="line">childGroup</span><br><span class="line">childChildGroup</span><br><span class="line">非递归获取线程组</span><br><span class="line">childGroup</span><br><span class="line">递归获取线程</span><br><span class="line">p-A</span><br><span class="line">p-B</span><br><span class="line">c-a</span><br><span class="line">c-b</span><br><span class="line">cc-a</span><br><span class="line">非递归获取线程</span><br><span class="line">p-A</span><br><span class="line">p-B</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at cn.victor.test.ThreadGroup2GroupDemo$myThread.run(ThreadGroup2GroupDemo.java:11)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at cn.victor.test.ThreadGroup2GroupDemo$myThread.run(ThreadGroup2GroupDemo.java:11)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at cn.victor.test.ThreadGroup2GroupDemo$myThread.run(ThreadGroup2GroupDemo.java:11)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at cn.victor.test.ThreadGroup2GroupDemo$myThread.run(ThreadGroup2GroupDemo.java:11)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at cn.victor.test.ThreadGroup2GroupDemo$myThread.run(ThreadGroup2GroupDemo.java:11)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h2 id="线程组自动归属">线程组自动归属</h2><p>自动归属是指对于初始化时没有指定所属线程组的Thread和ThreadGroup对象，他们会被自动归属到当前线程所属的线程组中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// openJdk 1.8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//　ThreadGroup 不指定线程组的初始化方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadGroup</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(Thread.currentThread().getThreadGroup(), name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread init 初始化方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span><br><span class="line"><span class="params">                       <span class="type">long</span> stackSize, AccessControlContext acc)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">parent</span> <span class="operator">=</span> currentThread();</span><br><span class="line">    <span class="type">SecurityManager</span> <span class="variable">security</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (g == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">/* Determine if it&#x27;s an applet or not */</span></span><br><span class="line">        <span class="comment">/* If there is a security manager, ask the security manager what to do. */</span></span><br><span class="line">        <span class="keyword">if</span> (security != <span class="literal">null</span>) &#123;</span><br><span class="line">            g = security.getThreadGroup();</span><br><span class="line">            <span class="comment">/** </span></span><br><span class="line"><span class="comment">             * // In Class SecurityManager</span></span><br><span class="line"><span class="comment">             * public ThreadGroup getThreadGroup() &#123;</span></span><br><span class="line"><span class="comment">             * return Thread.currentThread().getThreadGroup();</span></span><br><span class="line"><span class="comment">             * &#125;</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* If the security doesn&#x27;t have a strong opinion of the matter use the parent thread group. */</span></span><br><span class="line">        <span class="keyword">if</span> (g == <span class="literal">null</span>) &#123;</span><br><span class="line">            g = parent.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="根线程组">根线程组</h2><p>根线程组就是系统线程组system，根线程组上没有父线程组。查看OpenJdk的ThreadGroup源码，可以发现下面这段代码。这是用于C代码调用，来生成系统线程组的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an empty Thread group that is not in any Thread group.</span></span><br><span class="line"><span class="comment"> * This method is used to create the system Thread group.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">ThreadGroup</span><span class="params">()</span> &#123;     <span class="comment">// called from C code</span></span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;system&quot;</span>;</span><br><span class="line">    <span class="built_in">this</span>.maxPriority = Thread.MAX_PRIORITY;</span><br><span class="line">    <span class="built_in">this</span>.parent = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="未捕获异常的统一处理">未捕获异常的统一处理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// openJdk 1.8 source code</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;  </span><br><span class="line">        parent.uncaughtException(t, e);<span class="comment">//父线程组不为空，设置到父线程组  </span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        Thread.<span class="type">UncaughtExceptionHandler</span> <span class="variable">ueh</span> <span class="operator">=</span>   </span><br><span class="line">        Thread.getDefaultUncaughtExceptionHandler();  </span><br><span class="line">        <span class="keyword">if</span> (ueh != <span class="literal">null</span>) &#123; </span><br><span class="line">            <span class="comment">// 默认异常处理器</span></span><br><span class="line">            ueh.uncaughtException(t, e);  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(e <span class="keyword">instanceof</span> ThreadDeath)) &#123;  </span><br><span class="line">            System.err.print(<span class="string">&quot;Exception in thread \&quot;&quot;</span> + t.getName() + <span class="string">&quot;\&quot; &quot;</span>);  </span><br><span class="line">            e.printStackTrace(System.err);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><ul><li>如果当前线程组有父线程组，调用父线程组的<code>uncaughtException</code>方法。</li><li>如果父线程组不存在，但是有默认异常处理器，调用异常处理器的<code>uncaughtException</code>方法。</li><li>如果没有指定异常处理器，输出异常日志。注意，如果异常是<code>ThreadDeath</code>，忽略该异常。</li></ul><p>可以在子类中覆盖ThreadGroup的<code>uncaughtException</code>方法来统一处理线程组异常。</p><h2 id="线程优先级">线程优先级</h2><p>现代操作系统一般是分时操作系统，即一台计算机采用时间片轮转的方式同时为若干用户提供服务。线程分配得到的时间片的多少决定了线程使用处理器资源的多少，也对应了线程优先级这个概念。JAVA线程中使用一个int 值priority来控制优先级，范围为1-10,其中10的优先级最高，1的优先级最低。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最小优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MIN_PRIORITY</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 默认优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NORM_PRIORITY</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 最大优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAX_PRIORITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// native method</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">setPriority0</span><span class="params">(<span class="type">int</span> newPriority)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// API</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setPriority</span><span class="params">(<span class="type">int</span> newPriority)</span> &#123;</span><br><span class="line">    ThreadGroup g;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="keyword">if</span> (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((g = getThreadGroup()) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 线程有限级不能比线程组优先级大</span></span><br><span class="line">        <span class="keyword">if</span> (newPriority &gt; g.getMaxPriority()) &#123;</span><br><span class="line">            newPriority = g.getMaxPriority();</span><br><span class="line">        &#125;</span><br><span class="line">        setPriority0(priority = newPriority);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程的优先级有继承性">线程的优先级有继承性</h3><p>在Java中，线程的优先级具有继承性，比如，A线程启动B线程，则B线程的优先级与A是一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPriority</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyThread priority is :&quot;</span>+ <span class="built_in">this</span>.getPriority());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main Thread priority is:&quot;</span>+ Thread.currentThread().getPriority());</span><br><span class="line">        Thread.currentThread().setPriority(<span class="number">8</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;After seted, main Thread priority is:&quot;</span>+ Thread.currentThread().getPriority());</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        myThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * main Thread priority is:5</span></span><br><span class="line"><span class="comment"> * After seted, main Thread priority is:8</span></span><br><span class="line"><span class="comment"> * MyThread priority is :8</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="优先级规则">优先级规则</h3><ol><li>CPU尽量把执行资源让给优先级高的线程，即优先级高的线程总是大部分会先执行，但是这不代笔高优先级的线程全部先执行完再执行低优先级的线程。</li><li>优先级具有随机性，优先级高的不一定每次都先执行。</li></ol><blockquote><p>线程优先级不能作为程序正确性的依赖，因为操作系统可以完全不用理会JAVA线程对于优先级的设定。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPriority</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> notStart=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> notEnd=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;Job&gt; jobs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">priority</span> <span class="operator">=</span> i&lt;<span class="number">5</span>?Thread.MIN_PRIORITY:Thread.MAX_PRIORITY;</span><br><span class="line">            Job job=<span class="keyword">new</span> <span class="title class_">Job</span>(priority);</span><br><span class="line">            jobs.add(job);</span><br><span class="line">            Thread thread=<span class="keyword">new</span> <span class="title class_">Thread</span>(job, <span class="string">&quot;Thread:&quot;</span>+i);</span><br><span class="line">            thread.setPriority(priority);</span><br><span class="line">            thread.start();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="comment">//使用这个循环启动了10个线程</span></span><br><span class="line"></span><br><span class="line">        notStart=<span class="literal">false</span>;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">10</span>);<span class="comment">//main线程沉睡10s，使得10个小线程执行结束</span></span><br><span class="line">        notEnd=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Job job:jobs)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;JOB priority:&quot;</span>+job.priority+<span class="string">&quot;,&quot;</span>+job.jobCount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Job</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> priority;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">long</span> jobCount;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Job</span><span class="params">(<span class="type">int</span> priority)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">this</span>.priority=priority;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(notStart)</span><br><span class="line">            &#123;</span><br><span class="line">                Thread.<span class="keyword">yield</span>();<span class="comment">//这里确保main线程将10个小线程启动成功</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(notEnd)</span><br><span class="line">            &#123;</span><br><span class="line">                Thread.<span class="keyword">yield</span>();<span class="comment">//这里让出CPU资源，使得10个线程自由竞争。</span></span><br><span class="line">                jobCount++;<span class="comment">//记录竞争状态，反映线程的优先级。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** ------ out put ------</span></span><br><span class="line"><span class="comment"> * // OS: Ubuntu</span></span><br><span class="line"><span class="comment"> * JOB priority:1,20002078</span></span><br><span class="line"><span class="comment"> * JOB priority:1,21466360</span></span><br><span class="line"><span class="comment"> * JOB priority:1,20064881</span></span><br><span class="line"><span class="comment"> * JOB priority:1,21806089</span></span><br><span class="line"><span class="comment"> * JOB priority:1,17341995</span></span><br><span class="line"><span class="comment"> * JOB priority:10,21941482</span></span><br><span class="line"><span class="comment"> * JOB priority:10,15592763</span></span><br><span class="line"><span class="comment"> * JOB priority:10,23662996</span></span><br><span class="line"><span class="comment"> * JOB priority:10,17024857</span></span><br><span class="line"><span class="comment"> * JOB priority:10,17770879</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>显然，根据输出我们可以发现Linux 操作系统并没有理会JAVA设置的优先级。</p><p>而在window系统上，我们可能得到这样的结果:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">JOB priority:<span class="number">1</span>,<span class="number">1099494</span></span><br><span class="line">JOB priority:<span class="number">1</span>,<span class="number">1097710</span></span><br><span class="line">JOB priority:<span class="number">1</span>,<span class="number">1099911</span></span><br><span class="line">JOB priority:<span class="number">1</span>,<span class="number">1100411</span></span><br><span class="line">JOB priority:<span class="number">1</span>,<span class="number">1099721</span></span><br><span class="line">JOB priority:<span class="number">10</span>,<span class="number">5208263</span></span><br><span class="line">JOB priority:<span class="number">10</span>,<span class="number">5198474</span></span><br><span class="line">JOB priority:<span class="number">10</span>,<span class="number">5213148</span></span><br><span class="line">JOB priority:<span class="number">10</span>,<span class="number">5184842</span></span><br><span class="line">JOB priority:<span class="number">10</span>,<span class="number">5172312</span></span><br></pre></td></tr></table></figure><p>这就符合了线程的优先级规则。</p><h2 id="daemon进程">daemon进程</h2><p>Java的线程有两种类型: 用户进程和守护进程。守护进程是一种特殊的线程，当进程中不存在非守护线程的时候，则守护进程自动销毁，典型的守护进程是垃圾回收进程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaemonTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;a thread alive&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        myThread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">        myThread.start();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果将　myThread.setDaemon(true)　放在start()方法后,</span></span><br><span class="line"><span class="comment">         * myThread 将被当做用户线程,程序会一直执行下去.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** ----- out put -----</span></span><br><span class="line"><span class="comment"> * a thread alive</span></span><br><span class="line"><span class="comment"> * a thread alive</span></span><br><span class="line"><span class="comment"> * a thread alive</span></span><br><span class="line"><span class="comment"> * a thread alive</span></span><br><span class="line"><span class="comment"> * a thread alive</span></span><br><span class="line"><span class="comment"> * Process finished with exit code 0</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="reward-container"><div>请我一杯咖啡吧！</div><button>赞赏</button><div class="post-reward"><div><img src="/images/weixinpay.webp" alt="Victor Chu 微信"> <span>微信</span></div><div><img src="/images/alpay.webp" alt="Victor Chu 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"><strong>本文作者： </strong>Victor Chu</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://www.victorchu.info/posts/8c8208eb/" title="Java并发之Thread">https://www.victorchu.info/posts/8c8208eb/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="followme"><span>欢迎关注我的其它发布渠道</span><div class="social-list"><div class="social-item"><a target="_blank" class="social-link" href="/atom.xml"><span class="icon"><i class="fa fa-rss"></i> </span><span class="label">RSS</span></a></div><div class="social-item"><a target="_blank" class="social-link" href="/images/wechat_channel.webp"><span class="icon"><i class="fab fa-weixin"></i> </span><span class="label">WeChat</span></a></div></div></div><div class="post-tags"><a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a> <a href="/tags/Concurrency/" rel="tag"><i class="fa fa-tag"></i> Concurrency</a></div><div class="social-like a2a_kit a2a_kit_size_32 a2a_default_style"><a class="a2a_dd" target="_blank" rel="noopener" href="https://www.addtoany.com/share"></a> <a class="a2a_button_facebook"></a> <a class="a2a_button_twitter"></a> <a class="a2a_button_wechat"></a> <a class="a2a_button_pocket"></a> <a class="a2a_button_instapaper"></a> <a class="a2a_button_pinboard"></a> <a class="a2a_button_kindle_it"></a> <a class="a2a_button_copy_link"></a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/d51dc677/" rel="prev" title="Java，循环还是递归？"><i class="fa fa-angle-left"></i> Java，循环还是递归？</a></div><div class="post-nav-item"><a href="/posts/1f893078/" rel="next" title="IEEE 754 标准">IEEE 754 标准 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">浙ICP备18037908号-1 </a><img src="/images/gongan_icon.webp" alt=""><a href="https://beian.mps.gov.cn/#/query/webSearch?code=33010902002043" rel="noopener" target="_blank">浙公网安备 33010902002043号</a></div><div class="copyright">&copy; 2016 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Victor Chu</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span title="站点总字数">1.9m</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">53:07</span></span></div><div class="powered-by">由<a href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" class="theme-link" rel="noopener" target="_blank"><img src="/images/upyun_logo.webp" width="50" style="display:inline"></a>提供CDN服务</div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/algoliasearch/4.23.3/algoliasearch-lite.umd.js" integrity="sha256-1QNshz86RqXe/qsCBldsUu13eAX6n/O98uubKQs87UI=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/instantsearch.js/4.67.0/instantsearch.production.min.js" integrity="sha256-TW7D3X/i/W+RUgEeDppEnFT2ixv5lzplKH0c58D92dY=" crossorigin="anonymous"></script><script src="/js/third-party/search/algolia-search.js"></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":"dark","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.9.0/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script><script src="/js/third-party/tags/mermaid.js"></script><script src="/js/third-party/fancybox.js"></script><script src="/js/third-party/pace.js"></script><script src="/js/third-party/addtoany.js"></script><script class="next-config" data-name="enableMath" type="application/json">false</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css" integrity="sha256-UF1fgpAiu3tPJN/uCqEUHNe7pnr+QR0SQDNfgglgtcM=" crossorigin="anonymous"><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"walineui.victorchu.info","cssUrl":"https://cdn.staticfile.org/waline/2.15.8/waline.css","commentCount":true,"pageview":true,"requiredMeta":["nick","mail"],"login":"force","libUrl":"https://cdn.staticfile.org/waline/2.15.8/waline.js","dark":"body.darkmode--activated","el":"#waline","comment":true,"path":"/posts/8c8208eb/"}</script><link rel="stylesheet" href="https://cdn.staticfile.org/waline/2.15.8/waline.css"><script>document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});</script><script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script><script>var options = {
  bottom: '64px',
  right: '32px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();</script><script defer src="/_vercel/insights/script.js"></script><script defer src="/_vercel/speed-insights//script.js"></script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script></body></html>