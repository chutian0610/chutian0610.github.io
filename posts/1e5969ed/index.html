<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"www.victorchu.info","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"style":null,"show_result":"mac"},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"waline","storage":false,"lazyload":false,"nav":null,"activeClass":"waline"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"algolia":{"appID":"X9UOD4FSUP","apiKey":"fa32db1f02073025c69da8ebad0a6aa6","indexName":"hexo-next-blog","hits":{"per_page":10}}}</script><script src="/js/config.js"></script><meta name="description" content="在JDK1.2之前，Java中的引用的定义很传统: 如果reference类型(栈中的引用类型)的数据中存储的数值代表另一块内存的起始地址，就称这块内存代表一个引用。在这种情况下，对象只有被引用和没有被引用两种状态。 我们希望有这样一类对象，当内存空间还足够时，保存在内存中；而如果内存空间在垃圾回收后还是紧张，则可以抛弃这些对象。 JDK1.2后，java对引用的概念进行了扩充，将引用分为强引用("><meta property="og:type" content="article"><meta property="og:title" content="Java引用"><meta property="og:url" content="https://www.victorchu.info/posts/1e5969ed/index.html"><meta property="og:site_name" content="代码之旅"><meta property="og:description" content="在JDK1.2之前，Java中的引用的定义很传统: 如果reference类型(栈中的引用类型)的数据中存储的数值代表另一块内存的起始地址，就称这块内存代表一个引用。在这种情况下，对象只有被引用和没有被引用两种状态。 我们希望有这样一类对象，当内存空间还足够时，保存在内存中；而如果内存空间在垃圾回收后还是紧张，则可以抛弃这些对象。 JDK1.2后，java对引用的概念进行了扩充，将引用分为强引用("><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.victorchu.info/posts/1e5969ed/java_reference.webp"><meta property="article:published_time" content="2017-05-05T06:15:08.000Z"><meta property="article:modified_time" content="2024-11-25T07:12:32.917Z"><meta property="article:author" content="Victor Chu"><meta property="article:tag" content="Reference"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.victorchu.info/posts/1e5969ed/java_reference.webp"><link rel="canonical" href="https://www.victorchu.info/posts/1e5969ed/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.victorchu.info/posts/1e5969ed/","path":"/posts/1e5969ed/","title":"Java引用"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Java引用 | 代码之旅</title><script src="/js/third-party/analytics/baidu-analytics.js"></script><script async src="https://hm.baidu.com/hm.js?277fc29fa80de77c97f4f62b69e94233"></script><link rel="dns-prefetch" href="walineui.victorchu.info"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="alternate" href="/atom.xml" title="代码之旅" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">代码之旅</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">I love Coding !</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">113</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">80</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">210</span></a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="algolia-stats"><hr></div><div class="algolia-hits"></div><div class="algolia-pagination"></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E7%9A%84%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.</span> <span class="nav-text">扩展的引用类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8"><span class="nav-number">1.1.</span> <span class="nav-text">强引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8"><span class="nav-number">1.2.</span> <span class="nav-text">软引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="nav-number">1.3.</span> <span class="nav-text">弱引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E5%BC%95%E7%94%A8"><span class="nav-number">1.4.</span> <span class="nav-text">虚引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reference%E4%B8%8EReferenceQueue"><span class="nav-number">1.5.</span> <span class="nav-text">Reference与ReferenceQueue</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#reference%E7%B1%BB"><span class="nav-number">1.5.1.</span> <span class="nav-text">reference类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reference%E4%B8%8EReferenceQueue%E4%B9%8B%E9%97%B4%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="nav-number">1.5.2.</span> <span class="nav-text">Reference与ReferenceQueue之间是如何工作的呢？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FinalReference"><span class="nav-number">1.6.</span> <span class="nav-text">FinalReference</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Finalizer%E5%AF%B9%E8%B1%A1%E4%BD%95%E6%97%B6%E8%A2%AB%E6%B3%A8%E5%86%8C%E5%88%B0Finalizer%E5%AF%B9%E8%B1%A1%E9%93%BE%E9%87%8C"><span class="nav-number">1.7.</span> <span class="nav-text">Finalizer对象何时被注册到Finalizer对象链里</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%98%AF%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AAf%E7%B1%BB"><span class="nav-number">1.7.1.</span> <span class="nav-text">如何判断一个类是不是一个f类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#f%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%BD%95%E6%97%B6%E4%BC%A0%E5%88%B0Finalizer-register%E6%96%B9%E6%B3%95"><span class="nav-number">1.7.2.</span> <span class="nav-text">f类的对象何时传到Finalizer.register方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hotspot%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0f%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95%E5%90%8E%E8%B0%83%E7%94%A8Finalizer-register"><span class="nav-number">1.7.3.</span> <span class="nav-text">hotspot如何实现f类对象在构造函数执行完毕后调用Finalizer.register</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#f%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84GC%E5%9B%9E%E6%94%B6"><span class="nav-number">1.7.4.</span> <span class="nav-text">f类对象的GC回收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Finalizer%E5%AF%B9%E8%B1%A1%E4%BD%95%E6%97%B6%E8%A2%AB%E6%94%BE%E5%88%B0ReferenceQueue%E9%87%8C"><span class="nav-number">1.7.5.</span> <span class="nav-text">Finalizer对象何时被放到ReferenceQueue里</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Finalizer%E5%AF%BC%E8%87%B4%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="nav-number">1.7.6.</span> <span class="nav-text">Finalizer导致的内存泄露</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%B1%E5%93%8D"><span class="nav-number">1.7.7.</span> <span class="nav-text">影响</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java-lang-ref-Cleaner-%E4%BB%A3%E6%9B%BF-Finalizer"><span class="nav-number">1.8.</span> <span class="nav-text">java.lang.ref.Cleaner 代替 Finalizer</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">2.</span> <span class="nav-text">参考资料</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Victor Chu" src="/images/victor-blog-head.webp"><p class="site-author-name" itemprop="name">Victor Chu</p><div class="site-description" itemprop="description">blog about programming.</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">210</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">80</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">113</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/chutian0610" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;chutian0610" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:victorchu0610@outlook.com" title="E-Mail → mailto:victorchu0610@outlook.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/victorchu" title="Zhihu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;victorchu" rel="noopener me" target="_blank"><i class="fab fa-zhihu fa-fw"></i>Zhihu</a> </span><span class="links-of-author-item"><a href="/images/Wechat.webp" title="WeChat → &#x2F;images&#x2F;Wechat.webp" rel="noopener me"><i class="fa-brands fa-weixin fa-fw"></i>WeChat</a></span></div></div></div><div class="back-to-top animated" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div><div class="sidebar-inner sidebar-blogroll"><div class="links-of-blogroll animated"><div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i> 链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://www.tpfuture.top/" title="https:&#x2F;&#x2F;www.tpfuture.top&#x2F;" rel="noopener" target="_blank">一水轩</a></li></ul></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.victorchu.info/posts/1e5969ed/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/victor-blog-head.webp"><meta itemprop="name" content="Victor Chu"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="代码之旅"><meta itemprop="description" content="blog about programming."></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Java引用 | 代码之旅"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Java引用</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2017-05-05 14:15:08" itemprop="dateCreated datePublished" datetime="2017-05-05T14:15:08+08:00">2017-05-05</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-11-25 15:12:32" itemprop="dateModified" datetime="2024-11-25T15:12:32+08:00">2024-11-25</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a> </span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/JDK/" itemprop="url" rel="index"><span itemprop="name">JDK</span></a> </span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Waline：</span> <a title="waline" href="/posts/1e5969ed/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/1e5969ed/" itemprop="commentCount"></span> </a></span><span class="post-meta-item" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="waline-pageview-count" data-path="/posts/1e5969ed/"></span> </span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>18k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>30 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>在JDK1.2之前，Java中的引用的定义很传统: <code>如果reference类型(栈中的引用类型)的数据中存储的数值代表另一块内存的起始地址，就称这块内存代表一个引用。</code>在这种情况下，对象只有被引用和没有被引用两种状态。</p><p>我们希望有这样一类对象，当内存空间还足够时，保存在内存中；而如果内存空间在垃圾回收后还是紧张，则可以抛弃这些对象。</p><p>JDK1.2后，java对引用的概念进行了扩充，将引用分为强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(Phanton Reference)这四种，引用强度依次减弱。主要有两个目的：第一是可以让程序员通过代码的方式决定某些对象的生命周期；第二是有利于JVM进行垃圾回收。</p><span id="more"></span><h1 id="扩展的引用类型">扩展的引用类型</h1><p>jvm有四种引用: strong soft weak phantom(其实还有一种FinalReference，这个由jvm自己使用，外部无法调用到），主要的区别体现在gc上的处理，如下：</p><ul><li>Strong类型，也就是正常使用的类型，不需要显示定义，只要没有任何引用就可以回收</li><li>SoftReference类型，如果一个对象只剩下一个soft引用，在jvm内存不足的时候会将这个对象进行回收</li><li>WeakReference类型，如果对象只剩下一个weak引用，那gc的时候就会回收。和SoftReference都可以用来实现cache</li><li>PhantomReference类型，如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收，可以用来实现类似Object.finalize功能。</li></ul><h2 id="强引用">强引用</h2><p>强引用就是指在程序代码之中普遍存在的，比如下面这段代码中的object和str都是强引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure><p>只要某个对象有强引用与之关联，JVM必定不会回收这个对象，即使在内存不足的情况下，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。比如下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Main</span>().fun1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        Object[] objArr = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">1000</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当运行至<code>Object[] objArr = new Object[1000];</code>这句时，如果内存不足，JVM会抛出OOM错误也不会回收object指向的对象。不过要注意的是，当fun1运行完之后，object和objArr都已经不存在了，所以它们指向的对象都会被JVM回收。</p><p>如果想中断强引用和某个对象之间的关联，可以显示地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象。比如Vector类的clear方法中就是通过将引用赋值为null来实现清理工作的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">modCount++;</span><br><span class="line"><span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(index);</span><br><span class="line"><span class="type">Object</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData[index];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> elementCount - index - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">    System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">             numMoved);</span><br><span class="line">elementData[--elementCount] = <span class="literal">null</span>; <span class="comment">// Let gc do its work</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (E)oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="软引用">软引用</h2><p>软引用是用来描述一些有用但并不是必需的对象，在Java中用<code>java.lang.ref.SoftReference</code>类来表示。对于软引用关联着的对象，只有在内存不足异常抛出前，JVM才会把该对象列入回收范围中进行二次回收。若内存仍不足，会抛出内存溢出异常。因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.SoftReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SoftReference&lt;String&gt; sr = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;String&gt;(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">        System.out.println(sr.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="弱引用">弱引用</h2><p>弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用<code>java.lang.ref.WeakReference</code>类来表示。下面是使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.WeakReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        WeakReference&lt;String&gt; sr = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;String&gt;(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">        System.out.println(sr.get());</span><br><span class="line">        System.gc();                <span class="comment">//通知JVM的gc进行垃圾回收</span></span><br><span class="line">        System.out.println(sr.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** ------ out put ----</span></span><br><span class="line"><span class="comment"> * hello</span></span><br><span class="line"><span class="comment"> * null</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>第二个输出结果是null，这说明只要JVM进行垃圾回收，被弱引用关联的对象必定会被回收掉。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被JVM回收，这个软引用就会被加入到与之关联的引用队列中。</p><blockquote><p>要注意的是，这里所说的被弱引用关联的对象是指只有弱引用与之关联，如果存在强引用同时与之关联，则进行垃圾回收时也不会回收该对象（软引用也是如此）。</p></blockquote><h2 id="虚引用">虚引用</h2><p>虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期。在java中用java.lang.ref.PhantomReference类表示。如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。要注意的是，虚引用必须和引用队列关联使用。</p><p>当referent被gc回收时，JVM自动把PhantomReference对象(reference)本身加入到ReferenceQueue中，像发出信号通知一样，表明该reference指向的referent被回收。然后可以通过去queue中取到reference，此时说明其指向的referent已经被回收，可以通过这个通知机制来做额外的清场工作。 因此有些情况可以用PhantomReference 代替finalize()，做资源释放更明智。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.PhantomReference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.ReferenceQueue;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ReferenceQueue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;String&gt;();</span><br><span class="line">        PhantomReference&lt;String&gt; pr = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;String&gt;(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>), queue);</span><br><span class="line">        System.out.println(pr.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用虚引用有潜在的内存泄露风险，因为JVM不会自动帮助我们释放，我们必须要保证它指向的堆对象是不可达的。</p><ul><li>软引用和弱引用差别不大，JVM都是先将其referent字段设置成null，之后将软引用或弱引用，加入到关联的引用队列中。我们可以认为JVM先回收堆对象占用的内存，然后才将软引用或弱引用加入到引用队列。</li><li>而虚引用则不同，JVM不会自动将虚引用的referent字段设置成null，而是先保留堆对象的内存空间，直接将PhantomReference加入到关联的引用队列，也就是说如果我们不手动调用PhantomReference.clear()，虚引用指向的堆对象内存是不会被释放的。</li></ul><h2 id="Reference与ReferenceQueue">Reference与ReferenceQueue</h2><p>Reference作为SoftReference，WeakReference，PhantomReference，FinalReference这几个引用类型的父类。主要有两个字段referent、queue，一个是指所引用的对象，一个是与之对应的ReferenceQueue。Reference类有个构造函数 <code>Reference(T referent, ReferenceQueue&lt;? super T&gt; queue)</code>，可以通过该构造函数传入与Reference相伴的ReferenceQueue。</p><p>ReferenceQueue本身提供队列的功能，有入队(enqueue)和出队(poll,remove,其中remove阻塞等待提取队列元素)。ReferenceQueue对象本身保存了一个Reference类型的head节点，Reference封装了next字段，这样就是可以组成一个单向链表。同时ReferenceQueue提供了两个静态字段NULL，ENQUEUED。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ReferenceQueue&lt;Object&gt; NULL = <span class="keyword">new</span> <span class="title class_">Null</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">static</span> ReferenceQueue&lt;Object&gt; ENQUEUED = <span class="keyword">new</span> <span class="title class_">Null</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>这两个字段的主要功能：NULL是当我们构造Reference实例时queue传入null时，会默认使用NULL，这样在enqueue时判断queue是否为NULL,如果为NULL直接返回，入队失败。ENQUEUED的作用是防止重复入队，reference后会把其queue字段赋值为ENQUEUED,当再次入队时会直接返回失败。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">enqueue</span><span class="params">(Reference&lt;? extends T&gt; r)</span> &#123; <span class="comment">/* Called only by Reference class */</span></span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="comment">// Check that since getting the lock this reference hasn’t already been</span></span><br><span class="line">        <span class="comment">// enqueued (and even then removed)</span></span><br><span class="line">        ReferenceQueue&lt;?&gt; queue = r.queue;</span><br><span class="line">        <span class="comment">// 此处的 NULL 是上方的 ReferenceQueue&lt;Object&gt; NULL </span></span><br><span class="line">        <span class="keyword">if</span> ((queue == NULL) || (queue == ENQUEUED)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">assert</span> queue == <span class="built_in">this</span>;</span><br><span class="line">        r.queue = ENQUEUED; <span class="comment">// reference 入队后，状态改为入队</span></span><br><span class="line">        r.next = (head == <span class="literal">null</span>) ? r : head;</span><br><span class="line">        head = r;<span class="comment">// 插入队列头部</span></span><br><span class="line">        queueLength++;</span><br><span class="line">        <span class="keyword">if</span> (r <span class="keyword">instanceof</span> FinalReference) &#123;</span><br><span class="line">            sun.misc.VM.addFinalRefCount(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        lock.notifyAll();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="reference类">reference类</h3><p>Reference类存在四种不同的状态：</p><ul><li>Active：接受垃圾收集器的特殊处理。 在收集器检测到引用对象的可达性已更改为适当状态后的一段时间，它会将实例的状态更改为 Pending 或 Inactive，具体取决于实例在创建时是否已注册到队列中。 在前一种情况下，它还将实例添加到待处理的引用列表中。 新创建的实例处于活动状态。</li><li>Pending：待处理引用列表的一个元素，等待被引用处理线程加入到ReferenceQueue。 未注册的实例永远不会处于这种状态。</li><li>Enqueued：实例创建时注册了队列元素。 当一个实例从其 ReferenceQueue 中移除时，它会变为非活动状态。 未注册的实例永远不会处于这种状态。</li><li>Inactive：无事可做。 一旦一个实例变为非活动状态，它的状态将永远不会再改变，等待gc回收。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// public abstract class Reference&lt;T&gt; </span></span><br><span class="line">   <span class="comment">// 引用的对象</span></span><br><span class="line">    <span class="keyword">private</span> T referent;         <span class="comment">/* Treated specially by GC */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> ReferenceQueue&lt;? <span class="built_in">super</span> T&gt; queue;</span><br><span class="line">   <span class="comment">/* When </span></span><br><span class="line"><span class="comment">    *    Active:   NULL</span></span><br><span class="line"><span class="comment">    *    pending:   this</span></span><br><span class="line"><span class="comment">    *    Enqueued:   next reference in queue (or this if last)</span></span><br><span class="line"><span class="comment">    *    Inactive:   this</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Reference next; </span><br><span class="line"></span><br><span class="line">   <span class="comment">/* When </span></span><br><span class="line"><span class="comment">     *    active:   next element in a discovered reference list maintained by GC (or this if last)</span></span><br><span class="line"><span class="comment">     *    pending:   next element in the pending list (or null if last)</span></span><br><span class="line"><span class="comment">     *    otherwise:   NULL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">private</span> Reference&lt;T&gt; discovered;  <span class="comment">/* used by VM */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Object used to synchronize with the garbage collector.  The collector</span></span><br><span class="line"><span class="comment">     * must acquire this lock at the beginning of each collection cycle.  It is</span></span><br><span class="line"><span class="comment">     * therefore critical that any code holding this lock complete as quickly</span></span><br><span class="line"><span class="comment">     * as possible, allocate no new objects, and avoid calling user code.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Lock</span> &#123; &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* List of References waiting to be enqueued.  The collector adds</span></span><br><span class="line"><span class="comment">     * References to this list, while the Reference-handler thread removes</span></span><br><span class="line"><span class="comment">     * them.  This list is protected by the above lock object. The</span></span><br><span class="line"><span class="comment">     * list uses the discovered field to link its elements.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Reference&lt;Object&gt; pending = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//... ...</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReferenceHandler</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    ReferenceHandler(ThreadGroup g, String name) &#123;</span><br><span class="line">        <span class="built_in">super</span>(g, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            tryHandlePending(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">tryHandlePending</span><span class="params">(<span class="type">boolean</span> waitForNotify)</span> &#123;</span><br><span class="line">        Reference&lt;Object&gt; r;</span><br><span class="line">        Cleaner c;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pending != <span class="literal">null</span>) &#123;</span><br><span class="line">                    r = pending;</span><br><span class="line">                    <span class="comment">// &#x27;instanceof&#x27; might throw OutOfMemoryError sometimes</span></span><br><span class="line">                    <span class="comment">// so do this before un-linking &#x27;r&#x27; from the &#x27;pending&#x27; chain...</span></span><br><span class="line">                    c = r <span class="keyword">instanceof</span> Cleaner ? (Cleaner) r : <span class="literal">null</span>;</span><br><span class="line">                    <span class="comment">// unlink &#x27;r&#x27; from &#x27;pending&#x27; chain</span></span><br><span class="line">                    pending = r.discovered;</span><br><span class="line">                    r.discovered = <span class="literal">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// The waiting on the lock may cause an OutOfMemoryError</span></span><br><span class="line">                    <span class="comment">// because it may try to allocate exception objects.</span></span><br><span class="line">                    <span class="keyword">if</span> (waitForNotify) &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// retry if waited</span></span><br><span class="line">                    <span class="keyword">return</span> waitForNotify;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">            <span class="comment">// Give other threads CPU time so they hopefully drop some live references</span></span><br><span class="line">            <span class="comment">// and GC reclaims some space.</span></span><br><span class="line">            <span class="comment">// Also prevent CPU intensive spinning in case &#x27;r instanceof Cleaner&#x27; above</span></span><br><span class="line">            <span class="comment">// persistently throws OOME for some time...</span></span><br><span class="line">            Thread.<span class="keyword">yield</span>();</span><br><span class="line">            <span class="comment">// retry</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">            <span class="comment">// retry</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Fast path for cleaners, cleaner 是虚引用的子类</span></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="literal">null</span>) &#123;</span><br><span class="line">            c.clean();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ReferenceQueue&lt;? <span class="built_in">super</span> Object&gt; q = r.queue;</span><br><span class="line">        <span class="keyword">if</span> (q != ReferenceQueue.NULL) q.enqueue(r);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ReferenceQueue 入队后，会将Reference 加入到内置的链表中，Queue提供了poll方法用于取出元素，一般后续操作就是设置为null。例如在java.util.WeakHashMap的expungeStaleEntries方法中。</p><figure><img data-src="/posts/1e5969ed/java_reference.webp" alt></figure><h3 id="Reference与ReferenceQueue之间是如何工作的呢？">Reference与ReferenceQueue之间是如何工作的呢？</h3><p>Reference里有个静态字段pending，同时还通过静态代码块启动了Reference-handler thread。当一个Reference的referent被回收时，垃圾回收器会把reference添加到pending这个链表里，然后Reference-handler thread不断的读取pending中的reference，把它加入到对应的ReferenceQueue中。</p><p>可见如果pending为空的时候，会通过lock.wait()一直等在那里，其中唤醒的动作是在jvm里做的，当gc完成之后会调用如下的方法VM_GC_Operation::doit_epilogue()，在方法末尾会调用lock的notify操作，至于pending队列什么时候将引用放进去的，其实是在gc的引用处理逻辑中放进去的<a href="#refer-anchor-3"><sup>3</sup></a>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">VM_GC_Operation::doit_epilogue</span><span class="params">()</span> &#123;</span><br><span class="line">  assert(Thread::current()-&gt;is_Java_thread(), <span class="string">&quot;just checking&quot;</span>);</span><br><span class="line">  <span class="comment">// Release the Heap_lock first.</span></span><br><span class="line">  SharedHeap* sh = SharedHeap::heap();</span><br><span class="line">  <span class="keyword">if</span> (sh != <span class="literal">NULL</span>) sh-&gt;_thread_holds_heap_lock_for_gc = <span class="literal">false</span>;</span><br><span class="line">  Heap_lock-&gt;unlock();</span><br><span class="line">  release_and_notify_pending_list_lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">VM_GC_Operation::release_and_notify_pending_list_lock</span><span class="params">()</span> &#123;</span><br><span class="line">instanceRefKlass::release_and_notify_pending_list_lock(&amp;_pending_list_basic_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过下面代码块来进行把SoftReference，WeakReference，PhantomReference与ReferenceQueue联合使用来验证这个机制。为了确保SoftReference在每次gc后，其引用的referent都被回收，我们需要加入-XX:SoftRefLRUPolicyMSPerMB=0参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为了确保System.gc()后,SoftReference引用的referent被回收需要加入下面的参数</span></span><br><span class="line"><span class="comment"> * -XX:SoftRefLRUPolicyMSPerMB=0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Reference&gt; roots = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ReferenceQueue</span> <span class="variable">rq</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">Reference</span> <span class="variable">r</span> <span class="operator">=</span> rq.remove();</span><br><span class="line">                        System.out.println(<span class="string">&quot;reference:&quot;</span>+r);</span><br><span class="line">                        System.out.println( <span class="string">&quot;get:&quot;</span>+r.get()); <span class="comment">//为null说明referent被回收</span></span><br><span class="line">                        i++;</span><br><span class="line">                        System.out.println( <span class="string">&quot;queue remove num:&quot;</span>+i);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100000</span>;i++) &#123;</span><br><span class="line">            <span class="type">byte</span>[] a = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">// 分别验证SoftReference,WeakReference,PhantomReference</span></span><br><span class="line">            <span class="type">Reference</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SoftReference</span>(a, rq);</span><br><span class="line">            <span class="comment">//Reference r = new WeakReference(a, rq);</span></span><br><span class="line">            <span class="comment">//Reference r = new PhantomReference(a, rq);</span></span><br><span class="line">            roots.add(r);</span><br><span class="line">            System.gc();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;produce&quot;</span>+i);</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过jstack命令可以看到对应的Reference Handler thread</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">“Reference Handler” #<span class="number">2</span> daemon prio=<span class="number">10</span> os_prio=<span class="number">31</span> tid=<span class="number">0x00007f8fb2836800</span> nid=<span class="number">0x2e03</span> in Object.wait() [<span class="number">0x000070000082b000</span>]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        – waiting on &lt;<span class="number">0x0000000740008878</span>&gt; (a java.lang.ref.Reference$Lock)</span><br><span class="line">        at java.lang.Object.wait(Object.java:<span class="number">502</span>)</span><br><span class="line">        at java.lang.ref.Reference.tryHandlePending(Reference.java:<span class="number">191</span>)</span><br><span class="line">        – locked &lt;<span class="number">0x0000000740008878</span>&gt; (a java.lang.ref.Reference$Lock)</span><br><span class="line">        at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:<span class="number">153</span>)</span><br></pre></td></tr></table></figure><p>因此可以看出，当reference与referenQueue联合使用的主要作用就是当reference指向的referent回收时(或者要被回收,如下文要讲的Finalizer)，提供一种通知机制，通过queue取到这些reference，来做额外的处理工作(比 Object的finalize方法更精细<a href="#refer-anchor-1"><sup>1</sup></a>)。当然，如果我们不需要这种通知机制，我们就不用传入额外的queue,默认使用NULL queue就会入队失败。</p><h2 id="FinalReference">FinalReference</h2><p>FinalReference 用于处理所有的finalizer类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FinalReference</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Reference</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FinalReference</span><span class="params">(T referent, ReferenceQueue&lt;? <span class="built_in">super</span> T&gt; q)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(referent, q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类访问权限是package的，这也就意味着我们不能直接去对其进行扩展，但是JDK里对此类进行了扩展实现java.lang.ref.Finalizer，这个类在概述里提到的过，而此类的访问权限也是package的，并且是final的，意味着它不能再被扩展了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Finalizer</span> <span class="keyword">extends</span> <span class="title class_">FinalReference</span> &#123;</span><br><span class="line">    <span class="comment">/* A native method that invokes an arbitrary object&#x27;s finalize method is</span></span><br><span class="line"><span class="comment">       required since the finalize method is protected</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">invokeFinalizeMethod</span><span class="params">(Object o)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReferenceQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Finalizer</span> <span class="variable">unfinalized</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Finalizer</span></span><br><span class="line">        <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>,</span><br><span class="line">        prev = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Finalizer</span><span class="params">(Object finalizee)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(finalizee, queue);</span><br><span class="line">        add();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Invoked by VM */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Object finalizee)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Finalizer</span>(finalizee);</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (unfinalized != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.next = unfinalized;</span><br><span class="line">                unfinalized.prev = <span class="built_in">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            unfinalized = <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>Finalizer的构造函数提供了以下几个关键信息：</p><ul><li>private：意味着我们无法在当前类之外构建这类的对象；</li><li>finalizee参数：FinalReference指向的对象引用；</li><li>调用add方法：将当前对象插入到Finalizer对象链里，链里的对象和Finalizer类静态关联。言外之意是在这个链里的对象都无法被GC掉，除非将这种引用关系剥离（因为Finalizer类无法被unload）。</li></ul><p>虽然外面无法创建Finalizer对象，但是它有一个名为register的静态方法，该方法可以创建这种对象，同时将这个对象加入到Finalizer对象链里，这个方法是被vm调用的，那么问题来了，vm在什么情况下会调用这个方法呢？</p><h2 id="Finalizer对象何时被注册到Finalizer对象链里">Finalizer对象何时被注册到Finalizer对象链里</h2><p>类的修饰有很多，比如final，abstract，public等，如果某个类用final修饰，我们就说这个类是final类，上面列的都是语法层面我们可以显式指定的，在JVM里其实还会给类标记一些其他符号，比如finalizer，表示这个类是一个finalizer类（为了和java.lang.ref.Fianlizer类区分，下文在提到的finalizer类时会简称为f类），GC在处理这种类的对象时要做一些特殊的处理，如在这个对象被回收之前会调用它的finalize方法。</p><h3 id="如何判断一个类是不是一个f类">如何判断一个类是不是一个f类</h3><p>在讲这个问题之前，我们先来看下java.lang.Object里的一个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure><p>在Object类里定义了一个名为finalize的空方法，这意味着Java里的所有类都会继承这个方法，甚至可以覆写该方法，并且根据方法覆写原则，如果子类覆盖此方法，方法访问权限至少protected级别的，这样其子类就算没有覆写此方法也会继承此方法。</p><p>而判断当前类是否是f类的标准并不仅仅是当前类是否含有一个参数为空，返回值为void的finalize方法，还要求finalize方法必须非空，因此Object类虽然含有一个finalize方法，但它并不是f类，Object的对象在被GC回收时其实并不会调用它的finalize方法。</p><p>需要注意的是，类在加载过程中其实就已经被标记为是否为f类了。（JVM在类加载的时候会遍历当前类的所有方法，包括父类的方法，只要有一个参数为空且返回void的非空finalize方法就认为这个类是f类。）</p><h3 id="f类的对象何时传到Finalizer-register方法">f类的对象何时传到Finalizer.register方法</h3><p>对象的创建其实是被拆分成多个步骤的，比如A a=new A(2)这样一条语句对应的字节码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">1</span>                  <span class="comment">// class A</span></span><br><span class="line"><span class="number">3</span>: dup</span><br><span class="line"><span class="number">4</span>: iconst_2</span><br><span class="line"><span class="number">5</span>: invokespecial #<span class="number">11</span>                 <span class="comment">// Method &quot;&lt;init&gt;&quot;:(I)V</span></span><br></pre></td></tr></table></figure><p>先执行new分配好对象空间，然后再执行invokespecial调用构造函数，JVM里其实可以让用户在这两个时机中选择一个，将当前对象传递给Finalizer.register方法来注册到Finalizer对象链里，这个选择取决于是否设置了RegisterFinalizersAtInit这个vm参数，默认值为true，也就是在构造函数返回之前调用Finalizer.register方法，如果通过-XX:-RegisterFinalizersAtInit关闭了该参数，那将在对象空间分配好之后将这个对象注册进去。</p><p>另外需要提醒的是，当我们通过clone的方式复制一个对象时，如果当前类是一个f类，那么在clone完成时将调用Finalizer.register方法进行注册。</p><h3 id="hotspot如何实现f类对象在构造函数执行完毕后调用Finalizer-register">hotspot如何实现f类对象在构造函数执行完毕后调用Finalizer.register</h3><p>这个实现比较有意思，在这简单提一下，我们知道执行一个构造函数时，会去调用父类的构造函数，主要是为了初始化继承自父类的属性，那么任何一个对象的初始化最终都会调用到Object的空构造函数里（任何空的构造函数其实并不空，会含有三条字节码指令，如下代码所示），为了不对所有类的构造函数都埋点调用Finalizer.register方法，hotspot的实现是，在初始化Object类时将构造函数里的return指令替换为_return_register_finalizer指令，该指令并不是标准的字节码指令，是hotspot扩展的指令，这样在处理该指令时调用Finalizer.register方法，以很小的侵入性代价完美地解决了这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: aload_0</span><br><span class="line"><span class="number">1</span>: invokespecial #<span class="number">21</span>                 <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line"><span class="number">4</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><h3 id="f类对象的GC回收">f类对象的GC回收</h3><p>在Finalizer类的clinit方法（静态块）里，我们看到它会创建一个FinalizerThread守护线程，这个线程的优先级并不是最高的，意味着在CPU很紧张的情况下其被调度的优先级可能会受到影响.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">FinalizerThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> running;</span><br><span class="line">    FinalizerThread(ThreadGroup g) &#123;</span><br><span class="line">        <span class="built_in">super</span>(g, <span class="string">&quot;Finalizer&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (running)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        running = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Finalizer</span> <span class="variable">f</span> <span class="operator">=</span> (Finalizer)queue.remove();</span><br><span class="line">                f.runFinalizer();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="type">ThreadGroup</span> <span class="variable">tg</span> <span class="operator">=</span> Thread.currentThread().getThreadGroup();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">ThreadGroup</span> <span class="variable">tgn</span> <span class="operator">=</span> tg;</span><br><span class="line">            tgn != <span class="literal">null</span>;</span><br><span class="line">            tg = tgn, tgn = tg.getParent());</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">finalizer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FinalizerThread</span>(tg);</span><br><span class="line">    finalizer.setPriority(Thread.MAX_PRIORITY - <span class="number">2</span>);</span><br><span class="line">    finalizer.setDaemon(<span class="literal">true</span>);</span><br><span class="line">    finalizer.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个线程用来从queue里获取Finalizer对象，然后执行该对象的runFinalizer方法，该方法会将Finalizer对象从Finalizer对象链里剥离出来，这样意味着下次GC发生时就可以将其关联的f对象回收了，最后将这个Finalizer对象关联的f对象传给一个native方法invokeFinalizeMethod。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">runFinalizer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasBeenFinalized()) <span class="keyword">return</span>;</span><br><span class="line">            remove();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">finalizee</span> <span class="operator">=</span> <span class="built_in">this</span>.get();</span><br><span class="line">            <span class="keyword">if</span> (finalizee != <span class="literal">null</span> &amp;&amp; !(finalizee <span class="keyword">instanceof</span> java.lang.Enum)) &#123;</span><br><span class="line">                invokeFinalizeMethod(finalizee);</span><br><span class="line">                <span class="comment">/* Clear stack slot containing this variable, to decrease</span></span><br><span class="line"><span class="comment">                   the chances of false retention with a conservative GC */</span></span><br><span class="line">                finalizee = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable x) &#123; &#125;</span><br><span class="line">        <span class="built_in">super</span>.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">invokeFinalizeMethod</span><span class="params">(Object o)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line"><span class="comment">// invokeFinalizeMethod方法就是调了这个f对象的finalize方法</span></span><br></pre></td></tr></table></figure><h3 id="Finalizer对象何时被放到ReferenceQueue里">Finalizer对象何时被放到ReferenceQueue里</h3><p>当GC发生时，GC算法会判断f类对象是不是只被Finalizer类引用（f类对象被Finalizer对象引用，然后放到Finalizer对象链里），如果这个类仅仅被Finalizer对象引用，说明这个对象在不久的将来会被回收，现在可以执行它的finalize方法了，于是会将这个Finalizer对象放到Finalizer类的ReferenceQueue里，但是这个f类对象其实并没有被回收，因为Finalizer这个类还对它们保持引用，在GC完成之前，JVM会调用ReferenceQueue中lock对象的notify方法（当ReferenceQueue为空时，FinalizerThread线程会调用ReferenceQueue的lock对象的wait方法直到被JVM唤醒），此时就会执行上面FinalizeThread线程里看到的其他逻辑了。</p><h3 id="Finalizer导致的内存泄露">Finalizer导致的内存泄露</h3><p>SocksSocketImpl的父类其实就实现了finalize方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cleans up if the user forgets to close it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这么做的主要目的是万一用户忘记关闭Socket，那么在这个对象被回收时能主动关闭Socket来释放一些系统资源，但是如果用户真的忘记关闭，那这些socket对象可能因为FinalizeThread迟迟没有执行这些socket对象的finalize方法，而导致内存泄露.</p><h3 id="影响">影响</h3><ul><li>f对象因为Finalizer的引用而变成了一个临时的强引用，即使没有其他的强引用，还是无法立即被回收；</li><li>f对象至少经历两次GC才能被回收，因为只有在FinalizerThread执行完了f对象的finalize方法的情况下才有可能被下次GC回收，而有可能期间已经经历过多次GC了，但是一直还没执行f对象的finalize方法。f对象成为了快速回收的阻碍者。</li><li>CPU资源比较稀缺的情况下FinalizerThread线程有可能因为优先级比较低而延迟执行f对象的finalize方法；</li><li>因为f对象的finalize方法迟迟没有执行，有可能会导致大部分f对象进入到old分代，此时容易引发old分代的GC，甚至Full GC，GC暂停时间明显变长；</li><li>f对象的finalize方法被调用后，这个对象其实还并没有被回收，虽然可能在不久的将来会被回收。</li><li>对于消耗非常高频的资源，不要指望finalize去承担释放资源的主要职责。推荐做法：资源用完即显式释放，或者利用资源池来复用。</li><li>另外，finalize会掩盖资源回收时的出错信息：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.lang.ref.Finalizer ,Throwable被吞</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">runFinalizer</span><span class="params">(JavaLangAccess jla)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">finalizee</span> <span class="operator">=</span> <span class="built_in">this</span>.get();</span><br><span class="line">        <span class="keyword">if</span> (finalizee != <span class="literal">null</span> &amp;&amp; !(finalizee <span class="keyword">instanceof</span> java.lang.Enum)) &#123;</span><br><span class="line">            jla.invokeFinalize(finalizee);</span><br><span class="line">            <span class="comment">// Clear stack slot containing this variable, to decrease</span></span><br><span class="line">            <span class="comment">// the chances of false retention with a conservative GC</span></span><br><span class="line">            finalizee = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable x) &#123; &#125;</span><br><span class="line">    <span class="built_in">super</span>.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="java-lang-ref-Cleaner-代替-Finalizer"><code>java.lang.ref.Cleaner</code> 代替 Finalizer</h2><p>java.lang.ref.Cleaner 的实现依赖于PhantomReference(虚引用)和 ReferenceQueue。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 官方文档demo</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CleaningExample</span> <span class="keyword">implements</span> <span class="title class_">AutoCloseable</span> &#123;</span><br><span class="line">    <span class="comment">// A cleaner, preferably one shared within a library</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Cleaner</span> <span class="variable">cleaner</span> <span class="operator">=</span> Cleaner.create();</span><br><span class="line">    <span class="comment">// 当对象变成虚引用时的action</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">State</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">       State() &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;init&quot;</span>);<span class="comment">// initialize State needed for cleaning action</span></span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;clean&quot;</span>);<span class="comment">// cleanup action accessing State, executed at most once</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> State;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Cleaner.Cleanable cleanable</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CleaningExample</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = <span class="keyword">new</span> <span class="title class_">State</span>();</span><br><span class="line">        <span class="built_in">this</span>.cleanable = cleaner.register(<span class="built_in">this</span>, state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">       cleanable.clean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>仅在关联对象变为虚引用之后才调用清理操作，因此实现清理操作的对象不保留对该对象的引用非常重要。在示例中，静态内部类(静态的内部类不会持有外部类的一个隐式引用)封装了清理状态和操作，此处不使用lambda 和 内部类(匿名或非匿名),因为它们隐式包含对外部实例的引用，从而防止关联对象成为虚引用。</p><h1 id="参考资料">参考资料</h1><div id="refer-anchor-1"></div><ul><li><p>[1] <a target="_blank" rel="noopener" href="http://blog.ragozin.info/2016/03/finalizers-and-references-in-java.html">http://blog.ragozin.info/2016/03/finalizers-and-references-in-java.html</a></p></li><li><p>[2] <a target="_blank" rel="noopener" href="http://www.infoq.com/cn/articles/jvm-source-code-analysis-finalreference">http://www.infoq.com/cn/articles/jvm-source-code-analysis-finalreference</a></p></li></ul><div id="refer-anchor-3"></div><ul><li>[3] <a target="_blank" rel="noopener" href="http://lovestblog.cn/blog/2015/05/12/direct-buffer/">http://lovestblog.cn/blog/2015/05/12/direct-buffer/</a></li><li>[4] <a target="_blank" rel="noopener" href="https://bugs.openjdk.java.net/browse/JDK-8138696">https://bugs.openjdk.java.net/browse/JDK-8138696</a></li><li>[5] <a target="_blank" rel="noopener" href="https://bugs.openjdk.java.net/browse/JDK-6534574">https://bugs.openjdk.java.net/browse/JDK-6534574</a></li></ul></div><footer class="post-footer"><div class="reward-container"><div>请我一杯咖啡吧！</div><button>赞赏</button><div class="post-reward"><div><img src="/images/weixinpay.webp" alt="Victor Chu 微信"> <span>微信</span></div><div><img src="/images/alpay.webp" alt="Victor Chu 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"><strong>本文作者： </strong>Victor Chu</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://www.victorchu.info/posts/1e5969ed/" title="Java引用">https://www.victorchu.info/posts/1e5969ed/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="followme"><span>欢迎关注我的其它发布渠道</span><div class="social-list"><div class="social-item"><a target="_blank" class="social-link" href="/atom.xml"><span class="icon"><i class="fa fa-rss"></i> </span><span class="label">RSS</span></a></div><div class="social-item"><a target="_blank" class="social-link" href="/images/wechat_channel.webp"><span class="icon"><i class="fab fa-weixin"></i> </span><span class="label">WeChat</span></a></div></div></div><div class="post-tags"><a href="/tags/Reference/" rel="tag"><i class="fa fa-tag"></i> Reference</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/a8819e70/" rel="prev" title="使用 JOL 分析 Java 对象内存"><i class="fa fa-angle-left"></i> 使用 JOL 分析 Java 对象内存</a></div><div class="post-nav-item"><a href="/posts/fa358471/" rel="next" title="Java 反射">Java 反射 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">浙ICP备18037908号-1 </a><img src="/images/gongan_icon.webp" alt=""><a href="https://beian.mps.gov.cn/#/query/webSearch?code=33010902002043" rel="noopener" target="_blank">浙公网安备 33010902002043号</a></div><div class="copyright">&copy; 2016 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Victor Chu</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span title="站点总字数">1.8m</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">50:12</span></span></div><div class="powered-by">由<a href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" class="theme-link" rel="noopener" target="_blank"><img src="/images/upyun_logo.webp" width="50" style="display:inline"></a>提供CDN服务</div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/algoliasearch/4.23.3/algoliasearch-lite.umd.js" integrity="sha256-1QNshz86RqXe/qsCBldsUu13eAX6n/O98uubKQs87UI=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/instantsearch.js/4.67.0/instantsearch.production.min.js" integrity="sha256-TW7D3X/i/W+RUgEeDppEnFT2ixv5lzplKH0c58D92dY=" crossorigin="anonymous"></script><script src="/js/third-party/search/algolia-search.js"></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":"default","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.9.0/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script><script src="/js/third-party/tags/mermaid.js"></script><script src="/js/third-party/fancybox.js"></script><script class="next-config" data-name="enableMath" type="application/json">false</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css" integrity="sha256-UF1fgpAiu3tPJN/uCqEUHNe7pnr+QR0SQDNfgglgtcM=" crossorigin="anonymous"><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"walineui.victorchu.info","cssUrl":"https://cdn.staticfile.org/waline/2.15.8/waline.css","commentCount":true,"pageview":true,"requiredMeta":["nick","mail"],"login":"force","libUrl":"https://cdn.staticfile.org/waline/2.15.8/waline.js","el":"#waline","comment":true,"path":"/posts/1e5969ed/"}</script><link rel="stylesheet" href="https://cdn.staticfile.org/waline/2.15.8/waline.css"><script>document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});</script><script defer src="/_vercel/insights/script.js"></script><script defer src="/_vercel/speed-insights//script.js"></script></body></html>