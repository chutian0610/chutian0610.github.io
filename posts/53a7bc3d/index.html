<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"www.victorchu.info","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"style":null,"show_result":"mac"},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"waline","storage":false,"lazyload":false,"nav":null,"activeClass":"waline"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"algolia":{"appID":"X9UOD4FSUP","apiKey":"fa32db1f02073025c69da8ebad0a6aa6","indexName":"hexo-next-blog","hits":{"per_page":10}}}</script><script src="/js/config.js"></script><meta name="description" content="上篇分析了SQL逻辑执行计划的生成，本篇将继续分析逻辑计划是如何在进行调度的。"><meta property="og:type" content="article"><meta property="og:title" content="Trino源码学习-查询调度"><meta property="og:url" content="https://www.victorchu.info/posts/53a7bc3d/index.html"><meta property="og:site_name" content="代码之旅"><meta property="og:description" content="上篇分析了SQL逻辑执行计划的生成，本篇将继续分析逻辑计划是如何在进行调度的。"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-02-28T06:26:19.000Z"><meta property="article:modified_time" content="2024-06-27T06:53:33.494Z"><meta property="article:author" content="Victor Chu"><meta property="article:tag" content="Presto"><meta property="article:tag" content="Trino"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://www.victorchu.info/posts/53a7bc3d/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.victorchu.info/posts/53a7bc3d/","path":"/posts/53a7bc3d/","title":"Trino源码学习-查询调度"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Trino源码学习-查询调度 | 代码之旅</title><script src="/js/third-party/analytics/baidu-analytics.js"></script><script async src="https://hm.baidu.com/hm.js?277fc29fa80de77c97f4f62b69e94233"></script><link rel="dns-prefetch" href="walineui.victorchu.info"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="alternate" href="/atom.xml" title="代码之旅" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">代码之旅</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">I love Coding !</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">109</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">80</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">199</span></a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="algolia-stats"><hr></div><div class="algolia-hits"></div><div class="algolia-pagination"></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E8%B0%83%E5%BA%A6"><span class="nav-number">1.</span> <span class="nav-text">查询调度</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E6%9F%A5%E8%AF%A2%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="nav-number">1.1.</span> <span class="nav-text">构建查询调度器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#QueryScheduler"><span class="nav-number">1.2.</span> <span class="nav-text">QueryScheduler</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NodeScheduler"><span class="nav-number">1.3.</span> <span class="nav-text">NodeScheduler</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#NodeSelector"><span class="nav-number">1.3.1.</span> <span class="nav-text">NodeSelector</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NodePartitioningManager"><span class="nav-number">1.4.</span> <span class="nav-text">NodePartitioningManager</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#PipelinedQueryScheduler"><span class="nav-number">2.</span> <span class="nav-text">PipelinedQueryScheduler</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%9F%E6%88%90SqlStage"><span class="nav-number">2.1.</span> <span class="nav-text">生成SqlStage</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8ESubplan%E5%88%9B%E5%BB%BASqlStage"><span class="nav-number">2.1.1.</span> <span class="nav-text">从Subplan创建SqlStage</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8ESqlStage%E5%88%9B%E5%BB%BAStageExecution"><span class="nav-number">2.1.2.</span> <span class="nav-text">从SqlStage创建StageExecution</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#coordinatorStage-%E8%B0%83%E5%BA%A6"><span class="nav-number">2.2.</span> <span class="nav-text">coordinatorStage 调度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#distributedStage"><span class="nav-number">2.3.</span> <span class="nav-text">distributedStage</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ExecutionSchedule"><span class="nav-number">2.4.</span> <span class="nav-text">ExecutionSchedule</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#StageScheduler"><span class="nav-number">2.5.</span> <span class="nav-text">StageScheduler</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#FixedCountScheduler"><span class="nav-number">2.5.1.</span> <span class="nav-text">FixedCountScheduler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FixedSourcePartitionedScheduler"><span class="nav-number">2.5.2.</span> <span class="nav-text">FixedSourcePartitionedScheduler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ScaledWriterScheduler"><span class="nav-number">2.5.3.</span> <span class="nav-text">ScaledWriterScheduler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#newSourcePartitionedSchedulerAsStageScheduler"><span class="nav-number">2.5.4.</span> <span class="nav-text">newSourcePartitionedSchedulerAsStageScheduler</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Victor Chu" src="/images/victor-blog-head.webp"><p class="site-author-name" itemprop="name">Victor Chu</p><div class="site-description" itemprop="description">blog about programming.</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">199</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">80</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">109</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/chutian0610" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;chutian0610" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:victorchu0610@outlook.com" title="E-Mail → mailto:victorchu0610@outlook.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/victorchu" title="Zhihu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;victorchu" rel="noopener me" target="_blank"><i class="fab fa-zhihu fa-fw"></i>Zhihu</a> </span><span class="links-of-author-item"><a href="/images/Wechat.webp" title="WeChat → &#x2F;images&#x2F;Wechat.webp" rel="noopener me"><i class="fa-brands fa-weixin fa-fw"></i>WeChat</a></span></div></div></div><div class="back-to-top animated" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div><div class="sidebar-inner sidebar-blogroll"><div class="links-of-blogroll animated"><div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i> 链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://www.tpfuture.top/" title="https:&#x2F;&#x2F;www.tpfuture.top&#x2F;" rel="noopener" target="_blank">一水轩</a></li></ul></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.victorchu.info/posts/53a7bc3d/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/victor-blog-head.webp"><meta itemprop="name" content="Victor Chu"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="代码之旅"><meta itemprop="description" content="blog about programming."></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Trino源码学习-查询调度 | 代码之旅"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Trino源码学习-查询调度</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-02-28 14:26:19" itemprop="dateCreated datePublished" datetime="2023-02-28T14:26:19+08:00">2023-02-28</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-06-27 14:53:33" itemprop="dateModified" datetime="2024-06-27T14:53:33+08:00">2024-06-27</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Trino/" itemprop="url" rel="index"><span itemprop="name">Trino</span></a> </span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Waline：</span> <a title="waline" href="/posts/53a7bc3d/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/53a7bc3d/" itemprop="commentCount"></span> </a></span><span class="post-meta-item" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="waline-pageview-count" data-path="/posts/53a7bc3d/"></span> </span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>32k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>53 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p><a href="/posts/9fa3672f/">上篇</a>分析了SQL逻辑执行计划的生成，本篇将继续分析逻辑计划是如何在进行调度的。</p><span id="more"></span><h1 id="查询调度">查询调度</h1><p>首先回顾下调度的入口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">try</span> (<span class="type">SetThreadName</span> <span class="variable">ignored</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SetThreadName</span>(<span class="string">&quot;Query-%s&quot;</span>, stateMachine.getQueryId())) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!stateMachine.transitionToPlanning()) &#123;</span><br><span class="line">          <span class="comment">// query already started or finished</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ... ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 生成逻辑执行计划</span></span><br><span class="line">          <span class="type">PlanRoot</span> <span class="variable">plan</span> <span class="operator">=</span> planQuery();</span><br><span class="line">          registerDynamicFilteringQuery(plan);</span><br><span class="line">          <span class="comment">// 构建查询调度器</span></span><br><span class="line">          planDistribution(plan);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">          ... ... </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化 Query对应的TableExecuteContext</span></span><br><span class="line">        tableExecuteContextManager.registerTableExecuteContextForQuery(getQueryId());</span><br><span class="line">        <span class="keyword">if</span> (!stateMachine.transitionToStarting()) &#123;</span><br><span class="line">          <span class="comment">// query already started or finished</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if query is not finished, start the scheduler, otherwise cancel it</span></span><br><span class="line">        <span class="type">QueryScheduler</span> <span class="variable">scheduler</span> <span class="operator">=</span> queryScheduler.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!stateMachine.isDone()) &#123;</span><br><span class="line">          scheduler.start(); <span class="comment">// 启动调度器</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        fail(e);</span><br><span class="line">        throwIfInstanceOf(e, Error.class);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构建查询调度器">构建查询调度器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//io.trino.execution.SqlQueryExecution</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">planDistribution</span><span class="params">(PlanRoot plan)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// if query was canceled, skip creating scheduler</span></span><br><span class="line">  <span class="keyword">if</span> (stateMachine.isDone()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// record output field</span></span><br><span class="line">  <span class="type">PlanFragment</span> <span class="variable">rootFragment</span> <span class="operator">=</span> plan.getRoot().getFragment();</span><br><span class="line">  stateMachine.setColumns(</span><br><span class="line">    ((OutputNode) rootFragment.getRoot()).getColumnNames(),</span><br><span class="line">    rootFragment.getTypes());</span><br><span class="line">  <span class="comment">// 获取重试策略，Query 表示重试整个Query，Task表示只重试部分Task</span></span><br><span class="line">  <span class="type">RetryPolicy</span> <span class="variable">retryPolicy</span> <span class="operator">=</span> getRetryPolicy(getSession());</span><br><span class="line">  QueryScheduler scheduler;</span><br><span class="line">  <span class="keyword">switch</span> (retryPolicy) &#123;</span><br><span class="line">    <span class="keyword">case</span> QUERY:</span><br><span class="line">    <span class="keyword">case</span> NONE:</span><br><span class="line">      scheduler = <span class="keyword">new</span> <span class="title class_">PipelinedQueryScheduler</span>(</span><br><span class="line">                        stateMachine,</span><br><span class="line">                        plan.getRoot(),</span><br><span class="line">                        nodePartitioningManager,</span><br><span class="line">                        nodeScheduler,</span><br><span class="line">                        remoteTaskFactory,</span><br><span class="line">                        plan.isSummarizeTaskInfos(),</span><br><span class="line">                        scheduleSplitBatchSize,</span><br><span class="line">                        queryExecutor,</span><br><span class="line">                        schedulerExecutor,</span><br><span class="line">                        failureDetector,</span><br><span class="line">                        nodeTaskMap,</span><br><span class="line">                        executionPolicy,</span><br><span class="line">                        schedulerStats,</span><br><span class="line">                        dynamicFilterService,</span><br><span class="line">                        tableExecuteContextManager,</span><br><span class="line">                        plannerContext.getMetadata(),</span><br><span class="line">                        splitSourceFactory,</span><br><span class="line">                        coordinatorTaskManager);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TASK:</span><br><span class="line">      <span class="keyword">if</span> (isFaultTolerantExecutionEventDriverSchedulerEnabled(stateMachine.getSession())) &#123;</span><br><span class="line">        scheduler = <span class="keyword">new</span> <span class="title class_">EventDrivenFaultTolerantQueryScheduler</span>(... ...);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        scheduler = <span class="keyword">new</span> <span class="title class_">FaultTolerantQueryScheduler</span>(... ...)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unexpected retry policy: &quot;</span> + retryPolicy);</span><br><span class="line">    &#125;</span><br><span class="line">      queryScheduler.set(scheduler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="QueryScheduler">QueryScheduler</h2><p>QueryScheduler是Trino中的查询调度器，其定义如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">QueryScheduler</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">// 开始调度</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>; </span><br><span class="line">    <span class="comment">// 终止Stage</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">cancelStage</span><span class="params">(StageId stageId)</span>; </span><br><span class="line">    <span class="comment">// 将Task设置为失败</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">failTask</span><span class="params">(TaskId taskId, Throwable failureCause)</span>; </span><br><span class="line">    <span class="comment">// 获取基本的Stage统计信息</span></span><br><span class="line">    BasicStageStats <span class="title function_">getBasicStageStats</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 获取Stage信息</span></span><br><span class="line">    StageInfo <span class="title function_">getStageInfo</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 获取查询使用的内存</span></span><br><span class="line">    <span class="type">long</span> <span class="title function_">getUserMemoryReservation</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 整体内存的使用，包含 userMemory和RevocableMemory(可撤销内存)</span></span><br><span class="line">    <span class="type">long</span> <span class="title function_">getTotalMemoryReservation</span><span class="params">()</span>; </span><br><span class="line">    <span class="comment">// 获取整体CPU使用</span></span><br><span class="line">    Duration <span class="title function_">getTotalCpuTime</span><span class="params">()</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调度器将分段好的逻辑执行计划转化为分布式物理stage，然后用于执行。</p><pre class="mermaid">flowchart LR
  SubPlan--&gt;|QueryScheduler|SqlStage
  SqlStage--&gt;|QueryScheduler|StageExecution</pre><h2 id="NodeScheduler">NodeScheduler</h2><p>NodeScheduler是节点调度器，用于为各个Stage的task分配执行节点。在前面的<a href="/posts/4aaf9f12/#task">架构overview</a>一文中有介绍，Task是执行计划的最小组成。一个stage对应一个或多个Task。</p><p>NodeScheduler内部有NodeSelectorFactory，并对外提供createNodeSelector方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> NodeSelector <span class="title function_">createNodeSelector</span><span class="params">(Session session, Optional&lt;CatalogHandle&gt; catalogHandle)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> nodeSelectorFactory.createNodeSelector(requireNonNull(session, <span class="string">&quot;session is null&quot;</span>), requireNonNull(catalogHandle, <span class="string">&quot;catalogHandle is null&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NodeSelector">NodeSelector</h3><p>NodeSelector提供了对应节点的分配算法.有两个实现类:</p><ul><li>TopologyAwareNodeSelector: 基于网络拓扑距离的选择器<ul><li>如果split不能任意调度，那么会从split返回的节点中选择</li><li>对于可以任意调度的split，根据split的节点和NetworkPath获取节点列表。</li><li>根据Node上所有Split权重，或是Node上排队Split的权重平衡选择节点。</li><li>如果仍然没有找到，那么返回等待split空间的Future。</li></ul></li><li>UniformNodeSelector: 默认的均衡选择器<ul><li>如果开启了本地调度优化尽量将split放在本地节点上，否则(无法任意调度的split只能从自己返回的节点中选择)随机选取若干节点(count&gt;=minCandidates)</li><li>每次选取有最小权重的Node。即尽量使不同Node上所有Split权重的平衡，或是不同Node上排队Split的权重平衡(默认策略)。</li><li>如果仍然没有找到，那么返回等待split空间的Future。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//io.trino.execution.scheduler.NodeSelector</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">NodeSelector</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lockDownNodes</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;InternalNode&gt; <span class="title function_">allNodes</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    InternalNode <span class="title function_">selectCurrentNode</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> List&lt;InternalNode&gt; <span class="title function_">selectRandomNodes</span><span class="params">(<span class="type">int</span> limit)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> selectRandomNodes(limit, ImmutableSet.of());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;InternalNode&gt; <span class="title function_">selectRandomNodes</span><span class="params">(<span class="type">int</span> limit, Set&lt;InternalNode&gt; excludedNodes)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配算法</span></span><br><span class="line">    SplitPlacementResult <span class="title function_">computeAssignments</span><span class="params">(Set&lt;Split&gt; splits, List&lt;RemoteTask&gt; existingTasks)</span>;</span><br><span class="line">    <span class="comment">// 通过预先分配好的BucketNodeMap，选择节点。如果仍然没有找到，那么返回等待split空间的Future。</span></span><br><span class="line">    <span class="comment">// split -&gt; bucket -&gt; node </span></span><br><span class="line">    SplitPlacementResult <span class="title function_">computeAssignments</span><span class="params">(Set&lt;Split&gt; splits, List&lt;RemoteTask&gt; existingTasks, BucketNodeMap bucketNodeMap)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="NodePartitioningManager">NodePartitioningManager</h2><p>NodePartitioningManager#getNodePartitioningMap提供了基于分区和节点的映射关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NodePartitionMap</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Partition-&gt;Node</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;InternalNode&gt; partitionToNode;</span><br><span class="line">    <span class="comment">// Bucket -&gt; Partition</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span>[] bucketToPartition;</span><br><span class="line">    <span class="comment">// Split-&gt;Bucket</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ToIntFunction&lt;Split&gt; splitToBucket;</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="keyword">public</span> InternalNode <span class="title function_">getNode</span><span class="params">(Split split)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">bucket</span> <span class="operator">=</span> splitToBucket.applyAsInt(split);</span><br><span class="line">        <span class="type">int</span> <span class="variable">partition</span> <span class="operator">=</span> bucketToPartition[bucket];</span><br><span class="line">        <span class="keyword">return</span> requireNonNull(partitionToNode.get(partition));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// bucket -&gt; node</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ConnectorBucketNodeMap</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> bucketCount;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Optional&lt;List&lt;Node&gt;&gt; bucketToNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getNodePartitionMap的具体逻辑如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> NodePartitionMap <span class="title function_">getNodePartitioningMap</span><span class="params">(</span></span><br><span class="line"><span class="params">            Session session,</span></span><br><span class="line"><span class="params">            PartitioningHandle partitioningHandle,</span></span><br><span class="line"><span class="params">            Map&lt;Integer, List&lt;InternalNode&gt;&gt; bucketToNodeCache,</span></span><br><span class="line"><span class="params">            AtomicReference&lt;List&lt;InternalNode&gt;&gt; systemPartitioningCache)</span></span><br><span class="line">&#123;</span><br><span class="line">    requireNonNull(session, <span class="string">&quot;session is null&quot;</span>);</span><br><span class="line">    requireNonNull(partitioningHandle, <span class="string">&quot;partitioningHandle is null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (partitioningHandle.getConnectorHandle() <span class="keyword">instanceof</span> SystemPartitioningHandle) &#123;</span><br><span class="line">        <span class="comment">// 如果是系统分区Handle</span></span><br><span class="line">        <span class="keyword">return</span> systemNodePartitionMap(session, partitioningHandle, systemPartitioningCache);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (partitioningHandle.getConnectorHandle() <span class="keyword">instanceof</span> MergePartitioningHandle mergeHandle) &#123;</span><br><span class="line">        <span class="comment">// 如果是merge 分区Handle，递归调用</span></span><br><span class="line">        <span class="keyword">return</span> mergeHandle.getNodePartitioningMap(handle -&gt; getNodePartitioningMap(session, handle, bucketToNodeCache, systemPartitioningCache));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不是Trino提供的分区Handle，那就是Connector提供的。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取 分桶到节点的映射关系</span></span><br><span class="line">    Optional&lt;ConnectorBucketNodeMap&gt; optionalMap = getConnectorBucketNodeMap(session, partitioningHandle);</span><br><span class="line">    <span class="keyword">if</span> (optionalMap.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 如果connector没有提供 分桶到节点的映射关系, 使用FIXED_HASH_DISTRIBUTION分区方案</span></span><br><span class="line">        <span class="keyword">return</span> systemNodePartitionMap(session, FIXED_HASH_DISTRIBUTION, systemPartitioningCache);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ConnectorBucketNodeMap</span> <span class="variable">connectorBucketNodeMap</span> <span class="operator">=</span> optionalMap.get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// safety check for crazy partitioning，太多分桶异常</span></span><br><span class="line">    checkArgument(connectorBucketNodeMap.getBucketCount() &lt; <span class="number">1_000_000</span>, <span class="string">&quot;Too many buckets in partitioning: %s&quot;</span>, connectorBucketNodeMap.getBucketCount());</span><br><span class="line"></span><br><span class="line">    List&lt;InternalNode&gt; bucketToNode;</span><br><span class="line">    <span class="keyword">if</span> (connectorBucketNodeMap.hasFixedMapping()) &#123;</span><br><span class="line">        <span class="comment">// hasFixedMapping,那么 bucketToNode不为空，已经存在了Bucket到Node的预分配关系</span></span><br><span class="line">        bucketToNode = getFixedMapping(connectorBucketNodeMap);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">CatalogHandle</span> <span class="variable">catalogHandle</span> <span class="operator">=</span> requiredCatalogHandle(partitioningHandle);</span><br><span class="line">        <span class="comment">// 在对应的bucket的index处放入Node节点。</span></span><br><span class="line">        <span class="comment">// createArbitraryBucketToNode中将NodeList洗牌，然后循环分配个每个bucket。</span></span><br><span class="line">        bucketToNode = bucketToNodeCache.computeIfAbsent(</span><br><span class="line">                connectorBucketNodeMap.getBucketCount(),</span><br><span class="line">                bucketCount -&gt; createArbitraryBucketToNode(getAllNodes(session, catalogHandle), bucketCount));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 基于bucket-&gt; node.生成 node -&gt; partition和bucket -&gt; partition</span></span><br><span class="line">    <span class="type">int</span>[] bucketToPartition = <span class="keyword">new</span> <span class="title class_">int</span>[connectorBucketNodeMap.getBucketCount()];</span><br><span class="line">    BiMap&lt;InternalNode, Integer&gt; nodeToPartition = HashBiMap.create();</span><br><span class="line">    <span class="type">int</span> <span class="variable">nextPartitionId</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">bucket</span> <span class="operator">=</span> <span class="number">0</span>; bucket &lt; bucketToNode.size(); bucket++) &#123;</span><br><span class="line">        <span class="type">InternalNode</span> <span class="variable">node</span> <span class="operator">=</span> bucketToNode.get(bucket);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">partitionId</span> <span class="operator">=</span> nodeToPartition.get(node);</span><br><span class="line">        <span class="keyword">if</span> (partitionId == <span class="literal">null</span>) &#123;</span><br><span class="line">            partitionId = nextPartitionId;</span><br><span class="line">            nextPartitionId++;</span><br><span class="line">            nodeToPartition.put(node, partitionId);</span><br><span class="line">        &#125;</span><br><span class="line">        bucketToPartition[bucket] = partitionId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将Map映射转化为数组映射</span></span><br><span class="line">    List&lt;InternalNode&gt; partitionToNode = IntStream.range(<span class="number">0</span>, nodeToPartition.size())</span><br><span class="line">            .mapToObj(partitionId -&gt; nodeToPartition.inverse().get(partitionId))</span><br><span class="line">            .collect(toImmutableList());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NodePartitionMap</span>(partitionToNode, bucketToPartition, getSplitToBucket(session, partitioningHandle));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 系统分区的处理</span></span><br><span class="line"><span class="keyword">private</span> NodePartitionMap <span class="title function_">systemNodePartitionMap</span><span class="params">(Session session, PartitioningHandle partitioningHandle, AtomicReference&lt;List&lt;InternalNode&gt;&gt; nodesCache)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">SystemPartitioning</span> <span class="variable">partitioning</span> <span class="operator">=</span> ((SystemPartitioningHandle) partitioningHandle.getConnectorHandle()).getPartitioning();</span><br><span class="line"></span><br><span class="line">    <span class="type">NodeSelector</span> <span class="variable">nodeSelector</span> <span class="operator">=</span> nodeScheduler.createNodeSelector(session, Optional.empty());</span><br><span class="line"></span><br><span class="line">    List&lt;InternalNode&gt; nodes = <span class="keyword">switch</span> (partitioning) &#123;</span><br><span class="line">        <span class="keyword">case</span> COORDINATOR_ONLY -&gt; ImmutableList.of(nodeSelector.selectCurrentNode()); </span><br><span class="line">        <span class="comment">// currentNode，就是COORDINATOR</span></span><br><span class="line">        <span class="keyword">case</span> SINGLE -&gt; nodeSelector.selectRandomNodes(<span class="number">1</span>); </span><br><span class="line">        <span class="comment">// 随机选择一个</span></span><br><span class="line">        <span class="keyword">case</span> FIXED -&gt; &#123;</span><br><span class="line">            List&lt;InternalNode&gt; value = nodesCache.get();</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 根据Session配置，随机选取若干节点</span></span><br><span class="line">                value = nodeSelector.selectRandomNodes(getHashPartitionCount(session));</span><br><span class="line">                nodesCache.set(value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">yield</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span> -&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unsupported plan distribution &quot;</span> + partitioning);</span><br><span class="line">    &#125;;</span><br><span class="line">    checkCondition(!nodes.isEmpty(), NO_NODES_AVAILABLE, <span class="string">&quot;No worker nodes available&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NodePartitionMap</span>(nodes, split -&gt; &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;System distribution does not support source splits&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，对于SOURCE_DISTRIBUTION和SCALED_WRITER_ROUND_ROBIN_DISTRIBUTION，并不是通过NodePartitioningManager处理。而是通过StageScheduler的实现类进行处理。</p><h1 id="PipelinedQueryScheduler">PipelinedQueryScheduler</h1><p>由于默认的RetryPolicy是NONE，按照上面构建查询调度器的逻辑，会构建PipelinedQueryScheduler。</p><p>PipelinedQueryScheduler会在初始化的时候通过StageManager将SubPlan生成SqlStage。其中SqlStage会被分为两类</p><ul><li>coordinatorStage</li><li>distributedStage</li></ul><p>这两类Stage会分别由CoordinatorStagesScheduler和DistributedStagesScheduler 调度。</p><p>调度流程如下:</p><pre class="mermaid">sequenceDiagram
  PipelinedQueryScheduler-&gt;&gt;PipelinedQueryScheduler: 对象初始化
  PipelinedQueryScheduler-&gt;&gt;+StageManager:create
  loop every Subplan
    StageManager-&gt;&gt;StageManager:createSqlStage
    StageManager-&gt;&gt;StageManager: 分为coordinatorStage和distributedStage
  end
  StageManager-&gt;&gt;-PipelinedQueryScheduler: return StageManager
  PipelinedQueryScheduler-&gt;&gt;+CoordinatorStagesScheduler: create
  loop every coordinatorStage
    CoordinatorStagesScheduler -&gt;&gt; CoordinatorStagesScheduler: createPipelinedStageExecution
    CoordinatorStagesScheduler-&gt;&gt;PipelinedStageExecution: initialize
    PipelinedStageExecution -&gt;&gt; CoordinatorStagesScheduler: return PipelinedStageExecution
  end
  CoordinatorStagesScheduler-&gt;&gt;CoordinatorStagesScheduler: initialize,为stageExecution添加listener
  CoordinatorStagesScheduler -&gt;&gt;-PipelinedQueryScheduler: return CoordinatorStagesScheduler
  PipelinedQueryScheduler-&gt;&gt;PipelinedQueryScheduler: start
  PipelinedQueryScheduler -&gt;&gt; DistributedStagesScheduler: create
  loop every distributedStage
    DistributedStagesScheduler -&gt;&gt; DistributedStagesScheduler: createPipelinedStageExecution
    DistributedStagesScheduler-&gt;&gt;PipelinedStageExecution: initialize
    PipelinedStageExecution -&gt;&gt; DistributedStagesScheduler: return PipelinedStageExecution
  end
  loop every StageExecution
    DistributedStagesScheduler -&gt;&gt; StageScheduler: createStageScheduler
    StageScheduler-&gt;&gt;DistributedStagesScheduler: return StageScheduler
  end
  DistributedStagesScheduler -&gt;&gt;PipelinedQueryScheduler: return DistributedStagesScheduler
  PipelinedQueryScheduler -&gt;&gt;+ CoordinatorStagesScheduler: schedule
  CoordinatorStagesScheduler-&gt;&gt;- PipelinedQueryScheduler: return
  PipelinedQueryScheduler -&gt;&gt;+ DistributedStagesScheduler: schedule(Async)
  DistributedStagesScheduler -&gt;&gt;- PipelinedQueryScheduler: return</pre><h2 id="生成SqlStage">生成SqlStage</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//io.trino.execution.scheduler.StageManager</span></span><br><span class="line"><span class="keyword">static</span> StageManager <span class="title function_">create</span><span class="params">(... ...)</span></span><br><span class="line">&#123;</span><br><span class="line">  ... ...</span><br><span class="line">  <span class="comment">// 广度优先遍历</span></span><br><span class="line">  <span class="keyword">for</span> (SubPlan planNode : Traverser.forTree(SubPlan::getChildren).breadthFirst(planTree)) &#123;</span><br><span class="line">    <span class="type">PlanFragment</span> <span class="variable">fragment</span> <span class="operator">=</span> planNode.getFragment();</span><br><span class="line">    <span class="comment">// 构建SqlStage</span></span><br><span class="line">    <span class="type">SqlStage</span> <span class="variable">stage</span> <span class="operator">=</span> createSqlStage(</span><br><span class="line">              getStageId(session.getQueryId(), fragment.getId()),</span><br><span class="line">              fragment,</span><br><span class="line">              TableInfo.extract(session, metadata, fragment),</span><br><span class="line">              taskFactory,</span><br><span class="line">              session,</span><br><span class="line">              summarizeTaskInfo,</span><br><span class="line">              nodeTaskMap,</span><br><span class="line">              executor,</span><br><span class="line">              schedulerStats);</span><br><span class="line">    <span class="type">StageId</span> <span class="variable">stageId</span> <span class="operator">=</span> stage.getStageId();</span><br><span class="line">    stages.put(stageId, stage);</span><br><span class="line">    <span class="comment">// 拓扑排序</span></span><br><span class="line">    stagesInTopologicalOrder.add(stage);</span><br><span class="line">    <span class="keyword">if</span> (fragment.getPartitioning().isCoordinatorOnly()) &#123;</span><br><span class="line">      <span class="comment">// 在coordinator上调度的plan</span></span><br><span class="line">      <span class="comment">// 内部判断逻辑是SystemPartitioning类型是否是COORDINATOR_ONLY</span></span><br><span class="line">      <span class="comment">// 在前文提到的PlanFragmenter.Fragmenter中会将一些fragment属性设置为CoordinatorOnlyDistribution</span></span><br><span class="line">      coordinatorStagesInTopologicalOrder.add(stage);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 分布式调度节点</span></span><br><span class="line">      distributedStagesInTopologicalOrder.add(stage);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rootStageId == <span class="literal">null</span>) &#123;</span><br><span class="line">      rootStageId = stageId; <span class="comment">// 设置root stage</span></span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;StageId&gt; childStageIds = planNode.getChildren().stream()</span><br><span class="line">      .map(childStage -&gt; getStageId(session.getQueryId(), childStage.getFragment().getId()))</span><br><span class="line">      .collect(toImmutableSet());</span><br><span class="line">    children.put(stageId, childStageIds);</span><br><span class="line">    <span class="comment">// 存储Stage的子-父映射关系</span></span><br><span class="line">    childStageIds.forEach(child -&gt; parents.put(child, stageId));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">StageManager</span> <span class="variable">stageManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StageManager</span>(... ...);</span><br><span class="line">  <span class="keyword">return</span> stageManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从Subplan创建SqlStage">从Subplan创建SqlStage</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//io.trino.execution.scheduler.StageManager</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SqlStage <span class="title function_">createSqlStage</span><span class="params">(... ...)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// validate params</span></span><br><span class="line">  ... ... </span><br><span class="line"></span><br><span class="line">  <span class="type">SqlStage</span> <span class="variable">sqlStage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlStage</span>(</span><br><span class="line">          session,</span><br><span class="line">          <span class="comment">// 开始Stage状态机，状态:io.trino.execution.StageState</span></span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">StageStateMachine</span>(stageId, fragment, tables, executor, schedulerStats),</span><br><span class="line">          remoteTaskFactory,</span><br><span class="line">          nodeTaskMap,</span><br><span class="line">          summarizeTaskInfo);</span><br><span class="line">  sqlStage.initialize();</span><br><span class="line">  <span class="keyword">return</span> sqlStage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从SqlStage创建StageExecution">从SqlStage创建StageExecution</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//io.trino.execution.scheduler.PipelinedStageExecution</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> PipelinedStageExecution <span class="title function_">createPipelinedStageExecution</span><span class="params">(</span></span><br><span class="line"><span class="params">        SqlStage stage,</span></span><br><span class="line"><span class="params">        Map&lt;PlanFragmentId, PipelinedOutputBufferManager&gt; outputBufferManagers,</span></span><br><span class="line"><span class="params">        TaskLifecycleListener taskLifecycleListener,</span></span><br><span class="line"><span class="params">        FailureDetector failureDetector,</span></span><br><span class="line"><span class="params">        Executor executor,</span></span><br><span class="line"><span class="params">        Optional&lt;<span class="type">int</span>[]&gt; bucketToPartition,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> attempt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">PipelinedStageStateMachine</span> <span class="variable">stateMachine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PipelinedStageStateMachine</span>(stage.getStageId(), executor);</span><br><span class="line">    ImmutableMap.Builder&lt;PlanFragmentId, RemoteSourceNode&gt; exchangeSources = ImmutableMap.builder();</span><br><span class="line">    <span class="keyword">for</span> (RemoteSourceNode remoteSourceNode : stage.getFragment().getRemoteSourceNodes()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (PlanFragmentId planFragmentId : remoteSourceNode.getSourceFragmentIds()) &#123;</span><br><span class="line">            exchangeSources.put(planFragmentId, remoteSourceNode); </span><br><span class="line">            <span class="comment">// 记录执行计划中的远程输入节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">PipelinedStageExecution</span> <span class="variable">execution</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PipelinedStageExecution</span>(</span><br><span class="line">            stateMachine,</span><br><span class="line">            stage,</span><br><span class="line">            outputBufferManagers,</span><br><span class="line">            taskLifecycleListener,</span><br><span class="line">            failureDetector,</span><br><span class="line">            bucketToPartition,</span><br><span class="line">            exchangeSources.buildOrThrow(),</span><br><span class="line">            attempt);</span><br><span class="line">    execution.initialize();</span><br><span class="line">    <span class="keyword">return</span> execution;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="coordinatorStage-调度">coordinatorStage 调度</h2><p>coordinatorStage是在 coordinator上执行的Stage。 例如，使用 <code>EXPLAIN ANALYZE</code>命令时,coordinatorStage结构如下图所示。</p><pre class="mermaid">flowchart LR
    subgraph coordinatorStage
    subgraph planFragment
        OutputNode0(OutputNode)--&gt;|source|ExplainAnalyzedNode0(ExplainAnalyzedNode)
        ExplainAnalyzedNode0--&gt;|source|ExchangeNode0(ExchangeNode0)
        ExchangeNode0--&gt;|source|RemoteSourceNode01(RemoteSourceNode)
    end
    end</pre><p>coordinatorStage处理流程如下:</p><ul><li>coordinatorStage是COORDINATOR_ONLY分区的Stage。</li><li>在create CoordinatorStagesScheduler时会从SqlStage构建StageExecution</li><li>在CoordinatorStagesScheduler初始化(initialize)的时候会给StageExecution设置listener<ul><li>给每个StageExecution设置自己的状态Listener</li><li>每个StageExecution done时，终止其child StageExecution</li><li>root(first) StageExecution状态变化时，同步到QueryState</li><li>last StageExecution结束时，终止distributedStagesScheduler</li></ul></li><li>CoordinatorStagesScheduler 执行schedule方法时会执行StageExecution#scheduleTask方法，创建RemoteTask用于执行。</li></ul><h2 id="distributedStage">distributedStage</h2><p>distributedStage是指不在 coordinator上执行的Stage，其处理流程如下:</p><ul><li>distributedStage是非COORDINATOR_ONLY分区的Stage。</li><li>在create DistributedStagesScheduler时会从SqlStage构建StageExecution</li><li>构建StageExecution完成后，会为每个Stage和其children构建StageScheduler用于Stage调度。</li><li>在DistributedStagesScheduler初始化(initialize)的时候会给StageExecution设置listener<ul><li>给每个StageExecution设置自己的状态Listener</li><li>每个StageExecution done时，终止其child StageExecution</li></ul></li><li>DistributedStagesScheduler执行schedule方法时<ul><li>启动所有的StageScheduler</li><li>根据执行调度策略循环获取可以执行的StageExecution和对应的StageScheduler，直到所有StageExecution均完成。<ul><li>使用StageScheduler执行schedule</li><li>如果有blockedStage，且原因是WRITER_SCALING，WAITING_FOR_SOURCE和SPLIT_QUEUES_FULL加入列表，否则抛出异常</li><li>对于所有的blockedStage，等待1s，对所有blockedStage调用cancel方法(google AbstractFuture该方法默认是donothing)。</li></ul></li></ul></li></ul><h2 id="ExecutionSchedule">ExecutionSchedule</h2><p>ExecutionSchedule 是指StageExecution的调度策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ExecutionSchedule</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取用于调度的stage</span></span><br><span class="line">    StagesScheduleResult <span class="title function_">getStagesToSchedule</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isFinished</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ExecutionSchedule有两个实现类。</p><ul><li>AllAtOnceExecutionSchedule: 每次返回所有可以调度的StageExecution</li><li>PhasedExecutionSchedule: 默认调度模式，根据StageExecution的依赖顺序返回可以执行的stage，防止由于stage间的依赖造成的阻塞。</li></ul><p>对于带join的查询:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">    t.<span class="operator">*</span>,n.<span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    system.runtime.tasks t</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> </span><br><span class="line">    system.runtime.nodes n</span><br><span class="line"><span class="keyword">on</span> </span><br><span class="line">    t.node_id <span class="operator">=</span> n.node_id</span><br><span class="line"><span class="keyword">where</span> </span><br><span class="line">    t.state <span class="operator">=</span> <span class="string">&#x27;FINISHED&#x27;</span></span><br></pre></td></tr></table></figure><p>生成的查询结构如下:</p><pre class="mermaid">flowchart
    subgraph stage0
    subgraph planFragment0
        OutputNode0(OutputNode)--&gt;|source|JoinNode0(JoinNode)
        JoinNode0--&gt;|left source|RemoteSourceNode0(RemoteSourceNode)
        JoinNode0--&gt;|right source|ExchangeNode0(ExchangeNode0)
        ExchangeNode0--&gt;|source|RemoteSourceNode01(RemoteSourceNode)
    end
    end
    subgraph stage1
    subgraph planFragment1
        ProjectNode1(ProjectNode)--&gt;|source|FilterNode1(FilterNode)
        FilterNode1--&gt;|source|TableScanNode1(TableScanNode,system.runtime.tasks)
    end
    end
    subgraph stage2
    subgraph planFragment2
        ProjectNode2(ProjectNode)--&gt;|source|TableScanNode2(TableScanNode,system.runtime.nodes)
    end
    end
    RemoteSourceNode0-.-&gt;ProjectNode1
    RemoteSourceNode01-.-&gt;ProjectNode2</pre><p>PhasedExecutionSchedule会计算出以下依赖关系</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dependency</span></span><br><span class="line">Fragment2 -&gt; Fragment1 <span class="comment"># 1依赖于2</span></span><br></pre></td></tr></table></figure><p>Trino中会将join执行分为构建侧和探针侧，其中构建侧是小表(Trino中的右表)，会加载到内存中，探针侧是大表，用于遍历。所以会存在隐式依赖关系，构建侧的Stage和其上游任务需要在探针侧Stage前调度。所以有了上面的依赖关系。</p><p>由于依赖关系的存在，首次调度的stage将是 stage0和stage2。</p><h2 id="StageScheduler">StageScheduler</h2><p>从上面的distributedStage处理流程可以知道，最终StageExecution的调度是通过StageScheduler来进行调度的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StageScheduler</span></span><br><span class="line">        <span class="keyword">extends</span> <span class="title class_">Closeable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Called by the query scheduler when the scheduling process begins.</span></span><br><span class="line"><span class="comment">     * This method is called before the ExecutionSchedule takes a decision</span></span><br><span class="line"><span class="comment">     * to schedule a stage but after the query scheduling has been fully initialized.</span></span><br><span class="line"><span class="comment">     * Within this method the scheduler may decide to schedule tasks that</span></span><br><span class="line"><span class="comment">     * are necessary for query execution to make progress.</span></span><br><span class="line"><span class="comment">     * For example the scheduler may decide to schedule a task without</span></span><br><span class="line"><span class="comment">     * assigning any splits to unblock dynamic filter collection.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Schedules as much work as possible without blocking.</span></span><br><span class="line"><span class="comment">     * The schedule results is a hint to the query scheduler if and</span></span><br><span class="line"><span class="comment">     * when the stage scheduler should be invoked again.  It is</span></span><br><span class="line"><span class="comment">     * important to note that this is only a hint and the query</span></span><br><span class="line"><span class="comment">     * scheduler may call the schedule method at any time.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ScheduleResult <span class="title function_">schedule</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StageScheduler的实现有4个:</p><ul><li>newSourcePartitionedSchedulerAsStageScheduler中的内部类: 如果分区格式是SOURCE_DISTRIBUTION使用这种调度器</li><li>ScaledWriterScheduler: 如果分区格式是SCALED_WRITER_ROUND_ROBIN_DISTRIBUTION，使用这种调度器</li><li>FixedCountScheduler: 如果没有本地Source，都是remote Source，使用这种调度器</li><li>FixedSourcePartitionedScheduler: 如果有本地Source，使用这种调度器。</li></ul><blockquote><p>FixedCountScheduler和FixedSourcePartitionedScheduler会使用上面提到的NodePartitioningManager进行分区设置。</p></blockquote><p>我们先来看看FixedCountScheduler。</p><h3 id="FixedCountScheduler">FixedCountScheduler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FixedCountScheduler</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">StageScheduler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TaskScheduler</span></span><br><span class="line">    &#123;</span><br><span class="line">        Optional&lt;RemoteTask&gt; <span class="title function_">scheduleTask</span><span class="params">(InternalNode node, <span class="type">int</span> partition)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TaskScheduler taskScheduler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;InternalNode&gt; partitionToNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FixedCountScheduler</span><span class="params">(StageExecution stageExecution, List&lt;InternalNode&gt; partitionToNode)</span></span><br><span class="line">    &#123;</span><br><span class="line">        requireNonNull(stageExecution, <span class="string">&quot;stage is null&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.taskScheduler = (node, partition) -&gt; stageExecution.scheduleTask(node, partition, ImmutableMultimap.of());</span><br><span class="line">        <span class="built_in">this</span>.partitionToNode = requireNonNull(partitionToNode, <span class="string">&quot;partitionToNode is null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ScheduleResult <span class="title function_">schedule</span><span class="params">()</span></span><br><span class="line">    &#123;   <span class="comment">// 对每个分区，通过 stageExecution.scheduleTask 启动一个TASK.</span></span><br><span class="line">        List&lt;RemoteTask&gt; newTasks = IntStream.range(<span class="number">0</span>, partitionToNode.size())</span><br><span class="line">                .mapToObj(partition -&gt; taskScheduler.scheduleTask(partitionToNode.get(partition), partition))</span><br><span class="line">                .filter(Optional::isPresent)</span><br><span class="line">                .map(Optional::get)</span><br><span class="line">                .collect(toImmutableList());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduleResult</span>(<span class="literal">true</span>, newTasks, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FixedSourcePartitionedScheduler">FixedSourcePartitionedScheduler</h3><p>FixedSourcePartitionedScheduler是针对有本地Source的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FixedSourcePartitionedScheduler</span><span class="params">(... ...)</span></span><br><span class="line">&#123;</span><br><span class="line">   ... ... </span><br><span class="line"></span><br><span class="line">    <span class="type">BucketedSplitPlacementPolicy</span> <span class="variable">splitPlacementPolicy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BucketedSplitPlacementPolicy</span>(nodeSelector, nodes, bucketNodeMap, stageExecution::getAllTasks);</span><br><span class="line">    <span class="comment">// 注意split的放置策略: BucketedSplitPlacementPolicy</span></span><br><span class="line">    <span class="comment">// public SplitPlacementResult computeAssignments(Set&lt;Split&gt; splits)&#123;</span></span><br><span class="line">    <span class="comment">//   return nodeSelector.computeAssignments(splits, remoteTasks.get(), bucketNodeMap);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    ArrayList&lt;SourceScheduler&gt; sourceSchedulers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    partitionIdAllocator = <span class="keyword">new</span> <span class="title class_">PartitionIdAllocator</span>();</span><br><span class="line">    scheduledTasks = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (PlanNodeId planNodeId : schedulingOrder) &#123;</span><br><span class="line">        <span class="comment">// 对于每个SplitSource 构建一个 SourceScheduler</span></span><br><span class="line">        <span class="type">SplitSource</span> <span class="variable">splitSource</span> <span class="operator">=</span> splitSources.get(planNodeId);</span><br><span class="line">        <span class="comment">// TODO : change anySourceTaskBlocked to accommodate the correct blocked status of source tasks</span></span><br><span class="line">        <span class="comment">//  (ref : https://github.com/trinodb/trino/issues/4713)</span></span><br><span class="line">        <span class="type">SourceScheduler</span> <span class="variable">sourceScheduler</span> <span class="operator">=</span> newSourcePartitionedSchedulerAsSourceScheduler(</span><br><span class="line">                stageExecution,</span><br><span class="line">                planNodeId,</span><br><span class="line">                splitSource,</span><br><span class="line">                splitPlacementPolicy,</span><br><span class="line">                splitBatchSize,</span><br><span class="line">                dynamicFilterService,</span><br><span class="line">                tableExecuteContextManager,</span><br><span class="line">                () -&gt; <span class="literal">true</span>,</span><br><span class="line">                partitionIdAllocator,</span><br><span class="line">                scheduledTasks);</span><br><span class="line"></span><br><span class="line">        sourceSchedulers.add(sourceScheduler);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.sourceSchedulers = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;(sourceSchedulers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果所有的RemoteSource的ExchangeType都是REPLICATE(一般只有小表join时才会有REPLICATE类型的Exchange，即该stage都是本地Source，Trino中小表用于构建)。会根据输入的bucket确定和节点的映射(nodePartitioningManager#getBucketNodeMap)</li><li>否则，对于有remoteSource的会使用nodePartitioningManager#getNodePartitioningMap进行分区。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> ScheduleResult <span class="title function_">schedule</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// schedule a task on every node in the distribution</span></span><br><span class="line">    List&lt;RemoteTask&gt; newTasks = ImmutableList.of();</span><br><span class="line">    <span class="keyword">if</span> (scheduledTasks.isEmpty()) &#123;</span><br><span class="line">        ImmutableList.Builder&lt;RemoteTask&gt; newTasksBuilder = ImmutableList.builder();</span><br><span class="line">        <span class="keyword">for</span> (InternalNode node : nodes) &#123; <span class="comment">// nodes partition -&gt; node</span></span><br><span class="line">            <span class="comment">// 此处调度TASK</span></span><br><span class="line">            Optional&lt;RemoteTask&gt; task = stageExecution.scheduleTask(node, partitionIdAllocator.getNextId(), ImmutableMultimap.of());</span><br><span class="line">            <span class="keyword">if</span> (task.isPresent()) &#123;</span><br><span class="line">                scheduledTasks.put(node, task.get());</span><br><span class="line">                newTasksBuilder.add(task.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        newTasks = newTasksBuilder.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListenableFuture&lt;Void&gt; blocked = immediateFuture(<span class="literal">null</span>);</span><br><span class="line">    ScheduleResult.<span class="type">BlockedReason</span> <span class="variable">blockedReason</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">splitsScheduled</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!sourceSchedulers.isEmpty()) &#123;</span><br><span class="line">        <span class="type">SourceScheduler</span> <span class="variable">scheduler</span> <span class="operator">=</span> sourceSchedulers.peek();</span><br><span class="line">        <span class="comment">// 调度Source</span></span><br><span class="line">        <span class="type">ScheduleResult</span> <span class="variable">schedule</span> <span class="operator">=</span> scheduler.schedule();</span><br><span class="line">        splitsScheduled += schedule.getSplitsScheduled();</span><br><span class="line">        blocked = schedule.getBlocked();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (schedule.getBlockedReason().isPresent()) &#123;</span><br><span class="line">            <span class="comment">// 如果有Block记录block原因</span></span><br><span class="line">            blockedReason = schedule.getBlockedReason().get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            blockedReason = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if the source is not done scheduling, stop scheduling for now</span></span><br><span class="line">        <span class="keyword">if</span> (!blocked.isDone() || !schedule.isFinished()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stageExecution.schedulingComplete(scheduler.getPlanNodeId());</span><br><span class="line">        sourceSchedulers.remove().close(); <span class="comment">// 关闭成功的调度器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (blockedReason != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduleResult</span>(sourceSchedulers.isEmpty(), newTasks, blocked, blockedReason, splitsScheduled);</span><br><span class="line">    &#125;</span><br><span class="line">    checkState(blocked.isDone(), <span class="string">&quot;blockedReason not provided when scheduler is blocked&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduleResult</span>(sourceSchedulers.isEmpty(), newTasks, splitsScheduled);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意ScheduleResult返回如果不是finished，那么stageExecution的状态是不会被变到Scheduled。那么在下一次循环时，还是能获取到这个stageExecution</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.trino.execution.scheduler.PipelinedQueryScheduler.DistributedStagesScheduler.schedule</span></span><br><span class="line"><span class="comment">// modify parent and children based on the results of the scheduling</span></span><br><span class="line"><span class="keyword">if</span> (result.isFinished()) &#123;</span><br><span class="line">    stageExecution.schedulingComplete();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// io.trino.execution.scheduler.PipelinedStageExecution</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">schedulingComplete</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!stateMachine.transitionToScheduled()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isStageFlushing()) &#123;</span><br><span class="line">        stateMachine.transitionToFlushing();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isStageFinished()) &#123;</span><br><span class="line">        stateMachine.transitionToFinished();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (PlanNodeId partitionedSource : stage.getFragment().getPartitionedSources()) &#123;</span><br><span class="line">        schedulingComplete(partitionedSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ScaledWriterScheduler">ScaledWriterScheduler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduleResult <span class="title function_">schedule</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;RemoteTask&gt; writers = scheduleTasks(getNewTaskCount());</span><br><span class="line"></span><br><span class="line">    future.set(<span class="literal">null</span>);</span><br><span class="line">    future = SettableFuture.create();</span><br><span class="line">    executor.schedule(() -&gt; future.set(<span class="literal">null</span>), <span class="number">200</span>, MILLISECONDS);</span><br><span class="line">    <span class="comment">// 注意返回finished</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduleResult</span>(done.get(), writers, future, WRITER_SCALING, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 之后返回0或1</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getNewTaskCount</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (scheduledNodes.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> <span class="variable">fullTasks</span> <span class="operator">=</span> sourceTasksProvider.get().stream()</span><br><span class="line">            .filter(task -&gt; !task.getState().isDone())</span><br><span class="line">            .map(TaskStatus::getOutputBufferStatus)</span><br><span class="line">            .map(OutputBufferStatus::isOverutilized)</span><br><span class="line">            .mapToDouble(full -&gt; full ? <span class="number">1.0</span> : <span class="number">0.0</span>)</span><br><span class="line">            .average().orElse(<span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">writtenBytes</span> <span class="operator">=</span> writerTasksProvider.get().stream()</span><br><span class="line">            .map(TaskStatus::getPhysicalWrittenDataSize)</span><br><span class="line">            .mapToLong(DataSize::toBytes)</span><br><span class="line">            .sum();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fullTasks &gt;= <span class="number">0.5</span>) &amp;&amp; (writtenBytes &gt;= (writerMinSizeBytes * maxTaskWriterCount * scheduledNodes.size()))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;RemoteTask&gt; <span class="title function_">scheduleTasks</span><span class="params">(<span class="type">int</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ImmutableList.of();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;InternalNode&gt; nodes = nodeSelector.selectRandomNodes(count, scheduledNodes);</span><br><span class="line"></span><br><span class="line">    checkCondition(!scheduledNodes.isEmpty() || !nodes.isEmpty(), NO_NODES_AVAILABLE, <span class="string">&quot;No nodes available to run query&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ImmutableList.Builder&lt;RemoteTask&gt; tasks = ImmutableList.builder();</span><br><span class="line">    <span class="keyword">for</span> (InternalNode node : nodes) &#123;</span><br><span class="line">        Optional&lt;RemoteTask&gt; remoteTask = stage.scheduleTask(node, scheduledNodes.size(), ImmutableMultimap.of());</span><br><span class="line">        remoteTask.ifPresent(task -&gt; &#123;</span><br><span class="line">            tasks.add(task);</span><br><span class="line">            scheduledNodes.add(node);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tasks.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，写出任务的数量是静态的。启用写出器扩展允许 Presto 动态扩展写出器任务的数量，而不是分配固定数量的任务。当每个写出器的平均物理数据量高于最小阈值时，会添加其他任务，但前提是查询在写出时遇到瓶颈。</p><p>动态添加的原因，也是因为stageExecution未处于scheduled状态，从而会重复进入schedule方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (partitioningHandle.equals(SCALED_WRITER_ROUND_ROBIN_DISTRIBUTION)) &#123;</span><br><span class="line">        Supplier&lt;Collection&lt;TaskStatus&gt;&gt; sourceTasksProvider = () -&gt; childStageExecutions.stream()</span><br><span class="line">        .map(StageExecution::getTaskStatuses)</span><br><span class="line">        .flatMap(List::stream)</span><br><span class="line">        .collect(toImmutableList());</span><br><span class="line">Supplier&lt;Collection&lt;TaskStatus&gt;&gt; writerTasksProvider = stageExecution::getTaskStatuses;</span><br><span class="line"></span><br><span class="line"><span class="type">ScaledWriterScheduler</span> <span class="variable">scheduler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScaledWriterScheduler</span>(</span><br><span class="line">        stageExecution,</span><br><span class="line">        sourceTasksProvider,</span><br><span class="line">        writerTasksProvider,</span><br><span class="line">        nodeScheduler.createNodeSelector(session, Optional.empty()),</span><br><span class="line">        executor,</span><br><span class="line">        getWriterMinSize(session),</span><br><span class="line">        isTaskScaleWritersEnabled(session) ? getTaskScaleWritersMaxWriterCount(session) : getTaskWriterCount(session));</span><br><span class="line"><span class="comment">// 当childStageExecutions都完成时，会触发ScaledWriterScheduler的finish，从而终止ScaledWriterScheduler的多次调度</span></span><br><span class="line">whenAllStages(childStageExecutions, StageExecution.State::isDone)</span><br><span class="line">        .addListener(scheduler::finish, directExecutor());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> scheduler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="newSourcePartitionedSchedulerAsStageScheduler">newSourcePartitionedSchedulerAsStageScheduler</h3><p>newSourcePartitionedSchedulerAsStageScheduler是用于处理SplitSource的调度器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//io.trino.execution.scheduler.SourcePartitionedScheduler</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> StageScheduler <span class="title function_">newSourcePartitionedSchedulerAsStageScheduler</span><span class="params">(</span></span><br><span class="line"><span class="params">            StageExecution stageExecution,</span></span><br><span class="line"><span class="params">            PlanNodeId partitionedNode,</span></span><br><span class="line"><span class="params">            SplitSource splitSource,</span></span><br><span class="line"><span class="params">            SplitPlacementPolicy splitPlacementPolicy,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> splitBatchSize,</span></span><br><span class="line"><span class="params">            DynamicFilterService dynamicFilterService,</span></span><br><span class="line"><span class="params">            TableExecuteContextManager tableExecuteContextManager,</span></span><br><span class="line"><span class="params">            BooleanSupplier anySourceTaskBlocked)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">SourcePartitionedScheduler</span> <span class="variable">sourcePartitionedScheduler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SourcePartitionedScheduler</span>(</span><br><span class="line">            stageExecution,</span><br><span class="line">            partitionedNode,</span><br><span class="line">            splitSource,</span><br><span class="line">            splitPlacementPolicy,</span><br><span class="line">            splitBatchSize,</span><br><span class="line">            dynamicFilterService,</span><br><span class="line">            tableExecuteContextManager,</span><br><span class="line">            anySourceTaskBlocked,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PartitionIdAllocator</span>(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StageScheduler</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span></span><br><span class="line">        &#123;</span><br><span class="line">            sourcePartitionedScheduler.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> ScheduleResult <span class="title function_">schedule</span><span class="params">()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> sourcePartitionedScheduler.schedule();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span></span><br><span class="line">        &#123;</span><br><span class="line">            sourcePartitionedScheduler.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该Stage调度器的调度方法，实际上是调用了SourcePartitionedScheduler实现。SourcePartitionedScheduler的状态有4种:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">enum</span> <span class="title class_">State</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * No splits have been added to pendingSplits set.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    INITIALIZED,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * At least one split has been added to pendingSplits set.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SPLITS_ADDED,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * All splits from underlying SplitSource have been discovered.</span></span><br><span class="line"><span class="comment">     * No more splits will be added to the pendingSplits set.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SPLITS_SCHEDULED,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * All splits have been provided to caller of this scheduler.</span></span><br><span class="line"><span class="comment">     * Cleanup operations are done</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    FINISHED</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SplitSource是支持Split的Source，一般是ConnectorAwareSplitSource，调度器会从SplitSource中获取SplitBatch(表示一批Split)。然后将其中所有的Split加入到pendingSplits。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pendingSplits.isEmpty()) &#123;</span><br><span class="line">    <span class="comment">// try to get the next batch</span></span><br><span class="line">    <span class="keyword">if</span> (nextSplitBatchFuture == <span class="literal">null</span>) &#123;</span><br><span class="line">        nextSplitBatchFuture = splitSource.getNextBatch(splitBatchSize);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        addSuccessCallback(nextSplitBatchFuture, () -&gt; stageExecution.recordGetSplitTime(start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextSplitBatchFuture.isDone()) &#123;</span><br><span class="line">        <span class="type">SplitBatch</span> <span class="variable">nextSplits</span> <span class="operator">=</span> getFutureValue(nextSplitBatchFuture);</span><br><span class="line">        nextSplitBatchFuture = <span class="literal">null</span>;</span><br><span class="line">        pendingSplits.addAll(nextSplits.getSplits());</span><br><span class="line">        <span class="keyword">if</span> (nextSplits.isLastBatch()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (state == State.INITIALIZED &amp;&amp; pendingSplits.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// 此处通过 EmptySplit 兜底</span></span><br><span class="line">                <span class="comment">// Add an empty split in case no splits have been produced for the source.</span></span><br><span class="line">                <span class="comment">// For source operators, they never take input, but they may produce output.</span></span><br><span class="line">                <span class="comment">// This is well handled by the execution engine.</span></span><br><span class="line">                <span class="comment">// However, there are certain non-source operators that may produce output without any input,</span></span><br><span class="line">                <span class="comment">// for example, 1) an AggregationOperator, 2) a HashAggregationOperator where one of the grouping sets is ().</span></span><br><span class="line">                <span class="comment">// Scheduling an empty split kicks off necessary driver instantiation to make this work.</span></span><br><span class="line">                pendingSplits.add(<span class="keyword">new</span> <span class="title class_">Split</span>(</span><br><span class="line">                        splitSource.getCatalogHandle(),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">EmptySplit</span>(splitSource.getCatalogHandle())));</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;stage id: %s, node: %s; transitioning to SPLITS_SCHEDULED&quot;</span>, stageExecution.getStageId(), partitionedNode);</span><br><span class="line">            state = State.SPLITS_SCHEDULED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将调度结果设置为阻塞状态。</span></span><br><span class="line">        blockedFuture = Optional.of(asVoid(nextSplitBatchFuture));</span><br><span class="line">        blockedOnNextSplitBatch = <span class="literal">true</span>;</span><br><span class="line">        log.debug(<span class="string">&quot;stage id: %s, node: %s; blocked on next split batch&quot;</span>, stageExecution.getStageId(), partitionedNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当pendingSplits不为空时。调度器状态为SPLITS_ADDED。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> if (!pendingSplits.isEmpty() &amp;&amp; state == State.INITIALIZED) &#123;</span><br><span class="line">    log.debug(&quot;stage id: %s, node: %s; transitioning to SPLITS_ADDED&quot;, stageExecution.getStageId(), partitionedNode);</span><br><span class="line">    state = State.SPLITS_ADDED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是对于所有的Split，计算其放置策略。根据计算出来的策略设置Split</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SplitPlacementResult</span> <span class="variable">splitPlacementResult</span> <span class="operator">=</span> splitPlacementPolicy.computeAssignments(pendingSplits);</span><br><span class="line"><span class="comment">// 这里的策略是DynamicSplitPlacementPolicy，内部使用前面介绍的NodeSelector选择最佳节点。</span></span><br><span class="line">splitAssignment = splitPlacementResult.getAssignments(); <span class="comment">// remove splits with successful placements</span></span><br><span class="line">splitAssignment.values().forEach(pendingSplits::remove); <span class="comment">// AbstractSet.removeAll performs terribly here.</span></span><br><span class="line">overallSplitAssignmentCount += splitAssignment.size(); <span class="comment">// if not completed placed, mark scheduleGroup as blocked on placement</span></span><br><span class="line"><span class="keyword">if</span> (!pendingSplits.isEmpty()) &#123;</span><br><span class="line">    placementFuture = splitPlacementResult.getBlocked();</span><br><span class="line">    blockedFuture = Optional.of(placementFuture);</span><br><span class="line">    blockedOnPlacements = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// assign the splits with successful placements</span></span><br><span class="line">overallNewTasks.addAll(assignSplits(splitAssignment));</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Set&lt;RemoteTask&gt; <span class="title function_">assignSplits</span><span class="params">(Multimap&lt;InternalNode, Split&gt; splitAssignment)</span></span><br><span class="line">&#123;</span><br><span class="line">    ImmutableSet.Builder&lt;RemoteTask&gt; newTasks = ImmutableSet.builder();</span><br><span class="line"></span><br><span class="line">    ImmutableSet&lt;InternalNode&gt; nodes = ImmutableSet.copyOf(splitAssignment.keySet());</span><br><span class="line">    <span class="keyword">for</span> (InternalNode node : nodes) &#123;</span><br><span class="line">        <span class="comment">// source partitioned tasks can only receive broadcast data; otherwise it would have a different distribution</span></span><br><span class="line">        ImmutableMultimap&lt;PlanNodeId, Split&gt; splits = ImmutableMultimap.&lt;PlanNodeId, Split&gt;builder()</span><br><span class="line">                .putAll(partitionedNode, splitAssignment.get(node))</span><br><span class="line">                .build();</span><br><span class="line">        <span class="type">RemoteTask</span> <span class="variable">task</span> <span class="operator">=</span> scheduledTasks.get(node);</span><br><span class="line">        <span class="keyword">if</span> (task != <span class="literal">null</span>) &#123;</span><br><span class="line">            task.addSplits(splits);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 调度Split Task</span></span><br><span class="line">            scheduleTask(node, splits).ifPresent(newTasks::add);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTasks.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当pendingSplits为空，且状态为SPLITS_SCHEDULED时，会将状态设置为FINISH，并将调度器设置为scheduled。其他情况都会让调度器继续执行调度方法。</p></div><footer class="post-footer"><div class="reward-container"><div>请我一杯咖啡吧！</div><button>赞赏</button><div class="post-reward"><div><img src="/images/weixinpay.webp" alt="Victor Chu 微信"> <span>微信</span></div><div><img src="/images/alpay.webp" alt="Victor Chu 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"><strong>本文作者： </strong>Victor Chu</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://www.victorchu.info/posts/53a7bc3d/" title="Trino源码学习-查询调度">https://www.victorchu.info/posts/53a7bc3d/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="followme"><span>欢迎关注我的其它发布渠道</span><div class="social-list"><div class="social-item"><a target="_blank" class="social-link" href="/atom.xml"><span class="icon"><i class="fa fa-rss"></i> </span><span class="label">RSS</span></a></div><div class="social-item"><a target="_blank" class="social-link" href="/images/wechat_channel.webp"><span class="icon"><i class="fab fa-weixin"></i> </span><span class="label">WeChat</span></a></div></div></div><div class="post-tags"><a href="/tags/Presto/" rel="tag"><i class="fa fa-tag"></i> Presto</a> <a href="/tags/Trino/" rel="tag"><i class="fa fa-tag"></i> Trino</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/f3a4a47b/" rel="prev" title="The Snowflake Elastic Data Warehouse"><i class="fa fa-angle-left"></i> The Snowflake Elastic Data Warehouse</a></div><div class="post-nav-item"><a href="/posts/d1f5c023/" rel="next" title="HikariCP: Failed to validate connection">HikariCP: Failed to validate connection <i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">浙ICP备18037908号-1 </a><img src="/images/gongan_icon.webp" alt=""><a href="https://beian.mps.gov.cn/#/query/webSearch?code=33010902002043" rel="noopener" target="_blank">浙公网安备 33010902002043号</a></div><div class="copyright">&copy; 2016 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Victor Chu</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span title="站点总字数">1.7m</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">47:13</span></span></div><div class="powered-by">由<a href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" class="theme-link" rel="noopener" target="_blank"><img src="/images/upyun_logo.webp" width="50" style="display:inline"></a>提供CDN服务</div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/algoliasearch/4.23.3/algoliasearch-lite.umd.js" integrity="sha256-1QNshz86RqXe/qsCBldsUu13eAX6n/O98uubKQs87UI=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/instantsearch.js/4.67.0/instantsearch.production.min.js" integrity="sha256-TW7D3X/i/W+RUgEeDppEnFT2ixv5lzplKH0c58D92dY=" crossorigin="anonymous"></script><script src="/js/third-party/search/algolia-search.js"></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":"default","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.9.0/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script><script src="/js/third-party/tags/mermaid.js"></script><script src="/js/third-party/fancybox.js"></script><script class="next-config" data-name="enableMath" type="application/json">false</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css" integrity="sha256-UF1fgpAiu3tPJN/uCqEUHNe7pnr+QR0SQDNfgglgtcM=" crossorigin="anonymous"><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"walineui.victorchu.info","cssUrl":"https://cdn.staticfile.org/waline/2.15.8/waline.css","commentCount":true,"pageview":true,"requiredMeta":["nick","mail"],"login":"force","libUrl":"https://cdn.staticfile.org/waline/2.15.8/waline.js","el":"#waline","comment":true,"path":"/posts/53a7bc3d/"}</script><link rel="stylesheet" href="https://cdn.staticfile.org/waline/2.15.8/waline.css"><script>document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});</script></body></html>