<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-fill-left.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"www.victorchu.info","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"waline","storage":false,"lazyload":false,"nav":null,"activeClass":"waline"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"algolia":{"appID":"X9UOD4FSUP","apiKey":"fa32db1f02073025c69da8ebad0a6aa6","indexName":"hexo-next-blog","hits":{"per_page":10}}}</script><script src="/js/config.js"></script><meta name="description" content="本文会介绍操作系统中的进程,线程和协程。"><meta property="og:type" content="article"><meta property="og:title" content="操作系统:进程&amp;线程&amp;协程"><meta property="og:url" content="https://www.victorchu.info/posts/5211c8b3/index.html"><meta property="og:site_name" content="代码之旅"><meta property="og:description" content="本文会介绍操作系统中的进程,线程和协程。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.victorchu.info/posts/5211c8b3/cover.webp"><meta property="og:image" content="https://www.victorchu.info/posts/5211c8b3/Multithreaded_process.webp"><meta property="og:image" content="https://www.victorchu.info/posts/5211c8b3/thread.webp"><meta property="og:image" content="https://www.victorchu.info/posts/5211c8b3/system_call.webp"><meta property="og:image" content="https://www.victorchu.info/posts/5211c8b3/one_2_one.webp"><meta property="og:image" content="https://www.victorchu.info/posts/5211c8b3/many_2_one.webp"><meta property="og:image" content="https://www.victorchu.info/posts/5211c8b3/m_2_n.webp"><meta property="og:image" content="https://www.victorchu.info/posts/5211c8b3/combine.webp"><meta property="og:image" content="https://www.victorchu.info/posts/5211c8b3/linux_thread.webp"><meta property="og:image" content="https://www.victorchu.info/posts/5211c8b3/mm_struct.webp"><meta property="og:image" content="https://www.victorchu.info/posts/5211c8b3/coroutines_2.webp"><meta property="og:image" content="https://www.victorchu.info/posts/5211c8b3/Coroutines.webp"><meta property="og:image" content="https://www.victorchu.info/posts/5211c8b3/scheduler.webp"><meta property="article:published_time" content="2022-05-14T07:07:33.000Z"><meta property="article:modified_time" content="2025-06-17T03:13:16.681Z"><meta property="article:author" content="Victor Chu"><meta property="article:tag" content="Thread"><meta property="article:tag" content="Process"><meta property="article:tag" content="Coroutines"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.victorchu.info/posts/5211c8b3/cover.webp"><link rel="canonical" href="https://www.victorchu.info/posts/5211c8b3/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.victorchu.info/posts/5211c8b3/","path":"/posts/5211c8b3/","title":"操作系统:进程&线程&协程"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>操作系统:进程&线程&协程 | 代码之旅</title><script src="/js/third-party/analytics/baidu-analytics.js"></script><script async src="https://hm.baidu.com/hm.js?277fc29fa80de77c97f4f62b69e94233"></script><link rel="dns-prefetch" href="walineui.victorchu.info"><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="alternate" href="/atom.xml" title="代码之旅" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">代码之旅</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">I love Coding !</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">126</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">96</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">239</span></a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="algolia-stats"><hr></div><div class="algolia-hits"></div><div class="algolia-pagination"></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">进程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.1.</span> <span class="nav-text">用户态线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%80%81%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.2.</span> <span class="nav-text">内核态线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.3.</span> <span class="nav-text">用户态线程和内核态线程的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%98%A0%E5%B0%84"><span class="nav-number">2.4.</span> <span class="nav-text">用户线程和内核线程的映射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E5%AF%B9%E4%B8%80"><span class="nav-number">2.4.1.</span> <span class="nav-text">一对一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E5%AF%B9%E4%B8%80"><span class="nav-number">2.4.2.</span> <span class="nav-text">多对一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E5%AF%B9%E5%A4%9A-Many-To-Many"><span class="nav-number">2.4.3.</span> <span class="nav-text">多对多(Many To Many)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%90%88"><span class="nav-number">2.4.4.</span> <span class="nav-text">组合</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linux-%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.5.</span> <span class="nav-text">linux 中的线程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">协程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E7%9B%AE%E7%9A%84"><span class="nav-number">3.1.</span> <span class="nav-text">协程的目的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.2.</span> <span class="nav-text">协程类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E6%A0%88%E5%8D%8F%E7%A8%8B"><span class="nav-number">3.2.1.</span> <span class="nav-text">有栈协程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E6%A0%88%E5%8D%8F%E7%A8%8B"><span class="nav-number">3.2.2.</span> <span class="nav-text">无栈协程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kotlin-CPS-Transformation"><span class="nav-number">3.2.3.</span> <span class="nav-text">Kotlin CPS Transformation</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%AD%E4%BD%93%E5%9C%A8-kotlin-%E4%B8%AD%E5%AE%9A%E4%B9%89"><span class="nav-number">3.2.3.1.</span> <span class="nav-text">续体在 kotlin 中定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#StateMachine"><span class="nav-number">3.2.3.2.</span> <span class="nav-text">StateMachine</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">3.2.3.3.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="nav-number">3.3.</span> <span class="nav-text">协程调度</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Victor Chu" src="/images/victor-blog-head.webp"><p class="site-author-name" itemprop="name">Victor Chu</p><div class="site-description" itemprop="description">blog about programming.</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">239</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">96</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">126</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/chutian0610" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;chutian0610" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:victorchu0610@outlook.com" title="E-Mail → mailto:victorchu0610@outlook.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/victorchu" title="Zhihu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;victorchu" rel="noopener me" target="_blank"><i class="fab fa-zhihu fa-fw"></i>Zhihu</a> </span><span class="links-of-author-item"><a href="/images/Wechat.webp" title="WeChat → &#x2F;images&#x2F;Wechat.webp" rel="noopener me"><i class="fa-brands fa-weixin fa-fw"></i>WeChat</a></span></div></div></div></div><div class="sidebar-inner sidebar-blogroll"><div class="links-of-blogroll animated"><div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i> 链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://www.tpfuture.top/" title="https:&#x2F;&#x2F;www.tpfuture.top&#x2F;" rel="noopener" target="_blank">一水轩</a></li></ul></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.victorchu.info/posts/5211c8b3/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/victor-blog-head.webp"><meta itemprop="name" content="Victor Chu"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="代码之旅"><meta itemprop="description" content="blog about programming."></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="操作系统:进程&线程&协程 | 代码之旅"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">操作系统:进程&线程&协程</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-05-14 15:07:33" itemprop="dateCreated datePublished" datetime="2022-05-14T15:07:33+08:00">2022-05-14</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2025-06-17 11:13:16" itemprop="dateModified" datetime="2025-06-17T11:13:16+08:00">2025-06-17</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Computer/" itemprop="url" rel="index"><span itemprop="name">Computer</span></a> </span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Computer/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a> </span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Waline：</span> <a title="waline" href="/posts/5211c8b3/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/5211c8b3/" itemprop="commentCount"></span> </a></span><span class="post-meta-item" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="waline-pageview-count" data-path="/posts/5211c8b3/"></span> </span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>9.8k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>16 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>本文会介绍操作系统中的进程,线程和协程。</p><figure><img data-src="/posts/5211c8b3/cover.webp" alt></figure><span id="more"></span><h1 id="进程">进程</h1><p>计算机的核心是CPU，它承担了所有的计算任务；而操作系统是计算机的管理者，它负责任务的调度、资源的分配和管理，统领整个计算机硬件；应用程序则是具有某种功能的程序，程序是运行于操作系统之上的。进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。进程是一种抽象的概念，从来没有统一的标准定义。</p><p>进程一般由程序、数据集合和进程控制块三部分组成。</p><ul><li>程序用于描述进程要完成的功能，是控制进程执行的指令集；</li><li>数据集合是程序在执行时所需要的数据和工作区；</li><li>程序控制块(Program Control Block，简称PCB)，包含进程的描述信息和控制信息，是进程存在的唯一标志。</li></ul><p>进程具有的特征：</p><ul><li>动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；</li><li>并发性：任何进程都可以同其他进程一起并发执行；</li><li>独立性：进程是系统进行资源分配和调度的一个独立单位；</li><li>结构性：进程由程序、数据和进程控制块三部分组成。</li></ul><p>在早期的操作系统中并没有线程的概念，进程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位。任务调度采用的是时间片轮转的抢占式调度方式，而<strong>进程是任务调度的最小单位</strong><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。</p><p>操作系统管理所有进程的方法，就是对每一个进程建立一个PCB (Process Control Block)，记录该进程的相关状态。在切换不同进程时，会先保存当前执行状态，再切换到下一个进程，并恢复切换后进程的存储状态，继续执行。</p><ul><li>优点：相对比较稳定安全，因为每一个进程都拥有独立的系统资源，进程间不容易相互影响，而且因为不会共享 data 的问题，所以不须对进程作互斥存取之机制。</li><li>缺点：进程的建立及切换 (context switching) 的开销都比较大，因为涉及到 OS 资源的切换，彼此进程间要通信也比较复杂及耗时。</li></ul><h1 id="线程">线程</h1><p>随着计算机的发展，对CPU的要求越来越高，进程之间的切换开销较大，已经无法满足越来越复杂的程序的要求了。于是就有了线程。线程又被称为轻量级进程，线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。</p><p>一个CPU核心同一时刻只能执行一个线程，一个有两个线程的进程在单核处理器上的执行顺序如下图:</p><figure><img data-src="/posts/5211c8b3/Multithreaded_process.webp" alt></figure><p>一个标准的线程由以下部分组成,多个线程共享进程内的内存空间: 代码、数据、系统资源(例如文件).</p><ul><li>线程ID</li><li>当前指令指针(PC),也被称为程序计数器。</li><li>寄存器</li><li>堆栈。</li></ul><figure><img data-src="/posts/5211c8b3/thread.webp" alt></figure><p>线程的实现可以分为 2 类: 用户级线程和内核级线程。Kernel 运行在超级权限模式（Supervisor Mode）下，所以拥有很高的权限。按照权限管理的原则，多数应用程序应该运行在最小权限下。因此，很多操作系统，将内存分成了两个区域：</p><ul><li>内核空间（Kernal Space），这个空间只有内核程序可以访问。</li><li>用户空间（User Space），这部分内存专门给应用程序使用。</li></ul><p>用户空间中的代码被限制了只能使用一个局部的内存空间，我们说这些程序在用户态（User Mode） 执行。内核空间中的代码可以访问所有内存，我们称这些程序在内核态（Kernal Mode） 执行。如果用户态程序需要执行系统调用，就需要切换到内核态执行。</p><figure><img data-src="/posts/5211c8b3/system_call.webp" alt></figure><p>内核程序执行在内核态（Kernal Mode），用户程序执行在用户态（User Mode）。当发生系统调用时，用户态的程序发起系统调用。因为系统调用中牵扯特权指令，用户态程序权限不足，因此会中断执行，也就是 Trap。发生中断后，当前 CPU 执行的程序会中断，跳转到中断处理程序。内核程序开始执行，也就是开始处理系统调用。内核处理完成后，主动触发 Trap，这样会再次发生中断，切换回用户态工作。</p><p>进程可以分成用户态进程和内核态进程两类。用户态进程通常是应用程序的副本，内核态进程就是内核本身的进程。如果用户态进程需要申请资源，比如内存，可以通过系统调用向内核申请。进程可以通过 API 创建用户态的线程，也可以通过系统调用创建内核态的线程。</p><h2 id="用户态线程">用户态线程</h2><p>用户态线程也称作用户级线程（User Level Thread）。操作系统内核并不知道它的存在，它完全是在用户空间中创建。用户级线程有很多优势:</p><ul><li>管理开销小：创建、销毁不需要系统调用。</li><li>切换成本低：用户空间程序可以自己维护，不需要走操作系统调度。</li></ul><p>但是这种线程也有很多的缺点。</p><ul><li>与内核协作成本高：比如这种线程完全是用户空间程序在管理，当它进行 I/O 的时候，无法利用到内核的优势，需要频繁进行用户态到内核态的切换。</li><li>线程间协作成本高：设想两个线程需要通信，通信需要 I/O，I/O 需要系统调用，因此用户态线程需要支付额外的系统调用成本。</li><li>无法利用多核优势：比如操作系统调度的仍然是这个线程所属的进程，所以无论一个进程有多少用户态的线程，都只能并发执行一个线程，因此一个进程的多个线程无法利用多核的优势。</li><li>操作系统无法针对线程调度进行优化：当一个进程的一个用户态线程阻塞（Block）了，操作系统无法及时发现和处理阻塞问题，它不会更换执行其他线程，从而造成资源浪费。</li></ul><h2 id="内核态线程">内核态线程</h2><p>内核态线程也称作内核级线程（Kernel Level Thread）。这种线程执行在内核态，可以通过系统调用创造一个内核级线程。内核级线程有很多优势。</p><ul><li>可以利用多核 CPU 优势：内核拥有较高权限，因此可以在多个 CPU 核心上执行内核线程。</li><li>操作系统级优化：内核中的线程操作 I/O 不需要进行系统调用；一个内核线程阻塞了，可以立即让另一个执行。</li></ul><p>当然内核线程也有一些缺点。</p><ul><li>创建成本高：创建的时候需要系统调用，也就是切换到内核态。</li><li>扩展性差：由一个内核程序管理，不可能数量太多。</li><li>切换成本较高：切换的时候，也同样存在需要内核操作，需要切换内核态。</li></ul><h2 id="用户态线程和内核态线程的区别">用户态线程和内核态线程的区别</h2><p>用户态线程工作在用户空间，内核态线程工作在内核空间。用户态线程调度完全由进程负责，通常就是由进程的主线程负责。相当于进程主线程的延展，使用的是操作系统分配给进程主线程的时间片段。内核线程由内核维护，由操作系统调度。</p><p>用户态线程无法跨核心，一个进程的多个用户态线程不能并发，阻塞一个用户态线程会导致进程的主线程阻塞，直接交出执行权限。这些都是用户态线程的劣势。内核线程可以独立执行，操作系统会分配时间片段。因此内核态线程更完整，也称作轻量级进程。内核态线程创建成本高，切换成本高，创建太多还会给调度算法增加压力，因此不会太多。</p><p>实际操作中，往往结合两者优势，将用户态线程附着在内核态线程中执行。</p><h2 id="用户线程和内核线程的映射">用户线程和内核线程的映射</h2><p>用户态线程创建成本低，问题明显，不可以利用多核。内核态线程，创建成本高，可以利用多核，切换速度慢。因此通常我们会在内核中预先创建一些线程，并反复利用这些线程。这样，用户态线程和内核态线程之间就构成了下面 4 种可能的关系:</p><ul><li>一对一</li><li>多对一</li><li>多对多</li><li>组合</li></ul><p>这些模型各有优缺点，适用于不同的应用场景。</p><h3 id="一对一">一对一</h3><p>该模型为每个用户态的线程分配一个单独的内核态线程，在这种情况下，每个用户态都需要通过系统调用创建一个绑定的内核线程，并附加在上面执行。 这种模型允许所有线程并发执行，能够充分利用多核优势，Windows NT 内核采取的就是这种模型。但是因为线程较多，对内核调度的压力会明显增加。</p><figure><img data-src="/posts/5211c8b3/one_2_one.webp" alt></figure><h3 id="多对一">多对一</h3><p>用户态进程中的多线程复用一个内核态线程。这样，极大地减少了创建内核态线程的成本，但是线程不可以并发。因此，这种模型现在基本上用的很少。</p><figure><img data-src="/posts/5211c8b3/many_2_one.webp" alt></figure><h3 id="多对多-Many-To-Many">多对多(Many To Many)</h3><p>这种模式下会为 n 个用户态线程分配 m 个内核态线程。m 通常可以小于 n。一种可行的策略是将 m 设置为核数。这种多对多的关系，减少了内核线程，同时也保证了多核心并发。Linux 目前采用的就是该模型。</p><figure><img data-src="/posts/5211c8b3/m_2_n.webp" alt></figure><h3 id="组合">组合</h3><p>这种模型混合了多对多和一对一的特点。多数用户态线程和内核线程是 n 对 m 的关系，少量用户线程可以指定成 1 对 1 的关系。</p><figure><img data-src="/posts/5211c8b3/combine.webp" alt></figure><h2 id="linux-中的线程">linux 中的线程</h2><p>Linux(Kernel 2.6.34) 并没有一个明确的 Thread 或是 Process 的概念，取而代之为 Task (也可以称做 light-weight process),task_structs 就是 Task 的结构体现， 也被称做为 process descriptor (类似 PCB 的概念)，记录了这个 Process 所有的context。</p><figure><img data-src="/posts/5211c8b3/linux_thread.webp" alt></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">long</span> state; <span class="comment">// -1 unrunnable, 0 runnable, &gt;0 stopped</span></span><br><span class="line">  <span class="type">void</span> *<span class="built_in">stack</span>; <span class="comment">// point to kernel stack</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> // <span class="title">point</span> <span class="title">to</span> <span class="title">memory</span> <span class="title">descriptor</span></span></span><br><span class="line"><span class="class">  <span class="keyword">struct</span> <span class="title">thread_struct</span> <span class="title">thread</span>;</span> <span class="comment">// context switch info</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>task_struct 记录目前Process 的状态</li><li>每个 task_structs 都会有一个 kernel stack ，提供在 Kernel mode 时进行运算时，可存放临时变量的地方。</li><li>Process 都会拥有一个唯一的 mm_struct ，让 Process 有抽象的独立 memory (32 or 64 bits address space) 可以使用。Linux 中，如果共享 mm_struct ，则称为 Thread。</li><li>task_struct 通过 thread_struct 记录用户空间 user_stack的信息</li></ul><blockquote><p>如果task_struct 有自己的 mm_struct，称为 Process，其实本身就是个 Main Thread (CPU scheduling的基本单位)。如果task_struct 共用别人的 mm_struct，称为 Thread。</p></blockquote><p>mm_struct 也称做为 Memory descriptor， mm_struct 描述了属于这 Process 的整个 virtual address space 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> start_stack <span class="comment">// user stack start address</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure><img data-src="/posts/5211c8b3/mm_struct.webp" alt></figure><p>在 mm_struct 中，会有一个 start_stack (user stack 起始位置)，提供在 User mode 运算的存放空间。如果是一个 Thread，因为共享 parent 的 mm_struct ，为了不影响到 mm_struct 裡的 stack 空间，会在heap 或 mmap 内找一个空间作为 Thread 的 stack。</p><p>不论哪种方式产生的 user stack，都会初始化 task_struct-&gt;thread-&gt;sp ，让其存放 user stack 信息。thread_struct 保留了大部分的 CPU registers 的信息，context switch 主要就是恢复保存在 thread_struct 里的信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span> &#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span>  sp0; <span class="comment">// 存放 kernel stack base address  </span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span>  sp;  <span class="comment">// 存放 kernel stack (current)top address</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>建立 process/thread (task_struct) 会得到两个 stack:</p><ul><li>user stack:<ul><li>建立在 address space (mm_struct)，在 user mode 使用</li><li>process (mm_struct 的 stack) 或 thread (mm_struct 的 heap/mmap)</li></ul></li><li>kernel stack :<ul><li>建立在 kernel address space <sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>，在 kernel mode 使用</li><li>task_struct 指向的 stack (thread_info<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>)</li></ul></li></ul><p>综上，Linux 的线程模型是 one-to-one 模式。</p><h1 id="协程">协程</h1><p>协程，英文Coroutines，是一种基于线程之上，但又比线程更加轻量级的存在，这种由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』，具有对内核来说不可见的特性。因为是自主开辟的异步任务，所以很多人也更喜欢叫它们纤程（Fiber），或者绿色线程（GreenThread）。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。</p><h2 id="协程的目的">协程的目的</h2><p>在传统的web系统中都是基于每个请求占用一个线程去完成完整的业务逻辑。所以系统的吞吐能力取决于每个线程的操作耗时。如果遇到很耗时的I/O行为，则整个系统的吞吐立刻下降，因为这个时候线程一直处于阻塞状态，如果线程很多的时候，会存在很多线程处于空闲状态（等待该线程执行完才能执行），造成了资源应用不彻底。</p><p>最常见的例子就是JDBC（它是同步阻塞的），这也是为什么很多人都说数据库是瓶颈的原因。这里的耗时其实是让CPU一直在等待I/O返回，说白了线程根本没有利用CPU去做运算，而是处于空转状态。而另外过多的线程，也会带来更多的ContextSwitch开销。</p><figure><img data-src="/posts/5211c8b3/coroutines_2.webp" alt></figure><p>我们可以将任务分为 I/O bound和CPU bound</p><ul><li>任务本身是通过过IO去执行，这时就会受到写入/读取的速度限制，比如到远端的Server获取股票价格、上传文件到云端会根据电脑的网络速度、以及其他任何牵涉到IO读取和写入，都属于I/O bound的一种。</li><li>任务本身涉及大量CPU、GPU计算，比如3D制图、AI模型训练、本地解压缩等都属于CPU bound的一种。</li></ul><p>而协程的目的就是当出现I/O bound操作时，通过让出目前的协程调度，执行下一个任务的方式，来消除ContextSwitch上的开销。协程适用于被阻塞的，且需要大量并发的场景。但不适用于大量计算的多线程，遇到此种情况，更好实用线程去解决。</p><figure><img data-src="/posts/5211c8b3/Coroutines.webp" alt></figure><h2 id="协程类型">协程类型</h2><p>协程可以被划分为两大类，一类是有栈（stackful）协程，例如 goroutine；一类是无栈（stackless）协程，例如 async/await。</p><p>有栈是指协程是否可以在其任意嵌套函数中被挂起，有栈协程是可以的，而无栈协程则不可以。</p><h3 id="有栈协程">有栈协程</h3><p>实现一个协程的关键点在于如何保存、恢复和切换上下文。已知函数运行在调用栈上；如果将一个函数作为协程，我们很自然地联想到，</p><ul><li>保存上下文即是保存从这个函数及其嵌套函数的（连续的）栈帧存储的值，以及此时寄存器存储的值；</li><li>恢复上下文即是将这些值分别重新写入对应的栈帧和寄存器；</li><li>而切换上下文无非是保存当前正在运行的函数的上下文，恢复下一个将要运行的函数的上下文。</li></ul><p>有栈协程便是这种思想下的产物。很显然有栈协程被挂起时的自由度要比无栈协程高 <sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup> ，所以有栈协程可以很方便地兼容现有的同步代码 <sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>。</p><h3 id="无栈协程">无栈协程</h3><p>相比于有栈协程直接切换栈帧的思路，无栈协程在不改变函数调用栈的情况下，采用计算续体的思路实现了上下文切换<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>。</p><p>当一个计算过程在中间被打断，其剩余部分可以使用一个对象进行表示，这个对象就是计算续体。大多数编程语言会提供相关的关键词进行修饰，最常见的就是 async 和 await。一般 async 用于声明一个异步函数，await 用于挂起（执行）一个异步函数。事实上，计算续体就是异步函数的底层实现技术。当使用 await 调用一个异步函数时，那么编译器会 将后续部分的代码转换成续体，当异步任务执行完毕之后，再将值传递至续体中继续执行，有点类似于方法回调。</p><p>事实上，计算续体与函数栈帧有着非常紧密的关系，前者是保存和恢复栈帧的一种机制。在函数调用时，每个函数都会创建一个栈帧，其包含函数的局部变量、参数以及返回地址等信息。栈帧被存放在进程空间的栈区，当函数返回时，对应的栈帧会从栈中弹出，程序恢复到调用该函数的地方。</p><p>计算续体则是将 当前栈帧 以及 程序计算器 等信息保存至一个对象中，然后将该对象传递给一个续体函数。续体函数可以在需要时将保存的状态恢复，从而继续执行程序。</p><p>因此，从运行时层面看，计算续体就是当前函数的栈帧与现场状态；从代码层面看，计算续体就是等待异步操作完成的后续代码。</p><p>注意，计算续体不会改变函数调用栈，在无栈协程中，你（几乎）不可能在任意一个嵌套函数中挂起协程。不过由于不需要切换栈帧，无栈协程的性能倒是比有栈协程普遍要高一些。</p><h3 id="Kotlin-CPS-Transformation">Kotlin CPS Transformation</h3><p>CPS 变换（Continuation-Passing Style Transformation）是无栈协程实现的常见方案，它将挂起函数转换为continuation 传递风格的函数，本质上是一种将同步代码转换为异步代码的回调风格的转换方式。以 kotlin 代码为例:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">postItem</span><span class="params">(item: <span class="type">Item</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> token = generateToken()         <span class="comment">// step1</span></span><br><span class="line">    <span class="keyword">val</span> post = createPost(token, item)  <span class="comment">// step2</span></span><br><span class="line">    processPost(post)                   <span class="comment">// step3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上述代码进行CPS转化后(CPS转化其实是将下一步变成了回调):</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">postItem</span><span class="params">(item: <span class="type">Item</span>)</span></span> &#123;</span><br><span class="line">    generateToken &#123; token -&gt;              <span class="comment">// step1</span></span><br><span class="line">        createPost(token, item) &#123; post -&gt; <span class="comment">// step2</span></span><br><span class="line">            processPost(post)             <span class="comment">// step3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 kotlin 中增加 suspend 关键字来标记异步方法实现协程。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">postItem</span><span class="params">(item: <span class="type">Item</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> token = generateToken() <span class="comment">// suspend 方法</span></span><br><span class="line">    <span class="keyword">val</span> post = createPost(token, item) <span class="comment">// suspend 方法</span></span><br><span class="line">    processPost(post)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>带suspend的方法在编译后方法签名都会增加一个续体参数。续体负责将当前步骤结果传递给下个步骤，同时移交下一步的调用权。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译前：Kotlin</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">createPost</span><span class="params">(token: <span class="type">Token</span>, item: <span class="type">Item</span>)</span></span>: Post &#123; … &#125;</span><br><span class="line"><span class="comment">// 编译后：Java/JVM（cont其实是一个callback，Post为结果）</span></span><br><span class="line">Object createPost(Token token, Item item, Continuation&lt;Post&gt; cont) &#123; … &#125;</span><br></pre></td></tr></table></figure><h4 id="续体在-kotlin-中定义">续体在 kotlin 中定义</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Continuation</span>&lt;<span class="type">in T</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">resume</span><span class="params">(value: <span class="type">T</span>)</span></span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWithException</span><span class="params">(exception: <span class="type">Throwable</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>CoroutineContext：是一个链表结构，可以使用「+」操作符，其中包含协程执行时需要的一些参数：名称/ID、调度器 Dispatcher、控制器 Job、异常 Handler等（把 Job 称为「控制器」感觉好理解一些）</li><li>resumeWith：触发下一步的方法，参数 result 是当前步骤的结果（上面说到了调用权，resumeWith就是调用入口）</li></ul><h4 id="StateMachine">StateMachine</h4><p>每个 suspend 函数都会生成出一个内部类 StateMachine，用于保存函数的局部变量与执行点位，所有的暂停点位，都是调用 suspend 函数的位置。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">postItem</span><span class="params">(item: <span class="type">Item</span>, cont: <span class="type">Continuation</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// cont是父协程的续体，在当前协程结束时会触发cont的resume</span></span><br><span class="line">    <span class="keyword">val</span> sm = <span class="keyword">object</span> : CoroutineImpl(cont) &#123; </span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">resume</span><span class="params">(...)</span></span> &#123;</span><br><span class="line">            postItem(<span class="literal">null</span>, <span class="keyword">this</span>)    <span class="comment">// 续体回调入口</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    switch (sm.label) &#123;</span><br><span class="line">        case <span class="number">0</span>:</span><br><span class="line">            sm.item = item      <span class="comment">// 初始参数，执行过程中传递的一些参数</span></span><br><span class="line">            sm.label = <span class="number">1</span>        <span class="comment">// 状态控制</span></span><br><span class="line">            generateToken(sm)    <span class="comment">// step1，传入续体</span></span><br><span class="line">            <span class="comment">// 执行完成后调用resume，并将结果传递下去</span></span><br><span class="line">        case <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">val</span> token = sm.result <span class="keyword">as</span> Token  <span class="comment">// 从续体中拿取上一步的结果</span></span><br><span class="line">            <span class="keyword">val</span> item = sm.item              <span class="comment">// 从续体中拿取初始参数</span></span><br><span class="line">            sm.label = <span class="number">2</span>                    <span class="comment">// 状态控制</span></span><br><span class="line">            createPost(token, item, sm)     <span class="comment">// step2，传入续体&amp;参数</span></span><br><span class="line">            <span class="comment">// 执行完成后调用resume，并将结果传递下去</span></span><br><span class="line">        case <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">val</span> post = sm.result <span class="keyword">as</span> Post    <span class="comment">// 从续体中拿取上一步的结果</span></span><br><span class="line">            processPost(post, sm)           <span class="comment">// spte3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个 StateMachine 对象也是 Continuation 接口的实现。每当 suspend 函数执行到 suspend 点位时，实际上会退出执行，函数的执行上下文会完整记录在 StateMachine 中。</p><p>调用的异步方法有响应时，会回调 StateMachine 的 resume 方法，而 resume 方法的执行，相当于使用记录在 StateMachine 中的上下文作为参数，再执行一次该函数。</p><h4 id="总结">总结</h4><ul><li>kotlin 的协程支持是 CPS 变换和 StateMachine 两部分，CPS 变换使同步代码异步化，增加额外的 Continuation 类型的参数，用于函数结果值的返回；</li><li>通过 switch / case 配合 label，做到执行点位的记录与暂停；</li><li>每个 suspend 方法都会生成一个内部的 StateMachine 类，StateMachine 类中包含函数的所有局部变量，以及暂定点的返回值与异常值，扮演了 yield 语句的功能，即暂停函数的执行，为此需要记录下函数当前的局部变量上下文与执行点位。</li><li>被暂停函数的恢复执行，实现上等于将函数的局部变量上下文与点位作为参数，重新调用一次这个函数。</li></ul><h2 id="协程调度">协程调度</h2><p>以 Go Coroutine 调度为例介绍下协程的调度:</p><figure><img data-src="/posts/5211c8b3/scheduler.webp" alt></figure><ul><li>G: 协程任务(goroutine)</li><li>P: 任务处理器(Processor),包含了运行goroutine的资源，如果线程想运行goroutine，必须先获取P，P中还包含了可运行的G队列。</li><li>M: 线程</li></ul><p>在Go中，线程是运行goroutine的实体，调度器的功能是把可运行的goroutine分配到工作线程上。</p><ul><li>全局队列（Global Queue）：存放等待运行的G。</li><li>P的本地队列：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建G时，G优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。</li><li>P列表：所有的P都在程序启动时创建，并保存在数组中，最多有GOMAXPROCS(可配置)个。</li><li>M：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列拿一批G放到P的本地队列，或从其他P的本地队列偷一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。</li></ul><p>调度器的设计策略</p><ul><li>work stealing机制: 当本线程无可运行的G时，尝试从其他线程绑定的P偷取G，而不是销毁线程。</li><li>hand off机制: 当本线程因为G进行系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的线程执行。</li><li>抢占：在coroutine中要等待一个协程主动让出CPU才执行下一个协程，在Go中，一个goroutine最多占用CPU 10ms，防止其他goroutine被饿死，这就是goroutine不同于coroutine的一个地方<sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup>。</li></ul><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>也就是说同一时刻，一个 cpu 核心只能运行一个进程 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>所有kernel stack 共用的空间 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p>放在 struct thread_union 里与 context switch 有关 <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p>可以认为有栈协程实现了类似操作系统的线程上下文切换功能 <a href="#fnref4" class="footnote-backref">↩︎</a></p></li><li id="fn5" class="footnote-item"><p>JVM的 loom 就选择实现有栈协程 <a href="#fnref5" class="footnote-backref">↩︎</a></p></li><li id="fn6" class="footnote-item"><p>例如 rust 和 kotlin 的实现 <a href="#fnref6" class="footnote-backref">↩︎</a></p></li><li id="fn7" class="footnote-item"><p>kotlin 和 Rust 之类的无栈协程无法实现抢占 <a href="#fnref7" class="footnote-backref">↩︎</a></p></li></ol></section></div><footer class="post-footer"><div class="reward-container"><div>请我一杯咖啡吧！</div><button>赞赏</button><div class="post-reward"><div><img src="/images/weixinpay.webp" alt="Victor Chu 微信"> <span>微信</span></div><div><img src="/images/alpay.webp" alt="Victor Chu 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"><strong>本文作者： </strong>Victor Chu</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://www.victorchu.info/posts/5211c8b3/" title="操作系统:进程&amp;线程&amp;协程">https://www.victorchu.info/posts/5211c8b3/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="followme"><span>欢迎关注我的其它发布渠道</span><div class="social-list"><div class="social-item"><a target="_blank" class="social-link" href="/atom.xml"><span class="icon"><i class="fa fa-rss"></i> </span><span class="label">RSS</span></a></div><div class="social-item"><a target="_blank" class="social-link" href="/images/wechat_channel.webp"><span class="icon"><i class="fab fa-weixin"></i> </span><span class="label">WeChat</span></a></div></div></div><div class="post-tags"><a href="/tags/Thread/" rel="tag"><i class="fa fa-tag"></i> Thread</a> <a href="/tags/Process/" rel="tag"><i class="fa fa-tag"></i> Process</a> <a href="/tags/Coroutines/" rel="tag"><i class="fa fa-tag"></i> Coroutines</a></div><div class="social-like a2a_kit a2a_kit_size_32 a2a_default_style"><a class="a2a_dd" target="_blank" rel="noopener" href="https://www.addtoany.com/share"></a> <a class="a2a_button_facebook"></a> <a class="a2a_button_twitter"></a> <a class="a2a_button_wechat"></a> <a class="a2a_button_pocket"></a> <a class="a2a_button_instapaper"></a> <a class="a2a_button_pinboard"></a> <a class="a2a_button_kindle_it"></a> <a class="a2a_button_copy_link"></a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/c970017b/" rel="prev" title="diff算法-Myers算法"><i class="fa fa-angle-left"></i> diff算法-Myers算法</a></div><div class="post-nav-item"><a href="/posts/7d35c7f1/" rel="next" title="Presto: SQL on EveryThing">Presto: SQL on EveryThing <i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">浙ICP备18037908号-1 </a><img src="/images/gongan_icon.webp" alt=""><a href="https://beian.mps.gov.cn/#/query/webSearch?code=33010902002043" rel="noopener" target="_blank">浙公网安备 33010902002043号</a></div><div class="copyright">&copy; 2016 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Victor Chu</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span title="站点总字数">2m</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">56:01</span></span></div><div class="powered-by">由<a href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" class="theme-link" rel="noopener" target="_blank"><img src="/images/upyun_logo.webp" width="50" style="display:inline"></a>提供CDN服务</div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/algoliasearch/4.23.3/algoliasearch-lite.umd.js" integrity="sha256-1QNshz86RqXe/qsCBldsUu13eAX6n/O98uubKQs87UI=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/instantsearch.js/4.67.0/instantsearch.production.min.js" integrity="sha256-TW7D3X/i/W+RUgEeDppEnFT2ixv5lzplKH0c58D92dY=" crossorigin="anonymous"></script><script src="/js/third-party/search/algolia-search.js"></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":"dark","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.5.0/mermaid.min.js","integrity":"sha256-2obLuIPcceEhkE3G09G33hBdmE55ivVcZUlcKcGNHjU="}}</script><script src="/js/third-party/tags/mermaid.js"></script><script src="/js/third-party/fancybox.js"></script><script src="/js/third-party/pace.js"></script><script src="/js/third-party/addtoany.js"></script><script class="next-config" data-name="enableMath" type="application/json">false</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css" integrity="sha256-UF1fgpAiu3tPJN/uCqEUHNe7pnr+QR0SQDNfgglgtcM=" crossorigin="anonymous"><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"walineui.victorchu.info","cssUrl":"https://cdn.staticfile.org/waline/2.15.8/waline.css","commentCount":true,"pageview":true,"requiredMeta":["nick","mail"],"login":"force","libUrl":"https://cdn.staticfile.org/waline/2.15.8/waline.js","dark":"body.darkmode--activated","el":"#waline","comment":true,"path":"/posts/5211c8b3/"}</script><link rel="stylesheet" href="https://cdn.staticfile.org/waline/2.15.8/waline.css"><script>document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});</script><script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script><script>var options = {
  bottom: '64px',
  right: '32px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();</script><script defer src="/_vercel/insights/script.js"></script><script defer src="/_vercel/speed-insights//script.js"></script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script></body></html>