# Rust 所有权

Rust 为了解决内存安全问题，引入了所有权系统。

所有的程序都必须和计算机内存打交道，如何从内存中申请空间来存放程序的运行内容，如何在不需要的时候释放这些空间，成了重中之重，也是所有编程语言设计的难点之一。在计算机语言不断演变过程中，出现了三种流派：

- 垃圾回收机制(GC)，在程序运行时不断寻找不再使用的内存，典型代表：Java、Go
- 手动管理内存的分配和释放, 在程序中，通过函数调用的方式来申请和释放内存，典型代表：C++
- 通过所有权来管理内存，编译器在编译时会根据一系列规则进行检查。

Rust 选择了第三种，最妙的是，这种检查只发生在编译期，因此对于程序运行期，不会有任何性能上的损失。

<!--more-->

## 栈(Stack)与堆(Heap)

栈和堆是编程语言最核心的数据结构，栈和堆的核心目标就是为程序在运行时提供可供使用的内存空间。

- 栈按照顺序存储值并以相反顺序取出值，这也被称作后进先出。增加数据叫做进栈，移出数据则叫做出栈。因为上述的实现方式，栈中的所有数据都必须**占用已知且固定大小的内存空间**，假设数据大小是未知的，那么在取出数据时，你将无法取到你想要的数据。
- 与栈不同，对于大小未知或者可能变化的数据，我们需要将它存储在堆上。当向堆上放入数据时，需要请求一定大小的内存空间。操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的指针，该过程被称为在堆上分配内存，有时简称为 “分配”(allocating)。接着，该指针会被推入栈中，因为指针的大小是已知且固定的，在后续使用过程中，你将通过栈中的指针，来获取数据在堆上的实际内存位置，进而访问该数据。

在栈上分配内存比在堆上分配内存要快，因为入栈时操作系统无需进行函数调用（或更慢的系统调用）来分配新的空间，只需要将新数据放入栈顶即可。相比之下，在堆上分配内存则需要更多的工作，这是因为操作系统必须首先找到一块足够存放数据的内存空间，接着做一些记录为下一次分配做准备，如果当前进程分配的内存页不足时，还需要进行系统调用来申请更多内存。 因此，处理器在栈上分配数据会比在堆上分配数据更加高效。

当你的代码调用一个函数时，传递给函数的参数（包括可能指向堆上数据的指针和函数的局部变量）依次被压入栈中，当函数调用结束时，这些值将被从栈中按照相反的顺序依次移除。

因为堆上的数据缺乏组织，因此跟踪这些数据何时分配和释放是非常重要的，否则堆上的数据将产生内存泄漏 —— 这些数据将永远无法被回收。这就是 Rust 所有权系统为我们提供的强大保障。

## 所有权原则

- Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者
- 一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者
- 当所有者（变量）离开作用域范围时，这个值将被丢弃(drop)

## 变量作用域

作用域是一个变量在程序中有效的范围，假如有这样一个变量 s 绑定到了一个字符串字面值，该字符串字面值是硬编码到程序代码中的。s 变量从声明的点开始直到当前作用域的结束都是有效的：

```rust
{                      // s 在这里无效，它尚未声明
    let s = "hello";   // 从此处起，s 是有效的

    // 使用 s
}                      // 此作用域已结束，s不再有效
```

## 变量绑定背后的数据交互

### 转移所有权(移动)

先来看一段代码：

```rust
let x = 5;
let y = x;
```

这段代码并没有发生所有权的转移，原因很简单： 代码首先将 5 绑定到变量 x，接着拷贝 x 的值赋给 y，最终 x 和 y 都等于 5，因为整数是 Rust 基本数据类型，是固定大小的简单值，因此这两个值都是通过自动拷贝的方式来赋值的，都被存在栈中，完全无需在堆上分配内存。

> 整个过程中的赋值都是通过值拷贝的方式完成（发生在栈中），因此并不需要所有权转移。Rust 基本类型都是通过自动拷贝的方式来赋值的。

然后再来看一段代码：

```rust
let s1 = String::from("hello");
let s2 = s1;
```

String 类型是一个复杂类型，由存储在栈中的堆指针、字符串长度、字符串容量共同组成。堆指针指向了一个堆上的空间，这里存储着它的真实数据。

下面对上面代码中的 let s2 = s1 分成两种情况讨论：

- 拷贝 String 和存储在堆上的字节数组，如果该语句是拷贝所有数据(深拷贝)，那么无论是 String 本身还是底层的堆上数据，都会被全部拷贝，这对于性能而言会造成非常大的影响
- 只拷贝 String 本身，这样的拷贝非常快，因为在 64 位机器上就拷贝了 8字节的指针、8字节的长度、8字节的容量，总计 24 字节，但是带来了新的问题，还记得我们之前提到的所有权规则吧？其中有一条就是：一个值只允许有一个所有者，而现在这个值（堆上的真实字符串数据）有了两个所有者：s1 和 s2。

> 假定一个值可以拥有两个所有者，会发生什么呢？
> 当变量离开作用域后，Rust 会自动调用 drop 函数并清理变量的堆内存。不过由于两个 String 变量指向了同一位置。这就有了一个问题：当 s1 和 s2 离开作用域，它们都会尝试释放相同的内存。这是一个叫做 二次释放（double free） 的错误，也是之前提到过的内存安全性 BUG 之一。两次释放（相同）内存会导致内存污染，它可能会导致潜在的安全漏洞。

因此，Rust 这样解决问题：当 s1 被赋予 s2 后，Rust 认为 s1 不再有效，因此也无需在 s1 离开作用域后 drop 任何东西，这就是把所有权从 s1 转移给了 s2，s1 在被赋予 s2 后就马上失效了。

```rust
let s1 = String::from("hello");
let s2 = s1;
println!("{}, world!", s1);
             // error: ^^ value borrowed here after move
```

如果你在其他语言中听说过术语 浅拷贝(shallow copy) 和 深拷贝(deep copy)，那么拷贝指针、长度和容量而不拷贝数据听起来就像浅拷贝，但是又因为 Rust 同时使第一个变量 s1 无效了，因此这个操作被称为 移动(move)，而不是浅拷贝。

![](move.webp)

### 克隆

Rust 永远也不会自动创建数据的 “克隆”。因此，任何自动的复制都不是深拷贝，可以被认为对运行时性能影响较小。如果我们确实需要深度复制 String 中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫做 clone 的方法。

```rust
let s1 = String::from("hello");
let s2 = s1.clone();
println!("s1 = {}, s2 = {}", s1, s2);
```

> 如果代码性能无关紧要，例如初始化程序时或者在某段时间只会执行寥寥数次时，你可以使用 clone 来简化编程。但是对于执行较为频繁的代码（热点路径），使用 clone 会极大的降低程序性能，需要小心使用！

### 拷贝

拷贝只发生在栈上，因此性能很高，在日常编程中，拷贝无处不在。Rust 有一个叫做 Copy 的特征，可以用在类似整型这样在栈中存储的类型。如果一个类型拥有 Copy 特征，一个旧的变量在被赋值给其他变量后仍然可用，也就是赋值的过程即是拷贝的过程。

那么什么类型是可 Copy 的呢？可以查看给定类型的文档来确认，这里可以给出一个通用的规则：任何基本类型的组合可以 Copy ，不需要分配内存或某种形式资源的类型是可以 Copy 的。如下是一些 Copy 的类型：

- 所有整数类型，比如 u32
- 布尔类型，bool，它的值是 true 和 false
- 所有浮点数类型，比如 f64
- 字符类型，char
- 元组，当且仅当其包含的类型也都是 Copy 的时候。比如，(i32, i32) 是 Copy 的，但 (i32, String) 就不是
- 基础类型的数组，比如`let arr = [0;1000];` 
- 不可变引用 &T ，但是注意：可变引用 &mut T 是不可以 Copy的

### 自定义类型上的 Copy

要为自定义类型实现 Copy，该类型必须首先实现 Clone trait，然后我们可以为其标注 Copy trait。但需要注意，只有当类型中所有的字段都是 Copy 时，我们才能安全地为该类型实现 Copy trait。

```rust
/// Wire in circuit.
#[derive(Default, Clone, Copy)]
pub struct Wire {
    potential: bool,
}
impl Wire {
    /// Create a new wire.
    pub fn new(potential: Potential) -> Self {
        Self { potential }
    }
    /// Get the output of the wire.
    pub fn output(&self) -> Potential {
        self.potential
    }
    /// Set the input of the wire.
    pub fn input(&mut self, potential: &Potential) {
        self.potential = potential.to_owned();
    }
}
fn test_wire_copy() {
    let mut wire1: Wire = Wire::default();
    assert_eq!(wire1.output(), false);
    println!("地址1: {:p}", &wire1);
    let mut wire2 = wire1;
    assert_eq!(wire2.output(), false);
    println!("地址2: {:p}", &wire2);
    wire1.input(&true);
    println!("地址1: {:p}", &wire1);
    // 地址1: 0x16d52e44d
    // 地址2: 0x16d52e4dd
    // 地址1: 0x16d52e44d
}
```

### 函数传值与返回

将值传递给函数，一样会发生 移动 或者 复制，就跟 let 语句一样，下面的代码展示了所有权、作用域的规则：

```rust
fn main() {
    let s = String::from("hello");  // s 进入作用域
    takes_ownership(s);             // s 的值移动到函数里 ...
    // println!("在move进函数后继续使用s: {}",s); 
    //  ^^ 异常，s 所有权归函数takes_ownership，到这里不再有效
    let x = 5;                      // x 进入作用域
    makes_copy(x);                  // x 应该移动函数里，
                                    // 但 i32 是 Copy 的，所以在后面可继续使用 x
} // 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，
  // 所以不会有特殊操作

fn takes_ownership(some_string: String) { // some_string 进入作用域
    println!("{}", some_string);
} // 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放

fn makes_copy(some_integer: i32) { // some_integer 进入作用域
    println!("{}", some_integer);
} // 这里，some_integer 移出作用域。不会有特殊操作
```

同样的，函数返回值也有所有权。

所有权很强大，避免了内存的不安全性，但是也带来了一个新麻烦： 总是把一个值传来传去来使用它。 传入一个函数，很可能还要从该函数传出去，结果就是语言表达变得非常啰嗦，幸运的是，Rust 提供了新功能解决这个问题。

## 引用与解引用

常规引用是一个指针类型，指向了对象存储的内存地址。在下面代码中，我们创建一个 i32 值的引用 y，然后使用解引用运算符来解出 y 所使用的值:

```rust
fn main() {
    let x = 5;
    let y = &x;
    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```

悬垂引用也叫做悬垂指针，意思为指针指向某个值后，这个值被释放掉了，而指针仍然存在，其指向的内存可能不存在任何值或已被其它变量重新使用。在 Rust 中编译器可以确保引用永远也不会变成悬垂状态：当你获取数据的引用后，编译器可以确保数据不会在引用结束前被释放，要想释放数据，必须先停止其引用的使用。


### 不可变引用

下面的代码，我们用 s1 的引用作为参数传递给 calculate_length 函数，而不是把 s1 的所有权转移给该函数：

```rust
fn main() {
    let s1 = String::from("hello");
    let len = calculate_length(&s1);
    println!("The length of '{}' is {}.", s1, len);
}
fn calculate_length(s: &String) -> usize {
    s.len()
}
```

`&` 符号即是引用，它们允许你使用值，但是不获取所有权，如图所示：

![](point.webp)

通过 `&s1` 语法，我们创建了一个指向 s1 的引用，但是并不拥有它。因为并不拥有这个值，当引用离开作用域后，其指向的值也不会被丢弃。正如变量默认不可变一样，引用指向的值默认也是不可变的,不能修改借用的变量。

### 可变引用

可以通过可变引用来修改借用变量。

```rust
fn main() {
    let mut s = String::from("hello");
    change(&mut s);
}
fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```
#### 可变引用只能存在一个

可变引用并不是随心所欲、想用就用的，它有一个很大的限制： 同一作用域，特定数据只能有一个可变引用：

```rust
let mut s = String::from("hello");
let r1 = &mut s;
let r2 = &mut s;
// cannot borrow `s` as mutable more than once at a time
println!("{}, {}", r1, r2);
```

这种限制的好处就是使 Rust 在编译期就避免数据竞争，数据竞争可由以下行为造成：

- 两个或更多的指针同时访问同一数据
- 至少有一个指针被用来写入数据
- 没有同步数据访问的机制

数据竞争会导致未定义行为，这种行为很可能超出我们的预期，难以在运行时追踪，并且难以诊断和修复。而 Rust 避免了这种情况的发生，因为它甚至不会编译存在数据竞争的代码！

```rust
let mut s = String::from("hello");
{
    let r1 = &mut s;
} // r1 在这里离开了作用域，所以我们完全可以创建一个新的引用
let r2 = &mut s;
```

#### 可变引用与不可变引用不能同时存在

下面的代码会导致一个错误：
```rust
let mut s = String::from("hello");

let r1 = &s; 
let r2 = &s;
let r3 = &mut s; // 无法借用可变 `s` 因为它已经被借用了不可变

println!("{}, {}, and {}", r1, r2, r3);
```

> 注意，引用的作用域 s 从创建开始，一直持续到它最后一次使用的地方，这个跟变量的作用域有所不同，变量的作用域从创建持续到某一个花括号 `}`

### 结构体字段

假设有如下结构体:

```rust
struct Person {
    name: String,
    age: u32,
}
impl Person {
    // 获取字段的不可变引用,所有权不变
    fn borrow_name(&self) -> &String {
        &self.name
    }
    // 返回字段的切片引用，而不是字段本身
    // 所有权不变
    fn borrow_name_slice(&self) -> &str {
        &self.name
    }
    // 所有权转移
    fn take_name(self) -> String {
        self.name
    }
}
```

## 参考

- [1] [Rust语言圣经](https://course.rs/about-book.html)

