# 正则表达式速查

正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。

<!--more-->

## 元字符

对于字符串"DEF",在正则中视为包含3个字符"D","E","F"和4个位置0-3,"DEF"= 0D1E2F3.

* 如果子表达式匹配到东西,而不是一个位置,并最终保存到匹配的结果中.这样的就称为占有字符.占有字符是互斥的,即一个字符,同一时间只能由一个子表达式匹配。
* 而只匹配一个位置,或匹配的内容并不保存到匹配结果中,这就称为零宽度.零宽度是非互斥的,即一个位置,可以同时有多个零宽度的子表达式匹配.

### 元字符描述

|元字符|描述|
|:---|:----|
|`\b`|匹配单词的开始或结束|
|`\w`|匹配字母或数字或下划线或汉字|
|`\s`|匹配任意空白符,包括空格,TAB,换行符等|
|`\d`|匹配任意数字|
|`.`|匹配出换行符外任意字符|
|`^`|匹配字符串的开始|
|`$`|匹配字符串的结束|

### 字符转义

如果想查找元字符本身,需要使用`\`来转义.如: `\.`

## 重复

|重复字符|描述|
|:---|:---|
|`*`|重复0次或多次|
|`+`|重复1次或多次|
|`?`|重复0次或1次|
|`{n}`|重复n次|
|`{n,}`|重复n次或更多次|
|`{n,m}`|重复n到m次|

__例如:__ `\d{5,12}` 匹配了5到12位的连续数字.

## 字符类

|字符类|描述|
|:---|:---|
|`[]`|方括号中列出匹配字符的集合|

__例如:__ `[0-9]`表示匹配一位数字

## 分支条件 `|`

__例如:__ `\d{5}-\d{4}|\d{5}` 可以匹配连字符间隔的9位数字或5位数字.值得一提的是要注意各个条件的顺序.因为匹配分枝条件时,会从左到右的匹配,如果满足了某个分支,就不会再管其它条件了.

## 分组

|分组|描述|
|:---|:---|
|`()`|括号里的子表达式被作为一组|

__例如:__ `(\d{1,3}\.){3}` 匹配出现3次的`(\d{1,3}\.)`

## 反意

|反意|描述|
|:---|:---|
|`\W`|匹配任意不是字母,数字,下划线,汉字的字符|
|`\S`|匹配任意不是空白符的字符|
|`\D`|匹配任意不是数字的字符|
|`\B`|匹配任意不是单词开头或结束的位置|
|`[^x]`|匹配除了x以外的任意字符|
|`[^aeio]`|匹配除了aeio这几个字符的任意字符|

## 后向引用

使用小括号指定一个子表达式后,匹配到的内容可以用于进一步处理,默认情况下,每个分组会自动拥有一个组号,依次为1,2,3... 另外,分组0对应整个正则表达式.
    使用`\1`代表分组1匹配的文本.如: `\b(\w+)\b\s+\1\b` 这可以用来匹配重复的单词.

|语法|描述|
|:---|:---|
|`(exp)`|匹配exp,并捕获文本到自动命名的组里|
|`(?<name>exp)`|匹配exp,并捕获文本到名为name的组里,也可以写成(?'name'exp)调用有名字的组可以使用`\k<name>`|
|`(?:exp)`|匹配exp,不捕获匹配的文本,也不给此分组分配组号|

## 注释

|语法|描述|
|:---|:---|
|`(?#comment)`|这种类型的分组不对正则表达式的处理产生影响,用于提供注释|

要包含注释的话,最好是启用“忽略模式里的空白符”选项,这样在编写表达式时能任意的添加空格,Tab,换行,而实际使用时这些都将被忽略。启用这个选项后,在`#`后面到这一行结束的所有文本都将被当成注释忽略掉。

例子：

```perl
(?<=           #断言要匹配的文本的前缀
<(\w+)>        #查找尖括号括起来的字母或数字(即HTML/XML标签)
)              #前缀结束
.*             #匹配任意文本
(?=            #断言要匹配的文本的后缀
<\/\1>         #查找尖括号括起来的内容:前面是一个"/",后面是先前捕获的标签
)              #后缀结束
```

## 零宽断言

零宽断言: 用于指定一个位置,并且这个位置满足一定的条件(即断言).

|语法|描述|
|:---|:---|
|`(?=exp)`|匹配exp前面的位置,即断言自身后面能匹配表达式exp|
|`(?<=exp)`|匹配exp后面的位置,即断言自身前面能匹配表达式exp|
|`(?!exp)`|匹配后面不是exp的位置|
|`(?<!exp)`|匹配前面不是exp的位置|

## 贪婪和懒惰

当正则表达式中包含能接受重复的限定符时,通常的行为是匹配尽可能多的字符.如`a.*b`,将会匹配最长的以a开始,以b结束的字符串,若搜索aabab时,它会匹配整个字符串aabab.这是贪婪匹配.有时,我们需要懒惰匹配,就是匹配尽可能少的字符.只要在重复表达式后面加上一个问号.如: `a.*?b` 匹配以a开始,以b结束的字符串.若搜索aabab,它会匹配aab和ab.

常用懒惰限定符
`*?`,`+?`,`??`,`{n,m}?`,`{n,}?`

## 独占模式(+)

同贪婪模式一样，独占模式一样会匹配最长。不过在独占模式下，正则表达式尽可能长地去匹配字符串，一旦匹配不成功就会结束匹配而不会回溯。

```sh
## 独占
ab{1,3}+bc

## 贪婪
ab{1,3}bc
```

abbc 独占匹配失败：`b{1,3}+`会将文本中的2个字母b都匹配上，结果文本中只剩下一个字母c。那么正则中的b和文本中的c进行匹配，当无法匹配时，并不进行回溯，这时候整个文本就无法和正则表达式发生匹配。如果将正则表达式中的加号（+）去掉，那么这个文本整体就是匹配的了。


## 正则表示式处理选项

|处理选项|描述|
|:---|:---|
|`/i`忽略大小写|匹配时不去分大小写|
|`/m`多行模式|更改`^`和`$`的含义,使它们分别匹配每行的行首和行尾而不是仅在字符串的开始和结束匹配|
|`/s`单行模式|更改`.`的含义,使它也能匹配换行符`\n`|
|`/x`忽略空白|忽略表达式中的非转义空白,并启用由`#`标记的注释|
|`/g`全局匹配|主要在将表达式用来替换时起作用，配置为 Global 表示替换所有的匹配。|

## 平衡组/递归匹配

在**perl**中递归匹配可以使用`(?R)`来代表嵌套的表达式.例如匹配递归标签对`<font></font>`可以使用如下正则`<font>(.(?<!</?font>)*|(?R))*</font>`

