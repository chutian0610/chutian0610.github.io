<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/@fortawesome/fontawesome-free@6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/@fancyapps/ui@5.0.31/dist/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/pace-js@1.2.4/themes/blue/pace-theme-fill-left.css"><script src="https://cdn.jsdmirror.com/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"www.victorchu.info","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"waline","storage":false,"lazyload":false,"nav":null,"activeClass":"waline"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"algolia":{"appID":"X9UOD4FSUP","apiKey":"fa32db1f02073025c69da8ebad0a6aa6","indexName":"hexo-next-blog","hits":{"per_page":10}}}</script><script src="/js/config.js"></script><meta name="description" content="OOM(OutOfMemoryError)是java工程师都会了解的一种异常，实质上，OOM并不是只有一种，一共有9种不同类型的OOM：  java.lang.OutOfMemoryError: Java heap space java.lang.OutOfMemoryError: GC Overhead limit exceeded java.lang.OutOfMemoryError: Per"><meta property="og:type" content="article"><meta property="og:title" content="Java OOM Error"><meta property="og:url" content="https://www.victorchu.info/posts/45975fd0/index.html"><meta property="og:site_name" content="代码之旅"><meta property="og:description" content="OOM(OutOfMemoryError)是java工程师都会了解的一种异常，实质上，OOM并不是只有一种，一共有9种不同类型的OOM：  java.lang.OutOfMemoryError: Java heap space java.lang.OutOfMemoryError: GC Overhead limit exceeded java.lang.OutOfMemoryError: Per"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2017-08-01T13:35:37.000Z"><meta property="article:modified_time" content="2025-02-05T07:06:59.600Z"><meta property="article:author" content="Victor Chu"><meta property="article:tag" content="JVM"><meta property="article:tag" content="OOM"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://www.victorchu.info/posts/45975fd0/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.victorchu.info/posts/45975fd0/","path":"/posts/45975fd0/","title":"Java OOM Error"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Java OOM Error | 代码之旅</title><script src="/js/third-party/analytics/baidu-analytics.js"></script><script async src="https://hm.baidu.com/hm.js?277fc29fa80de77c97f4f62b69e94233"></script><link rel="dns-prefetch" href="walineui.victorchu.info"><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="alternate" href="/atom.xml" title="代码之旅" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">代码之旅</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">I love Coding !</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">127</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">97</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">242</span></a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="algolia-stats"><hr></div><div class="algolia-hits"></div><div class="algolia-pagination"></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-heap-space"><span class="nav-number">1.</span> <span class="nav-text">Java heap space</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">1.1.</span> <span class="nav-text">产生的原因</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">1.2.</span> <span class="nav-text">解决方案</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#GC-Overhead-limit-exceeded"><span class="nav-number">2.</span> <span class="nav-text">GC Overhead limit exceeded</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0-2"><span class="nav-number">2.1.</span> <span class="nav-text">产生的原因</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-2"><span class="nav-number">2.2.</span> <span class="nav-text">解决方案</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Permgen-space"><span class="nav-number">3.</span> <span class="nav-text">Permgen space</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0-3"><span class="nav-number">3.1.</span> <span class="nav-text">产生的原因</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-3"><span class="nav-number">3.2.</span> <span class="nav-text">解决方案</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Metaspace"><span class="nav-number">4.</span> <span class="nav-text">Metaspace</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-4"><span class="nav-number">4.1.</span> <span class="nav-text">解决方案</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Unable-to-create-new-native-thread"><span class="nav-number">5.</span> <span class="nav-text">Unable to create new native thread</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0-4"><span class="nav-number">5.1.</span> <span class="nav-text">产生的原因</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-5"><span class="nav-number">5.2.</span> <span class="nav-text">解决方案</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Out-of-swap-space%EF%BC%9F"><span class="nav-number">6.</span> <span class="nav-text">Out of swap space？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90"><span class="nav-number">6.1.</span> <span class="nav-text">原因分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-6"><span class="nav-number">6.2.</span> <span class="nav-text">解决方案</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Requested-array-size-exceeds-VM-limit"><span class="nav-number">7.</span> <span class="nav-text">Requested array size exceeds VM limit</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90-2"><span class="nav-number">7.1.</span> <span class="nav-text">原因分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-7"><span class="nav-number">7.2.</span> <span class="nav-text">解决方案</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Kill-process-or-sacrifice-child"><span class="nav-number">8.</span> <span class="nav-text">Kill process or sacrifice child</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90-3"><span class="nav-number">8.1.</span> <span class="nav-text">原因分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-8"><span class="nav-number">8.2.</span> <span class="nav-text">解决方案</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Direct-buffer-memory"><span class="nav-number">9.</span> <span class="nav-text">Direct buffer memory</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90-4"><span class="nav-number">9.1.</span> <span class="nav-text">原因分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-9"><span class="nav-number">9.2.</span> <span class="nav-text">解决方案</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM-Action"><span class="nav-number">10.</span> <span class="nav-text">JVM Action</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">11.</span> <span class="nav-text">参考</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Victor Chu" src="/images/victor-blog-head.webp"><p class="site-author-name" itemprop="name">Victor Chu</p><div class="site-description" itemprop="description">blog about programming.</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">242</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">97</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">127</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/chutian0610" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;chutian0610" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:victorchu0610@outlook.com" title="E-Mail → mailto:victorchu0610@outlook.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/victorchu" title="Zhihu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;victorchu" rel="noopener me" target="_blank"><i class="fab fa-zhihu fa-fw"></i>Zhihu</a> </span><span class="links-of-author-item"><a href="/images/Wechat.webp" title="WeChat → &#x2F;images&#x2F;Wechat.webp" rel="noopener me"><i class="fa-brands fa-weixin fa-fw"></i>WeChat</a></span></div></div></div></div><div class="sidebar-inner sidebar-blogroll"><div class="links-of-blogroll animated"><div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i> 链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://www.tpfuture.top/" title="https:&#x2F;&#x2F;www.tpfuture.top&#x2F;" rel="noopener" target="_blank">一水轩</a></li></ul></div></div><div class="sidebar-inner sidebar-post-related"><div class="animated"><div class="links-of-blogroll-title"><i class="fa fa-signs-post fa-fw"></i> 相关文章</div><ul class="popular-posts"><li class="popular-posts-item"><a class="popular-posts-link" href="/posts/b30e8283/" rel="bookmark"><time class="popular-posts-time">2017-08-24</time><br>Java虚拟机-元空间</a></li><li class="popular-posts-item"><a class="popular-posts-link" href="/posts/72bd051d/" rel="bookmark"><time class="popular-posts-time">2017-08-22</time><br>Java虚拟机-内存布局</a></li><li class="popular-posts-item"><a class="popular-posts-link" href="/posts/d4df40c6/" rel="bookmark"><time class="popular-posts-time">2021-12-16</time><br>算法之CRC</a></li><li class="popular-posts-item"><a class="popular-posts-link" href="/posts/4c79bccf/" rel="bookmark"><time class="popular-posts-time">2018-11-15</time><br>语法范式</a></li></ul></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.victorchu.info/posts/45975fd0/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/victor-blog-head.webp"><meta itemprop="name" content="Victor Chu"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="代码之旅"><meta itemprop="description" content="blog about programming."></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Java OOM Error | 代码之旅"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Java OOM Error</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2017-08-01 21:35:37" itemprop="dateCreated datePublished" datetime="2017-08-01T21:35:37+08:00">2017-08-01</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2025-02-05 15:06:59" itemprop="dateModified" datetime="2025-02-05T15:06:59+08:00">2025-02-05</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a> </span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a> </span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Waline：</span> <a title="waline" href="/posts/45975fd0/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/45975fd0/" itemprop="commentCount"></span> </a></span><span class="post-meta-item" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="waline-pageview-count" data-path="/posts/45975fd0/"></span> </span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>12k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>20 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>OOM(OutOfMemoryError)是java工程师都会了解的一种异常，实质上，OOM并不是只有一种，一共有9种不同类型的OOM：</p><ul><li>java.lang.OutOfMemoryError: Java heap space</li><li>java.lang.OutOfMemoryError: GC Overhead limit exceeded</li><li>java.lang.OutOfMemoryError: Permgen space</li><li>java.lang.OutOfMemoryError: Metaspace</li><li>java.lang.OutOfMemoryError: Unable to create new native thread</li><li>java.lang.OutOfMemoryError: reason stack_trace_with_native_method</li><li>java.lang.OutOfMemoryError: Requested array size exceeds VM limit</li><li>java.lang.OutOfMemoryError: Kill process or sacrifice child</li><li>java.lang.OutOfMemoryError: Direct buffer memory</li></ul><p>不同的原因触发不同类型的OOM，每种OOM类型的解决方案也不同。</p><span id="more"></span><h1 id="Java-heap-space">Java heap space</h1><p>java应用程序使用的内存是有上限的，这在程序启动时会被指定。java的堆的大小可以通过指定JVM参数-Xmx来设置，如果没有明确指定, 则根据操作系统平台和物理内存的大小来确定。。当应用程序试图向堆中存入数据，但堆中空间不足时，会抛出<code>java.lang.OutOfMemoryError: Java heap space</code>。注意，此时的物理内存可能仍有很多，java只能使用预设置大小的内存空间。</p><h2 id="产生的原因">产生的原因</h2><ol><li>一般的情况是，大数据量的程序预设置的空间过小，无法分配内存,此时只要增加堆内存的大小, 程序就能正常运行。</li><li>超出预期的访问量/数据量。 应用系统设计时,一般是有 “容量” 定义的, 用来处理一定量的数据/业务。 如果数据量突然飙升, 超过预期的阈值, 类似于时间坐标系中针尖形状的图谱, 那么在峰值所在的时间段, 程序很可能就会卡死、并触发<code>java.lang.OutOfMemoryError: Java heap space</code>错误。</li><li>内存泄露(Memory leak). 这也是一种经常出现的情形。由于代码中的某些错误, 导致系统占用的内存越来越多. 如果某个方法/某段代码存在内存泄漏的, 每执行一次, 就会（有更多的垃圾对象）占用更多的内存. 随着运行时间的推移, 泄漏的对象耗光了堆中的所有内存, 那么 <code>java.lang.OutOfMemoryError: Java heap space</code>错误就被抛出了。</li></ol><h2 id="解决方案">解决方案</h2><ol><li>首先，应该尝试提高堆空间的大小(如果设置的最大堆空间，并不大)。例如<code>-Xmx4g</code>将堆设置为4g大小。</li><li>在许多情况下，提供更多的Java堆空间并不能解决问题。例如，如果您的应用程序包含内存泄漏，则添加更多堆只会推迟<code>java.lang.OutOfMemoryError: Java heap space</code>异常的触发。此外，增加Java堆大小也会增加GC stop-the-world的时长，从而影响应用程序的吞吐量。此时需要确定代码的哪一部分负责分配最多的内存：<ul><li>哪些对象占据堆的大部分</li><li>这些对象在源代码中分配的位置</li></ul></li><li>分析JVM dump(可以使用<code>-XX:+HeapDumpOnOutOfMemoryError</code>)</li></ol><h1 id="GC-Overhead-limit-exceeded">GC Overhead limit exceeded</h1><p>在Java程序中, 只需要关心内存分配就行。如果某块内存不再使用, 垃圾收集(Garbage Collection) 模块会自动执行清理。<code>java.lang.OutOfMemoryError: GC overhead limit exceeded</code>这种情况发生的原因是, 程序基本上耗尽了所有的可用内存, GC也清理不了。</p><h2 id="产生的原因-2">产生的原因</h2><p>JVM抛出<code>java.lang.OutOfMemoryError: GC overhead limit exceeded</code>错误就是发出了这样的信号: 执行垃圾收集的时间比例太大, 有效的运算量太小. 默认情况下, 如果GC花费的时间超过 98%, 并且GC回收的内存少于 2%, JVM就会抛出这个错误。</p><p>注意, java.lang.OutOfMemoryError: GC overhead limit exceeded 错误只在连续多次 GC 都只回收了不到2%的极端情况下才会抛出。假如不抛出 GC overhead limit 错误会发生什么情况呢? 那就是GC清理的这么点内存很快会再次填满, 迫使GC再次执行. 这样就形成恶性循环, CPU使用率一直是100%, 而GC却没有任何成果. 系统用户就会看到系统卡死 - 以前只需要几毫秒的操作, 现在需要好几分钟才能完成。</p><h2 id="解决方案-2">解决方案</h2><ul><li>一种表面上的解决方案是在启动时添加参数:<code>-XX:-UseGCOverheadLimit</code>,JVM 就不会抛出 <code>java.lang.OutOfMemoryError: GC overhead limit exceeded</code> 错误信息。这不能真正地解决问题，只能推迟一点 out of memory 错误发生的时间，到最后还得进行其他处理。指定这个选项, 会将原来的<code>java.lang.OutOfMemoryError: GC overhead limit exceeded</code>错误掩盖，变成更常见的<code>java.lang.OutOfMemoryError: Java heap space</code>错误消息。</li><li>有时候触发 GC overhead limit 错误的原因, 是因为分配给JVM的堆内存不足。这种情况下只需要增加堆内存大小即可。</li><li>分析JVM dump(<code>-XX:+HeapDumpOnOutOfMemoryError</code>)。</li></ul><h1 id="Permgen-space">Permgen space</h1><p>永久代由JVM参数<code>-XX:MaxPermSize</code>设置。 如果没有明确指定, 则根据操作系统平台和物理内存的大小来确定。<code>java.lang.OutOfMemoryError: PermGen space</code>错误信息所表达的意思是: 永久代(Permanent Generation) 内存区域已满。</p><h2 id="产生的原因-3">产生的原因</h2><ol><li><strong>在JDK1.7及之前的版本</strong>, 永久代(permanent generation) 主要用于存储加载/缓存到内存中的 class 定义, 包括 class 的 名称(name), 字段(fields), 方法(methods)和字节码(method bytecode); 以及常量池(constant pool information); 对象数组(object arrays)/类型数组(type arrays)所关联的 class, 还有 JIT 编译器优化后的class信息等。很容易看出, PermGen 的使用量和JVM加载到内存中的 class 数量/大小有关。可以说 <code>java.lang.OutOfMemoryError: PermGen space</code>的主要原因, 是加载到内存中的 class 数量太多或体积太大。</li></ol><p>我们可以使用 CGLIB 来模拟这个错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM Option: -XX:PermSize=1M -XX:MaxPerSize=1M</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaMethodAreaOOM</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OOMObject</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">            enhancer.setSuperClass(OOMObject.class);</span><br><span class="line">            enhancer.setUserCache(<span class="literal">false</span>);</span><br><span class="line">            enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>()&#123;</span><br><span class="line">                <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj,Method method,Object[] args,MethodProxy proxy)</span><span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">                    <span class="keyword">return</span> proxy.invokeSuper(obj,args);</span><br><span class="line">                &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            enhancer.create();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>另一种常见的情况是在重新部署web应用时, 很可能会引起<code>java.lang.OutOfMemoryError: Permgen space</code>错误,理论上说，redeploy 时, Tomcat之类的容器会使用新的 classloader 来加载新的 class, 让垃圾收集器 将之前的 classloader (连同加载的class一起)清理掉,。但实际情况可能并不乐观, 很多第三方库, 以及某些受限的共享资源, 如 thread, JDBC驱动, 以及文件系统句柄(handles), 都会导致不能彻底卸载之前的 classloader. 那么在 redeploy 时, 之前的class仍然驻留在PermGen中, 每次重新部署都会产生几十MB，甚至上百MB的垃圾。</li></ol><h2 id="解决方案-3">解决方案</h2><ol><li>在程序启动时, 如果 PermGen 耗尽而产生 OutOfMemoryError 错误, 那很容易解决. 增加 PermGen 的大小, 让程序拥有更多的内存来加载 class 即可. 修改 -XX:MaxPermSize 启动参数, 类似下面这样:<code>-XX:MaxPermSize=512m</code></li><li>如果是redeploy 时产生的 OutOfMemoryError，我们可以进行堆转储分析，然后找出重复的类, 特别是类加载器(classloader)对应的 class. 你可能需要比对所有的 classloader, 来找出当前正在使用的那个。</li><li>如果在运行的过程中发生 OutOfMemoryError, 首先需要确认 GC是否能从PermGen中卸载class。 官方的JVM在这方面是相当的保守(在加载class之后,就一直让其驻留在内存中,即使这个类不再被使用)。那么我们就需要允许JVM卸载class。使用下面的启动参数:<code>-XX:+CMSClassUnloadingEnabled</code>.启用以后, GC 将会清理 PermGen, 卸载无用的 class. 当然, 这个选项只有在设置 UseConcMarkSweepGC 时生效。 如果使用了 ParallelGC, 或者 Serial GC 时, 那么需要切换为CMS:<code>-XX:+UseConcMarkSweepGC</code></li></ol><h1 id="Metaspace">Metaspace</h1><p>从Java 8开始,内存结构发生重大改变, 不再使用Permgen, 而是引入一个新的空间: Metaspace. Metaspace 的使用量与JVM加载到内存中的 class 数量/大小有关。可以说, java.lang.OutOfMemoryError: Metaspace 错误的主要原因, 是加载到内存中的 class 数量太多或者体积太大。</p><h2 id="解决方案-4">解决方案</h2><ul><li>如果抛出与 Metaspace 有关的 OutOfMemoryError , 第一解决方案是增加 Metaspace 的大小. 使用下面这样的启动参数:<code>-XX:MaxMetaspaceSize=512m</code>.</li><li>还有一种方案是直接去掉 Metaspace 的大小限制。 但需要注意, 不限制Metaspace内存的大小, 假若物理内存不足, 有可能会引起内存交换(swapping), 严重拖累系统性能。 此外,还可能造成native内存分配失败等问题。</li></ul><h1 id="Unable-to-create-new-native-thread">Unable to create new native thread</h1><p>Java程序本质上是多线程的, 可以同时执行多项任务。JVM中的线程需要内存空间来执行自己的任务. 如果线程数量太多, 就会引入新的问题:<code>java.lang.OutOfMemoryError: Unable to create new native thread</code>。错误表达的意思是: 程序创建的线程数量已达到上限值。</p><h2 id="产生的原因-4">产生的原因</h2><p>JVM向操作系统申请创建新的 native thread(原生线程)时, 就有可能会碰到 java.lang.OutOfMemoryError: Unable to create new native thread 错误. 如果底层操作系统创建新的 native thread 失败, JVM就会抛出相应的OutOfMemoryError. 原生线程的数量受到具体环境的限制, 但总体来说, 导致 <code>java.lang.OutOfMemoryError: Unable to create new native thread</code> 错误的场景大多经历以下这些阶段:</p><ol><li>Java程序向JVM请求创建一个新的Java线程;</li><li>JVM本地代码(native code)代理该请求, 尝试创建一个操作系统级别的 native thread(原生线程);</li><li>操作系统尝试创建一个新的native thread, 需要同时分配一些内存给该线程;</li><li>如果操作系统的虚拟内存已耗尽, 或者是受到32位进程的地址空间限制(约2-4GB), OS就会拒绝本地内存分配;</li><li>JVM抛出 java.lang.OutOfMemoryError: Unable to create new native thread 错误。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在一个死循环中创建并启动很多新线程。代码执行后, 很快就会达到操作系统的限制, 报出 java.lang.OutOfMemoryError: Unable to create new native thread 错误。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxThread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                        <span class="keyword">synchronized</span>(s)&#123;</span><br><span class="line">                            count += <span class="number">1</span>;</span><br><span class="line">                            System.err.println(<span class="string">&quot;New thread #&quot;</span>+count);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                                System.err.println(e);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解决方案-5">解决方案</h2><ol><li>可以修改系统限制来避开 Unable to create new native thread 问题. 假如JVM受到用户空间(user space)文件数量的限制, 像下面这样,就应该想办法增大这个值:</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//在这种情况下，很有可能产生` java.lang.OutOfMemoryError: Unable to create new native thread`异常。</span><br><span class="line"></span><br><span class="line">// 用户可创建线程总数</span><br><span class="line">$ <span class="built_in">ulimit</span> -u</span><br><span class="line">1024</span><br><span class="line">// 进程当前运行的线程数</span><br><span class="line">$ pstree -p pid | <span class="built_in">wc</span> -l</span><br><span class="line">1000</span><br></pre></td></tr></table></figure><ol start="2"><li>更多的情况, 触发创建 native 线程时的OutOfMemoryError, 表明编程存在BUG. 比如, 程序创建了成千上万的线程, 很可能就是某些地方出大问题了。此时可以使用thread dump 来分析问题。</li><li>还有一种情况是，JVM上设置堆栈大小有问题，可以通过<code>-Xss64k</code>,来设置堆栈大小为64k(每个线程允许的最小堆栈空间量)。但是要注意的是，堆栈过小，可能会导致<code>StackOverflowError</code>，调整这个值，需要做个平衡。</li></ol><h1 id="Out-of-swap-space？">Out of swap space？</h1><p>JVM启动参数指定了最大内存限制。如 -Xmx 以及相关的其他启动参数. 假若JVM使用的内存总量超过可用的物理内存, 操作系统就会用到虚拟内存。错误信息<code>java.lang.OutOfMemoryError: Out of swap space?</code>表明, 交换空间(swap space,虚拟内存) 不足,是由于物理内存和交换空间都不足所以导致内存分配失败。</p><h2 id="原因分析">原因分析</h2><p>如果 native heap 内存耗尽, 内存分配时, JVM 就会抛出 java.lang.OutOfmemoryError: Out of swap space? 错误消息, 这个消息告诉用户, 请求分配内存的操作失败了。</p><p>Java进程使用了虚拟内存才会发生这个错误。 对 Java的垃圾收集 来说这是很难应付的场景。即使现代的 GC算法 很先进, 但虚拟内存交换引发的系统延迟, 会让 GC暂停时间 膨胀到令人难以容忍的地步。</p><p>通常是操作系统层面的原因导致 java.lang.OutOfMemoryError: Out of swap space? 问题, 例如:</p><ul><li>操作系统的交换空间太小。</li><li>机器上的某个进程耗光了所有的内存资源。</li><li>也可能是应用程序的本地内存泄漏(native leak)引起的, 例如, 某个程序/库不断地申请本地内存,却不进行释放。</li></ul><h2 id="解决方案-6">解决方案</h2><p>第一种, 也是最简单的方法, 增加虚拟内存(swap space) 的大小. 各操作系统的设置方法不太一样, 比如Linux,可以使用下面的命令设置:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 创建了一个大小为 640MB 的 swapfile(交换文件) 并启用该文件。</span><br><span class="line">swapoff -a</span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=swapfile bs=1024 count=655360</span><br><span class="line">mkswap swapfile</span><br><span class="line">swapon swapfile</span><br></pre></td></tr></table></figure><p>因为垃圾收集器需要清理整个内存空间, 所以虚拟内存对 Java GC 来说是难以忍受的。存在内存交换时, 执行 垃圾收集 的 暂停时间 会增加上百倍,甚至更多, 所以最好不要增加虚拟内存。</p><p>如果程序允许环境还受到 “坏邻居效应” 的干扰, JVM还要和其他程序竞争计算资源, 那么提高性能的办法就是单独部署到专用的服务器/虚拟机中。也可以进行程序优化, 降低内存空间的使用量, 通过堆转储分析器可以检测到哪些方法/代码分配了大量的内存。</p><h1 id="Requested-array-size-exceeds-VM-limit">Requested array size exceeds VM limit</h1><p>Java平台限制了数组的最大长度。各个版本的具体限制可能稍有不同, 但范围都在 1 ~ 21亿 之间。如果程序抛出 java.lang.OutOfMemoryError: Requested array size exceeds VM limit 错误, 就说明想要创建的数组长度超过限制。</p><h2 id="原因分析-2">原因分析</h2><p>这个错误是由JVM中的本地代码抛出的. 在真正为数组分配内存之前, JVM会执行一项检查: 要分配的数据结构在该平台是否可以寻址(addressable). 当然, 这个错误比你所想的还要少见得多。</p><p>一般很少看到这个错误, 因为Java使用 int 类型作为数组的下标(index, 索引)。在Java中, int类型的最大值为 2^31 – 1 = 2,147,483,647。大多数平台的限制都约等于这个值 —— 例如在 64位的 MACBOOK Pro 上, Java 1.7 平台可以分配长度为 2,147,483,645(Integer.MAX_VALUE-2 长度)的数组。</p><p>再增加一点点长度, 变成 Integer.MAX_VALUE-1 时, 就会抛出我们所熟知的 OutOfMemoryError:<code>Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Requested array size exceeds VM limit</code>,在有的平台上, 这个最大限制可能还会更小一些, 例如在32位Linux, OpenJDK 6 上面, 数组长度大约在 11亿左右(约2^30) 就会抛出 “java.lang.OutOfMemoryError: Requested array size exceeds VM limit“ 错误。要找出具体的限制值, 可以执行一个小小的测试用例, 具体示例参见下文。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[Integer.MAX_VALUE-i];</span><br><span class="line">    System.out.format(<span class="string">&quot;Successfully initialized an array with %,d elements.\n&quot;</span>, Integer.MAX_VALUE-i);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    t.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中,for循环迭代4次, 每次都去初始化一个 int 数组, 长度从 Integer.MAX_VALUE-3 开始递增, 到 Integer.MAX_VALUE 为止.</p><h2 id="解决方案-7">解决方案</h2><p>发生 java.lang.OutOfMemoryError: Requested array size exceeds VM limit 错误的原因可能是:</p><ul><li>数组太大, 最终长度超过平台限制值, 但小于 Integer.MAX_INT</li><li>为了测试系统限制, 故意分配长度大于 2^31-1 的数组。</li></ul><p>第一种情况, 需要检查业务代码, 确认是否真的需要那么大的数组。如果可以减小数组长度, 那就万事大吉. 如果不行，可能需要把数据拆分为多个块, 然后根据需要按批次加载。</p><p>如果是第二种情况, 请记住, Java 数组用 int 值作为索引。所以数组元素不能超过 2^31-1 个. 实际上, 代码在编译阶段就会报错,提示信息为 “error: integer number too large”。</p><p>如果确实需要处理超大数据集, 那就要考虑调整解决方案了. 例如拆分成多个小块,按批次加载; 或者放弃使用标准库,而是自己处理数据结构,比如使用 sun.misc.Unsafe 类, 通过Unsafe工具类可以像C语言一样直接分配内存。</p><h1 id="Kill-process-or-sacrifice-child">Kill process or sacrifice child</h1><p>操作系统(operating system)构建在进程(process)的基础上. 进程由内核作业(kernel jobs)进行调度和维护, 其中有一个内核作业称为 “Out of memory killer(OOM终结者)”, 与本节所讲的 OutOfMemoryError 有关。</p><p>Out of memory killer 在可用内存极低的情况下会杀死某些进程。只要达到触发条件就会激活, 选中某个进程并杀掉。 通常采用启发式算法, 对所有进程计算评分(heuristics scoring), 得分最低的进程将被 kill 掉。因此 Out of memory: Kill process or sacrifice child 和前面所讲的 OutOfMemoryError 都不同, 因为它既不由JVM触发,也不由JVM代理, 而是系统内核内置的一种安全保护措施(日志在系统日志中)。</p><p>如果可用内存(含swap)不足, 就有可能会影响系统稳定, 这时候 Out of memory killer 就会设法找出流氓进程并杀死他, 也就是引起 Out of memory: kill process or sacrifice child 错误。</p><h2 id="原因分析-3">原因分析</h2><p>默认情况下, Linux kernels(内核)允许进程申请的量超过系统可用内存. 这是因为,在大多数情况下, 很多进程申请了很多内存, 但实际使用的量并没有那么多. 这样的话,可能会有一个问题, 假若某些程序占用了大量的系统内存, 那么可用内存量就会极小, 导致没有内存页面(pages)可以分配给需要的进程。可能这时候会出现极端情况, 就是 root 用户也不能通过 kill 来杀掉流氓进程. 为了防止发生这种情况, 系统会自动激活 killer, 查找流氓进程并将其杀死。</p><h2 id="解决方案-8">解决方案</h2><ul><li>最简单的办法就是将系统迁移到内存更大的实例中。</li><li>可以通过 <a target="_blank" rel="noopener" href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/performance_tuning_guide/s-memory-captun">OOM killer 调优</a></li><li>做负载均衡(水平扩展,集群).</li><li>降低应用对内存的需求.</li></ul><h1 id="Direct-buffer-memory">Direct buffer memory</h1><p>直接缓冲存储器是OS的本机存储器，由JVM进程使用，而不是在JVM堆中使用。Java NIO使用它快速将数据写入网络或磁盘; 无需在JVM堆和本机内存之间进行复制。Java应用程序可以设置JVM参数-XX：MaxDirectMemorySize来限制直接缓冲区内存大小。如果未设置此类参数，则JVM可以使用所有可用的OS本机内存。</p><p>由 DirectMemory 导致的内存溢出，一个明显的特征是在 Heap Dump 文件中不会看见明显的异常，如果发现 OOM 之后 Dump 文件很小，而程序中又直接或间接使用了 NIO ，那就可以考虑检查一下是不是这方面的原因。</p><h2 id="原因分析-4">原因分析</h2><ul><li>最常见的原因是直接内存不足导致。例如:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM Option: -Xmx20M -XX:MaxDirectMemorySize=10M</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectMemoryOOM</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">unsafeField</span> <span class="operator">=</span> Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</span><br><span class="line">        unsafeField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) unsafeField.get(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            unsafe.allocateMemory(size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>内存泄漏导致，<a target="_blank" rel="noopener" href="https://bugs.openjdk.java.net/browse/JDK-8147468">JDK BUG</a>,在<a target="_blank" rel="noopener" href="https://www.oracle.com/technetwork/java/javase/8u102-relnotes-3021767.html">JDK 8u102更新发行说明</a>中，添加了一个新的系统属性jdk.nio.maxCachedBufferSize来修复此问题。这个参数用于限制可以被缓存的DirectByteBuffer的大小，对于超过这个限制的DirectByteBuffer不会被缓存到ThreadLocal的bufferCache中，这样就能被GC正常回收掉。但是在本说明中指出，这个参数只能修复这个问题的一部分而不是所有情况。</li><li>使用了<code>-XX:+DisableExplicitGC</code>禁用system.gc方法的直接调用full gc。ByteBuffer类提供allocateDirect(int capacity)进行堆外内存的申请，底层通过unsafe.allocateMemory(size)实现，会调用malloc方法进行内存分配。实际上，在java堆里是维护了一个记录堆外地址和大小的DirectByteBuffer的对象，所以GC是能通过操作DirectByteBuffer对象来间接操作对应的堆外内存，从而达到释放堆外内存的目的。但如果一旦这个DirectByteBuffer对象熬过了young GC到达了Old区，同时Old区一直又没做CMS GC或者Full GC的话，这些“冰山对象”会将系统物理内存慢慢消耗掉。对于这种情况JVM留了后手，Bits给DirectByteBuffer前首先需要向Bits类申请额度，Bits类维护了一个全局的totalCapacity变量，记录着全部DirectByteBuffer的总大小，每次申请，都先看看是否超限（堆外内存的限额默认与堆内内存Xmx设定相仿），如果已经超限，会主动执行Sytem.gc()，System.gc()会对新生代的老生代都会进行内存回收，这样会比较彻底地回收DirectByteBuffer对象以及他们关联的堆外内存。但如果启动时通过-DisableExplicitGC禁止了System.gc()，那么这里就会出现比较严重的问题，导致回收不了DirectByteBuffer底下的堆外内存了。所以在类似Netty的框架里对DirectByteBuffer是框架自己主动回收来避免这个问题。</li></ul><h2 id="解决方案-9">解决方案</h2><ul><li>尝试增加堆外内存：<code>-XX:MaxDirectMemorySize</code></li><li>小心使用<code>-XX:+DisableExplicitGC</code>，特别是在有nio操作时。</li><li>可以考虑自己回收</li></ul><h1 id="JVM-Action">JVM Action</h1><p>JVM提供了很多处理内存溢出的相关参数:</p><ol><li><code>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath</code>: 只要给JVM传递了这2个参数，当发生内存溢出的时候，JVM会自动在指定目录下生成内存映像文件。默认情况下，命名为<code>java_[PID].hprof</code>。</li><li><code>-XX:OnOutOfMemoryError</code>:当发生内存溢出的时候，还可以让JVM调用任一个shell脚本。可以通过使用 <code>XX:OnOutOfMemoryError</code>中的<code>%p</code>占位符来传递 Java 进程的PID:<code>-XX:OnOutOfMemoryError=&quot;jstack %p&quot;</code>。HeapDumpOnOutOfMemoryError和OnOutOfMemoryError先后顺序依赖jvm的实现。</li><li><code>-XX:+ExitOnOutOfMemoryError</code>:如果传递了这个参数，当发生内存溢出的时候，JVM就会立马退出。</li><li><code>-XX:+CrashOnOutOfMemoryError</code>:如果给JVM传递了这个参数，当发生内存溢出的时候，JVM就会退出，同时，JVM会产生文本和二进制格式的崩溃日志。</li></ol><blockquote><p>如果同时配置了<code>-XX:+HeapDumpOnOutOfMemoryError</code>和<code>-XX:+ExitOnOutOfMemoryError</code>，hotspot 虚拟机会先 dump，然后退出。</p></blockquote><p>除了在启动时设置，也可以通过 JMX 暴露的HotSpotDiagnosticMBean来配置 VM 选项。</p><h1 id="参考">参考</h1><ul><li>[1] <a target="_blank" rel="noopener" href="https://plumbr.io/outofmemoryerror">out of memory error</a></li><li>[2] <a target="_blank" rel="noopener" href="https://www.oracle.com/technetwork/java/hotspotfaq-138619.html#threads_oom">threads_oom</a></li><li>[3] <a target="_blank" rel="noopener" href="https://tech.ebayinc.com/engineering/sre-case-study-triage-a-non-heap-jvm-out-of-memory-issue/">SRE Case Study: Triaging a Non-Heap JVM Out of Memory Issue</a></li><li>[4] <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000018695161">聊聊jvm的-XX:MaxDirectMemorySize</a></li><li>[5] <a target="_blank" rel="noopener" href="https://hllvm-group.iteye.com/group/topic/27945">HotSpot JVM调优的&quot;标准参数&quot;的各种陷阱</a></li><li>[6] <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e1503204a059">关于MaxDirectMemorySize的设置</a></li></ul></div><footer class="post-footer"><div class="reward-container"><div>请我一杯咖啡吧！</div><button>赞赏</button><div class="post-reward"><div><img src="/images/weixinpay.webp" alt="Victor Chu 微信"> <span>微信</span></div><div><img src="/images/alpay.webp" alt="Victor Chu 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"><strong>本文作者： </strong>Victor Chu</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://www.victorchu.info/posts/45975fd0/" title="Java OOM Error">https://www.victorchu.info/posts/45975fd0/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="followme"><span>欢迎关注我的其它发布渠道</span><div class="social-list"><div class="social-item"><a target="_blank" class="social-link" href="/atom.xml"><span class="icon"><i class="fa fa-rss"></i> </span><span class="label">RSS</span></a></div><div class="social-item"><a target="_blank" class="social-link" href="/images/wechat_channel.webp"><span class="icon"><i class="fab fa-weixin"></i> </span><span class="label">WeChat</span></a></div></div></div><div class="post-tags"><a href="/tags/JVM/" rel="tag"><i class="fa fa-tag"></i> JVM</a> <a href="/tags/OOM/" rel="tag"><i class="fa fa-tag"></i> OOM</a></div><div class="social-like a2a_kit a2a_kit_size_32 a2a_default_style"><a class="a2a_dd" target="_blank" rel="noopener" href="https://www.addtoany.com/share"></a> <a class="a2a_button_facebook"></a> <a class="a2a_button_twitter"></a> <a class="a2a_button_wechat"></a> <a class="a2a_button_pocket"></a> <a class="a2a_button_instapaper"></a> <a class="a2a_button_pinboard"></a> <a class="a2a_button_kindle_it"></a> <a class="a2a_button_copy_link"></a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/351dcf8c/" rel="prev" title="正则表达式速查"><i class="fa fa-angle-left"></i> 正则表达式速查</a></div><div class="post-nav-item"><a href="/posts/72bd051d/" rel="next" title="Java虚拟机-内存布局">Java虚拟机-内存布局 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">浙ICP备18037908号-1 </a><img src="/images/gongan_icon.webp" alt=""><a href="https://beian.mps.gov.cn/#/query/webSearch?code=33010902002043" rel="noopener" target="_blank">浙公网安备 33010902002043号</a></div><div class="copyright">&copy; 2016 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Victor Chu</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span title="站点总字数">2m</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">56:29</span></span></div><div class="powered-by">由<a href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" class="theme-link" rel="noopener" target="_blank"><img src="/images/upyun_logo.webp" width="50" style="display:inline"></a>提供CDN服务</div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdn.jsdmirror.com/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdn.jsdmirror.com/npm/@fancyapps/ui@5.0.31/dist/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous"></script><script src="https://cdn.jsdmirror.com/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://cdn.jsdmirror.com/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdn.jsdmirror.com/npm/algoliasearch@4.23.3/dist/algoliasearch-lite.umd.js" integrity="sha256-1QNshz86RqXe/qsCBldsUu13eAX6n/O98uubKQs87UI=" crossorigin="anonymous"></script><script src="https://cdn.jsdmirror.com/npm/instantsearch.js@4.67.0/dist/instantsearch.production.min.js" integrity="sha256-TW7D3X/i/W+RUgEeDppEnFT2ixv5lzplKH0c58D92dY=" crossorigin="anonymous"></script><script src="/js/third-party/search/algolia-search.js"></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":"dark","js":{"url":"https://cdn.jsdmirror.com/npm/mermaid@11.5.0/dist/mermaid.min.js","integrity":"sha256-2obLuIPcceEhkE3G09G33hBdmE55ivVcZUlcKcGNHjU="}}</script><script src="/js/third-party/tags/mermaid.js"></script><script src="/js/third-party/fancybox.js"></script><script src="/js/third-party/pace.js"></script><script src="/js/third-party/addtoany.js"></script><script class="next-config" data-name="enableMath" type="application/json">false</script><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/katex@0.16.9/dist/katex.min.css" integrity="sha256-UF1fgpAiu3tPJN/uCqEUHNe7pnr+QR0SQDNfgglgtcM=" crossorigin="anonymous"><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"walineui.victorchu.info","cssUrl":"https://cdn.jsdmirror.com/npm/@waline/client@3/dist/waline.min.css","commentCount":true,"pageview":true,"requiredMeta":["nick","mail"],"login":"force","libUrl":"https://cdn.jsdmirror.com/npm/@waline/client@3/dist/waline.umd.min.js","dark":"body.darkmode--activated","el":"#waline","comment":true,"path":"/posts/45975fd0/"}</script><link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/@waline/client@3/dist/waline.min.css"><script>document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});</script><script src="https://cdn.jsdmirror.com/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script><script>var options = {
  bottom: '64px',
  right: '32px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();</script><script defer src="/_vercel/insights/script.js"></script><script defer src="/_vercel/speed-insights//script.js"></script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script></body></html>