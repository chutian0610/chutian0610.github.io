<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>IO - 标签 - Victor's Code Journey</title><link>http://www.victorchu.info/tags/io/</link><description>IO - 标签 - Victor's Code Journey</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><managingEditor>victorchu0610@outlook.com (victorchutian)</managingEditor><webMaster>victorchu0610@outlook.com (victorchutian)</webMaster><lastBuildDate>Wed, 30 Mar 2022 22:42:53 +0800</lastBuildDate><atom:link href="http://www.victorchu.info/tags/io/" rel="self" type="application/rss+xml"/><item><title>Scalable IO in Java</title><link>http://www.victorchu.info/posts/2022/03/fda43133/</link><pubDate>Wed, 30 Mar 2022 22:42:53 +0800</pubDate><author><name>victorchutian</name></author><guid>http://www.victorchu.info/posts/2022/03/fda43133/</guid><description><![CDATA[<div class="featured-image">
                <img src="/feature-images/java.webp" referrerpolicy="no-referrer">
            </div><p>本文是 Doug Lea 的 &ldquo;Scalable IO in Java&rdquo; 读书笔记</p>]]></description></item><item><title>Java NIO: DirectBuffer</title><link>http://www.victorchu.info/posts/2021/07/250648ae/</link><pubDate>Sat, 24 Jul 2021 15:45:21 +0800</pubDate><author><name>victorchutian</name></author><guid>http://www.victorchu.info/posts/2021/07/250648ae/</guid><description><![CDATA[<div class="featured-image">
                <img src="/feature-images/java.webp" referrerpolicy="no-referrer">
            </div><p>前面介绍过Java Buffer使用的内存分堆内内存(Heap)和堆外内存(No Heap)，本文将介绍DirectBuffer的实现原理，以DirectByteBuffer为例<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>。</p>]]></description></item><item><title>Java NIO: Buffer</title><link>http://www.victorchu.info/posts/2021/07/af744943/</link><pubDate>Fri, 23 Jul 2021 14:45:38 +0800</pubDate><author><name>victorchutian</name></author><guid>http://www.victorchu.info/posts/2021/07/af744943/</guid><description><![CDATA[<div class="featured-image">
                <img src="/feature-images/java.webp" referrerpolicy="no-referrer">
            </div><p>Java 传统 IO 是面向流的，流的处理是单向「只能从输入流中读取数据，或是向输出流中写入数据」且阻塞的。通常都是从输入流中边读取数据边处理数据，这样 IO 处理效率就会很低，基于上述原因，JDK1.4 引入了 NIO，而 NIO 是面向 Buffer 的，在处理 IO 操作的时候，会一次性将 Channel 中的数据读取到 Buffer 中然后在做后续处理，向 Channel 中写入数据也是一样，也是需要一个 Buffer 做中转，然后将 Buffer 中的数据批量写入 Channel 中。通过增加Buffer支持了数据的灵活处理。</p>
<p>除此之外，Nio Buffer 还提供了堆外的直接内存和内存映射相关的访问方式，来避免内存之间的来回拷贝，所以即使在传统 IO 中用到了 BufferedInputStream 也还是没办法和 Nio Buffer 相匹敌。本文将结合源码介绍 ByteBuffer^[本文JDK源码基于Java8]。</p>]]></description></item><item><title>操作系统-IO</title><link>http://www.victorchu.info/posts/2021/02/d9090a0a/</link><pubDate>Tue, 16 Feb 2021 20:14:27 +0800</pubDate><author><name>victorchutian</name></author><guid>http://www.victorchu.info/posts/2021/02/d9090a0a/</guid><description><![CDATA[<div class="featured-image">
                <img src="/feature-images/computer.webp" referrerpolicy="no-referrer">
            </div><p>先介绍下系统的IO原型架构。CPU 通过内存总线(memory bus)连接到系统内存。显卡或者其他高性能 I/O 设备通过常规的I/O 总线(I/O bus)连接到系统，在许多现代系统中会是 PCI 或它的衍生形式。最后，更下面是外围总线(peripheral bus)，比如 SCSI、SATA 或者 USB。它们将最慢的设备连接到系统，包括磁盘、鼠标及其他类似设备。</p>
<p><figure><img  loading="lazy" src='/posts/2021/02/d9090a0a/architecture.webp'    height="286" width="350"><figcaption class="image-caption">IO原型架构</figcaption>
</figure></p>
<p>考虑物理布局及造价成本。越快的I/O 设备的总线越短，因此高性能的内存总线没有足够的空间连接太多设备。另外，在工程上高性能总线的造价非常高。所以，系统的设计采用了这种分层的方式，这样可以让要求高性能的设
备（比如显卡）离 CPU 更近一些，低性能的设备离 CPU 远一些。将磁盘和其他低速设备连到外围总线的好处很多，其中较为突出的好处就是你可以在外围总线上连接大量的设备。</p>]]></description></item></channel></rss>