<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>DI - 标签 - Victor's Code Journey</title><link>http://www.victorchu.info/tags/di/</link><description>DI - 标签 - Victor's Code Journey</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><managingEditor>victorchu0610@outlook.com (victorchutian)</managingEditor><webMaster>victorchu0610@outlook.com (victorchutian)</webMaster><lastBuildDate>Fri, 10 Feb 2023 17:32:53 +0800</lastBuildDate><atom:link href="http://www.victorchu.info/tags/di/" rel="self" type="application/rss+xml"/><item><title>Guice简介</title><link>http://www.victorchu.info/posts/2023/02/901e9e8/</link><pubDate>Fri, 10 Feb 2023 17:32:53 +0800</pubDate><author><name>victorchutian</name></author><guid>http://www.victorchu.info/posts/2023/02/901e9e8/</guid><description><![CDATA[<div class="featured-image">
                <img src="/feature-images/java.webp" referrerpolicy="no-referrer">
            </div><p>Guice是一个轻量级依赖注入框架。关于什么是依赖注入可以查看以前的blog，这里就不赘述了。</p>]]></description></item><item><title>Java 依赖注入规范:javax-inject</title><link>http://www.victorchu.info/posts/2017/01/38555ebb/</link><pubDate>Fri, 27 Jan 2017 11:07:51 +0800</pubDate><author><name>victorchutian</name></author><guid>http://www.victorchu.info/posts/2017/01/38555ebb/</guid><description><![CDATA[<div class="featured-image">
                <img src="/feature-images/java.webp" referrerpolicy="no-referrer">
            </div><p>JSR-330 是Java的依赖注入规范。标准的依赖注入的类在<code>javax.inject</code>中定义。</p>]]></description></item><item><title>设计模式之依赖注入</title><link>http://www.victorchu.info/posts/2017/01/21e1fc41/</link><pubDate>Thu, 26 Jan 2017 11:36:22 +0800</pubDate><author><name>victorchutian</name></author><guid>http://www.victorchu.info/posts/2017/01/21e1fc41/</guid><description><![CDATA[<div class="featured-image">
                <img src="/feature-images/architecture.webp" referrerpolicy="no-referrer">
            </div><p>依赖关系注入是一种软件设计模式，其中一个或多个依赖关系（或服务）被注入或通过引用传递到依赖对象（或客户端）中，并成为客户端状态的一部分。该模式将客户端依赖项的创建与其自身行为分开，这允许程序设计松散耦合并遵循控制反转和单一责任原则。</p>
<p>简单来说，依赖注入通过请求获取它们的子组件而不是通过创建它们来获取, 将依赖关系的创建与其自身行为分开。</p>]]></description></item></channel></rss>