<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Tree - 标签 - Victor's Code Journey</title><link>http://www.victorchu.info/tags/tree/</link><description>Tree - 标签 - Victor's Code Journey</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><managingEditor>victorchu0610@outlook.com (victorchutian)</managingEditor><webMaster>victorchu0610@outlook.com (victorchutian)</webMaster><lastBuildDate>Thu, 07 Jul 2022 16:08:17 +0800</lastBuildDate><atom:link href="http://www.victorchu.info/tags/tree/" rel="self" type="application/rss+xml"/><item><title>Mysql存储树结构</title><link>http://www.victorchu.info/posts/2022/07/78e26fb6/</link><pubDate>Thu, 07 Jul 2022 16:08:17 +0800</pubDate><author><name>victorchutian</name></author><guid>http://www.victorchu.info/posts/2022/07/78e26fb6/</guid><description><![CDATA[<div class="featured-image">
                <img src="/feature-images/mysql.webp" referrerpolicy="no-referrer">
            </div><p>通常在mysql中存储树形结构的方案，是通过在子节点上存储父节点编号的方案来实现的。这种方案可以很直观的体现各个节点之间的关系，通常可以满足大多数需求。</p>
<p>但是当数据量变大和层级关系变深后，对于部分需求(例如，判断节点是否其他节点的子节点)这样的存储方式很难满足要求。这类需求实质上需要在内存中构建一棵树，通过遍历树来给出答案。如果还是使用parent_id这种存储模型，显然需要按照树的层级关系递归向下搜索。</p>]]></description></item></channel></rss>