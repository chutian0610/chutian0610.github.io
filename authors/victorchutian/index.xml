<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Victorchutian - 作者 - Victor's Code Journey</title><link>http://www.victorchu.info/authors/victorchutian/</link><description>Victorchutian - 作者 - Victor's Code Journey</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><managingEditor>victorchu0610@outlook.com (victorchutian)</managingEditor><webMaster>victorchu0610@outlook.com (victorchutian)</webMaster><lastBuildDate>Thu, 05 Feb 2026 17:55:13 +0800</lastBuildDate><atom:link href="http://www.victorchu.info/authors/victorchutian/" rel="self" type="application/rss+xml"/><item><title>将Blog从Hexo迁移至Hugo</title><link>http://www.victorchu.info/posts/2026/02/b4d9bbef/</link><pubDate>Thu, 05 Feb 2026 17:55:13 +0800</pubDate><author><name>victorchutian</name></author><guid>http://www.victorchu.info/posts/2026/02/b4d9bbef/</guid><description><![CDATA[<div class="featured-image">
                <img src="/feature-images/blog.webp" referrerpolicy="no-referrer">
            </div><p>最近完成了博客从 Hexo 到 Hugo 的迁移，这篇文章记录了迁移的完整历程，包括技术选型、具体实施步骤、遇到的问题以及解决方案。</p>]]></description></item><item><title>Apache Calcite 关系代数</title><link>http://www.victorchu.info/posts/2025/12/554cedc2/</link><pubDate>Thu, 18 Dec 2025 11:09:52 +0800</pubDate><author><name>victorchutian</name></author><guid>http://www.victorchu.info/posts/2025/12/554cedc2/</guid><description><![CDATA[<div class="featured-image">
                <img src="/feature-images/calcite.webp" referrerpolicy="no-referrer">
            </div><div class="details admonition note open">
    <div class="details-summary admonition-title">
        <span class="icon"><svg class="icon"
    xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!-- Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) --><path d="M497.9 142.1l-46.1 46.1c-4.7 4.7-12.3 4.7-17 0l-111-111c-4.7-4.7-4.7-12.3 0-17l46.1-46.1c18.7-18.7 49.1-18.7 67.9 0l60.1 60.1c18.8 18.7 18.8 49.1 0 67.9zM284.2 99.8L21.6 362.4.4 483.9c-2.9 16.4 11.4 30.6 27.8 27.8l121.5-21.3 262.6-262.6c4.7-4.7 4.7-12.3 0-17l-111-111c-4.8-4.7-12.4-4.7-17.1 0zM124.1 339.9c-5.5-5.5-5.5-14.3 0-19.8l154-154c5.5-5.5 14.3-5.5 19.8 0s5.5 14.3 0 19.8l-154 154c-5.5 5.5-14.3 5.5-19.8 0zM88 424h48v36.3l-64.5 11.3-31.1-31.1L51.7 376H88v48z"/></svg></span>未完待续<span class="details-icon"><svg class="icon"
    xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 512"><!-- Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) --><path d="M224.3 273l-136 136c-9.4 9.4-24.6 9.4-33.9 0l-22.6-22.6c-9.4-9.4-9.4-24.6 0-33.9l96.4-96.4-96.4-96.4c-9.4-9.4-9.4-24.6 0-33.9L54.3 103c9.4-9.4 24.6-9.4 33.9 0l136 136c9.5 9.4 9.5 24.6.1 34z"/></svg></span>
    </div>
    <div class="details-content">
        <div class="admonition-content">持续更新中&hellip;</div></div></div>
<p>本文主要介绍Calcite 中的AST转执行计划。关系代数最早由E. F. Codd在1970年的论文<a href="https://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf" target="_blank" rel="noopener noreferrer">A Relational Model of Data for Large Shared Data Banks</a>中提出, 是关系型数据库查询语言的基础, 也是查询优化技术的理论基础。 在Calcite内部, 会将SQL查询转化为一颗等价的关系算子树, 并在此基础上进行查询优化. 通用的关系代数理论可以参考之前的文章<a href="/posts/9e3f23c9/" rel="">形式化关系查询语言</a>, 接下来介绍在Calciate中的实现。</p>]]></description></item><item><title>Apache Calcite: SQL验证</title><link>http://www.victorchu.info/posts/2025/12/3e9140da/</link><pubDate>Mon, 08 Dec 2025 17:23:48 +0800</pubDate><author><name>victorchutian</name></author><guid>http://www.victorchu.info/posts/2025/12/3e9140da/</guid><description><![CDATA[<div class="featured-image">
                <img src="/feature-images/calcite.webp" referrerpolicy="no-referrer">
            </div><p>本文主要介绍Calcite 中的SQL Validator。Calcite 通过 SQL 校验器实现 SQL 绑定，SQL 校验器所需的 Catalog 信息，在<a href="/post/f2cd8cb8/" rel="">深入理解 Apache Calcite Catalog</a> 中已经做了详细的介绍。</p>
<blockquote>
  <p>SQL 绑定主要的作用是将 SQL 解析生成的 AST 和数据库的元数据进行绑定，从而生成具有语义的 AST。SQL 绑定会通过自底向上的方式遍历 AST，对抽象语法树中的节点进行绑定分析，绑定的过程中会将表、列等元数据附在语法树上，最后生成具有语义的语法树 Bounded AST。</p>

</blockquote>]]></description></item><item><title>Apache Calcite:SQL解析</title><link>http://www.victorchu.info/posts/2025/11/ef5a33c2/</link><pubDate>Thu, 13 Nov 2025 17:34:25 +0800</pubDate><author><name>victorchutian</name></author><guid>http://www.victorchu.info/posts/2025/11/ef5a33c2/</guid><description><![CDATA[<div class="featured-image">
                <img src="/feature-images/calcite.webp" referrerpolicy="no-referrer">
            </div><p>Calcite 中的SQL Parser 使用JavaCC 实现。JavaCC 在前面的博客中有过介绍, 本文就不赘述了。本文主要介绍Parser。</p>]]></description></item><item><title>JavaCC:Token Manager</title><link>http://www.victorchu.info/posts/2025/11/553c738f/</link><pubDate>Wed, 12 Nov 2025 16:19:57 +0800</pubDate><author><name>victorchutian</name></author><guid>http://www.victorchu.info/posts/2025/11/553c738f/</guid><description><![CDATA[<div class="featured-image">
                <img src="/feature-images/compiler.webp" referrerpolicy="no-referrer">
            </div><p>JavaCC的词法解析被转化为一组词法状态，每个状态都有一个唯一的标识符用于命名。Token Manager(生成的代码)在运行时总是处于状态之一，默认的一个词法状态是<code>DEFAULT</code>。当Token Manager初始化时，默认情况下是以<code>DEFAULT</code>状态开始。也可以在Token Manager 构造时，指定起始词法状态<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>。</p>]]></description></item><item><title>JavaCC 实现一个计算器</title><link>http://www.victorchu.info/posts/2025/11/ce505f18/</link><pubDate>Tue, 11 Nov 2025 17:23:34 +0800</pubDate><author><name>victorchutian</name></author><guid>http://www.victorchu.info/posts/2025/11/ce505f18/</guid><description><![CDATA[<div class="featured-image">
                <img src="/feature-images/compiler.webp" referrerpolicy="no-referrer">
            </div><p><a href="/posts/2025/11/66ec4c97/" rel="">上一篇文章</a>我们简单介绍了 JavaCC的语法和使用。本文将以实现一个计算器为例，介绍JavaCC 在实际代码中的使用。</p>]]></description></item><item><title>JavaCC 简介</title><link>http://www.victorchu.info/posts/2025/11/66ec4c97/</link><pubDate>Mon, 10 Nov 2025 14:36:35 +0800</pubDate><author><name>victorchutian</name></author><guid>http://www.victorchu.info/posts/2025/11/66ec4c97/</guid><description><![CDATA[<div class="featured-image">
                <img src="/feature-images/compiler.webp" referrerpolicy="no-referrer">
            </div><p>JavaCC 是 java 生态中常用的Parser Generator。特征如下:</p>
<ul>
<li>JavaCC 生成的解析器是基于LL 的，默认是LL(1)，通过配置可以支持 LL(K)。</li>
<li>由于是LL 方式，需要用户自己书写递归下降的语法规则来避免出现左递归问题。</li>
<li>JavaCC 支持 EBNF 语法范式。</li>
</ul>
<p>JavaCC的工作流程如下:</p>
<ul>
<li>令牌管理器读入一个字符序列并生成一个称为令牌的对象序列。用于将字符序列分解为标记序列的规则取决于语言-它们由用户作为正则表达式的集合提供。</li>
<li>解析器使用一个令牌序列，分析它的结构，并产生一个由用户定义的输出。</li>
</ul>
<p><img class="tw-inline" loading="lazy" src='/posts/2025/11/66ec4c97/javacc-design.webp'    height="558" width="560"></p>]]></description></item><item><title>git多账号通过ssh提交</title><link>http://www.victorchu.info/posts/2025/10/a40cdb91/</link><pubDate>Wed, 29 Oct 2025 14:18:01 +0800</pubDate><author><name>victorchutian</name></author><guid>http://www.victorchu.info/posts/2025/10/a40cdb91/</guid><description><![CDATA[<div class="featured-image">
                <img src="/feature-images/git.webp" referrerpolicy="no-referrer">
            </div><p>假设我有两个 github 账号，victor(for personal) 和 superman(for work)。如果我想在同一台电脑上使用这两个账号进行 git push/pull。该如何配置？</p>]]></description></item><item><title>Rust Future 共享状态</title><link>http://www.victorchu.info/posts/2025/08/1ff241/</link><pubDate>Wed, 20 Aug 2025 18:04:53 +0800</pubDate><author><name>victorchutian</name></author><guid>http://www.victorchu.info/posts/2025/08/1ff241/</guid><description><![CDATA[<div class="featured-image">
                <img src="/feature-images/rust.webp" referrerpolicy="no-referrer">
            </div><p>如何在 Rust 的多线程中共享值？</p>
<ul>
<li>共享值的方式是使用<code>Arc</code></li>
<li>修改值的方式是使用<code>Mutex</code></li>
</ul>]]></description></item><item><title>Rust Future 实现原理</title><link>http://www.victorchu.info/posts/2025/04/f6310143/</link><pubDate>Wed, 30 Apr 2025 16:46:17 +0800</pubDate><author><name>victorchutian</name></author><guid>http://www.victorchu.info/posts/2025/04/f6310143/</guid><description><![CDATA[<div class="featured-image">
                <img src="/feature-images/rust.webp" referrerpolicy="no-referrer">
            </div><p>Rust 既支持了基于系统线程的多线程编程模型，也支持了基于<code>async/await</code>的异步编程模型。Rust 的async编程有有以下特性:</p>
<ul>
<li>Future 在 Rust 中是惰性的</li>
<li>Async 在 Rust 中使用开销是零</li>
<li>Rust 没有内置异步调用所必需的运行时，但是社区生态中已经提供了非常优异的运行时实现，例如 tokio和async-std</li>
<li>运行时同时支持单线程和多线程</li>
</ul>]]></description></item></channel></rss>